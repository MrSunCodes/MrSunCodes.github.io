<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode-1356</title>
    <url>/2020/03/02/leetcode-1356/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/</a>  </p>
<a id="more"></a>
<img src="/2020/03/02/leetcode-1356/1.png" class="" title="[leetcode-1356]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct node&#123;&#x2F;&#x2F;自定义结构体</span><br><span class="line">        int data;</span><br><span class="line">        int num;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a,node b)&#123;&#x2F;&#x2F;自定义排序函数</span><br><span class="line">        return a.num&#x3D;&#x3D;b.num?a.data&lt;b.data;a.num&lt;b.num;</span><br><span class="line">    &#125;</span><br><span class="line">    int checked(int n)&#x2F;&#x2F;输入一个十进制数字，输出数字在二进制下1的个数</span><br><span class="line">    &#123;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        while (n!&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            if (n%2!&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            n&#x2F;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;       </span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        vector&lt;node&gt;V;</span><br><span class="line">        for(auto i:arr)&#123;</span><br><span class="line">            int num&#x3D;checked(i);</span><br><span class="line">            V.push_back(&#123;i,num&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(),V.end(),cmp);</span><br><span class="line">        arr.clear();</span><br><span class="line">        for(auto i:V)&#123;</span><br><span class="line">            arr.push_back(i.data);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/03/02/leetcode-1356/2.png" class="" title="[leetcode-1356]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题45</title>
    <url>/2020/02/29/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9845/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</a>  </p>
<a id="more"></a>
<img src="/2020/02/29/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9845/1.png" class="" title="[leetcode-面试题45]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">    string minNumber(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        vector&lt;string&gt; V(len);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V[i] &#x3D; to_string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (auto i : V)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很像179题，思路是一模一样的</p>
<img src="/2020/02/29/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9845/2.png" class="" title="[leetcode-面试题45]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1054</title>
    <url>/2020/02/28/leetcode-1054/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/distant-barcodes/">https://leetcode-cn.com/problems/distant-barcodes/</a>  </p>
<a id="more"></a>
<img src="/2020/02/28/leetcode-1054/1.png" class="" title="[leetcode-1054]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一开始自己的思路，排序后从前往后和从后往前依次输出一个数，直到遍历完成，too young too simple，sometimes naive</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt; &amp;barcodes)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        sort(barcodes.begin(), barcodes.end());</span><br><span class="line">        int i &#x3D; 0, j &#x3D; barcodes.size() - 1;</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &lt;&#x3D; j)</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(barcodes[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt;&#x3D; j)</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(barcodes[j]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*</span><br><span class="line">非常好的思路：使用map来保存每个数字出现的次数，然后存入优先队列中并根据次数进行从大到小的排序（需要自定义排序函数）</span><br><span class="line">然后每次取优先队列的头两个元素，放入vector并将其second减一，如果不为0再放回。这样一直</span><br><span class="line">到最后优先队列只剩一个元素0个元素，然后直接再将其放入vector中即可</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct cmp</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator()(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            return a.second &lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt; &amp;barcodes)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; P;</span><br><span class="line">        map&lt;int, int&gt; M;</span><br><span class="line">        for (auto it : barcodes)</span><br><span class="line">        &#123;</span><br><span class="line">            M[it]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it : M)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int, int&gt; temp;</span><br><span class="line">            temp.first &#x3D; it.first;</span><br><span class="line">            temp.second &#x3D; it.second;</span><br><span class="line">            P.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        while (P.size() &gt;&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            auto t1 &#x3D; P.top();</span><br><span class="line">            P.pop();&#x2F;&#x2F;别忘pop</span><br><span class="line">            auto t2 &#x3D; P.top();</span><br><span class="line">            P.pop();</span><br><span class="line">            V.push_back(t1.first);</span><br><span class="line">            V.push_back(t2.first);</span><br><span class="line">            if (--t1.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--t2.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (P.size() &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(P.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/28/leetcode-1054/2.png" class="" title="[leetcode-1054]">  
<p>这类题（周围元素没有相同的排序）思路就非常明显了：使用map，优先队列，然后依次从次数大的元素开始输出即可(跟前面的767重构字符串很像)<br>修改后的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">学了1054新方法之后回来重写的方法，根本思路与1054基本一致</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct cmp</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator()(const pair&lt;char, int&gt; &amp;a, const pair&lt;char, int&gt; &amp;b) const</span><br><span class="line">        &#123;</span><br><span class="line">            return a.second &lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;char, int&gt;, vector&lt;pair&lt;char, int&gt;&gt;, cmp&gt; P;</span><br><span class="line">        map&lt;char, int&gt; M;</span><br><span class="line">        for (auto it : S)</span><br><span class="line">        &#123;</span><br><span class="line">            M[it]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it : M)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;char, int&gt; temp;</span><br><span class="line">            temp.first &#x3D; it.first;</span><br><span class="line">            temp.second &#x3D; it.second;</span><br><span class="line">            P.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        int len&#x3D;S.size();</span><br><span class="line">        if (P.top().second &gt; (len + 1) &#x2F; 2) &#x2F;&#x2F;如果次数出现最多的字母大于字符串的一半长度，那么肯定是不可以成功的了</span><br><span class="line">        &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        while (P.size() &gt;&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            auto t1 &#x3D; P.top();</span><br><span class="line">            P.pop();</span><br><span class="line">            auto t2 &#x3D; P.top();</span><br><span class="line">            P.pop();</span><br><span class="line">            str +&#x3D; t1.first;</span><br><span class="line">            str +&#x3D; t2.first;</span><br><span class="line">            if (--t1.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--t2.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (P.size() &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; P.top().first;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/28/leetcode-1054/3.png" class="" title="[leetcode-1054]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-853</title>
    <url>/2020/02/26/leetcode-853/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/car-fleet/">https://leetcode-cn.com/problems/car-fleet/</a>  </p>
<a id="more"></a>
<img src="/2020/02/26/leetcode-853/1.png" class="" title="[leetcode-853]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">思路：一开始的思路是只要有一个还未到终点的瞬间，有多个车到了同一个距离，那么他们就是</span><br><span class="line">同一个车队，为了防止重复计算，就将这些划为车队的车进行flag&#x3D;false操作，使其不再进行</span><br><span class="line">下一步遍历，结果只对了十个测试点，思路错了</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int pos;</span><br><span class="line">        bool flag &#x3D; true;</span><br><span class="line">    &#125;;</span><br><span class="line">    int equalNum(vector&lt;node&gt; &amp;V) &#x2F;&#x2F;函数检查V中相等元素的个数并返回，还要修改flag</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;int, int&gt; P;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[i].flag)</span><br><span class="line">            &#123;</span><br><span class="line">                P[V[i].pos]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second &gt;&#x3D; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (V[i].pos &#x3D;&#x3D; it-&gt;first)</span><br><span class="line">                    &#123;</span><br><span class="line">                        V[i].flag &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    int carFleet(int target, vector&lt;int&gt; &amp;position, vector&lt;int&gt; &amp;speed)</span><br><span class="line">    &#123;</span><br><span class="line">        int len &#x3D; position.size();</span><br><span class="line">        vector&lt;node&gt; V(len);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V[i].pos &#x3D; position[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (V[i].pos + speed[i] &lt;&#x3D; target &amp;&amp; V[i].flag) &#x2F;&#x2F;车还没到终点并且车不会超过终点</span><br><span class="line">                &#123;</span><br><span class="line">                    V[i].pos +&#x3D; speed[i];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &#x3D;&#x3D; 1 || cnt &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            count +&#x3D; equalNum(V);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[i].flag)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">官方思路：先按距终点的距离降序排序，然后算出每个车到终点的时间</span><br><span class="line">从头开始遍历(排序之后也就是降序顺序),遇到第一个比它大的数之前的车都可以组成一个车队</span><br><span class="line">因为车只受它前面的车的影响(后面的车即使追上他了也要跟他同一个速度前进)</span><br><span class="line">如果它到终点的时间小于等于前面车到终点的时间，那么它就能追上前面的车，也就是组成一个车队</span><br><span class="line">所以只要他遇到比它大的数，那么那个数之后（包括那个数）都不会与前面的车组成一个车队</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int pos;</span><br><span class="line">        double time;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a,node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.pos&gt;b.pos;</span><br><span class="line">    &#125;</span><br><span class="line">    int carFleet(int target, vector&lt;int&gt; &amp;position, vector&lt;int&gt; &amp;speed)</span><br><span class="line">    &#123;    </span><br><span class="line">        int len &#x3D; position.size();</span><br><span class="line">        if (len&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;node&gt; V(len);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V[i].pos &#x3D; position[i];</span><br><span class="line">            V[i].time &#x3D; (target - position[i])*1.0 &#x2F; speed[i];&#x2F;&#x2F;向上取整</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(),V.end(),cmp);</span><br><span class="line">        int i&#x3D;0,j&#x3D;i,cnt&#x3D;0;</span><br><span class="line">        while (j&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[j].time&lt;&#x3D;V[i].time)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                i&#x3D;j;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt+1;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/26/leetcode-853/2.png" class="" title="[leetcode-853]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-179</title>
    <url>/2020/02/25/leetcode-179/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-number/">https://leetcode-cn.com/problems/largest-number/</a>  </p>
<a id="more"></a>
<img src="/2020/02/25/leetcode-179/1.png" class="" title="[leetcode-179]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a+b&gt;b+a;&#x2F;&#x2F;直接根据a+b和b+a中更大的来排序，简单粗暴</span><br><span class="line">    &#125;</span><br><span class="line">    string largestNumber(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; V;&#x2F;&#x2F;用来存nums数组元素转换为string元素</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp&#x3D;to_string(nums[i]);</span><br><span class="line">            V.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        for (auto i &#x3D; V.begin(); i !&#x3D; V.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; *i;</span><br><span class="line">        &#125;</span><br><span class="line">        while (str[0]&#x3D;&#x3D;&#39;0&#39;&amp;&amp;str.size()&gt;1)&#x2F;&#x2F;删除拼接字符串的首项为0的元素，知道只剩一个0为止</span><br><span class="line">        &#123;</span><br><span class="line">            str.erase(0,1);</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/25/leetcode-179/2.png" class="" title="[leetcode-179]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-274</title>
    <url>/2020/02/25/leetcode-274/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/h-index/">https://leetcode-cn.com/problems/h-index/</a>  </p>
<a id="more"></a>
<img src="/2020/02/25/leetcode-274/1.png" class="" title="[leetcode-274]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">思路：就是从1-V.size()进行遍历，看哪个数最后满足h指数的情况，然后输出即可</span><br><span class="line">注意要使用do-while，这样可以使得循环至少进行一次，若数组只有一个元素，那么</span><br><span class="line">for循环就会出错</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">    bool checked(int cnt, vector&lt;int&gt; &amp;V)</span><br><span class="line">    &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[i] &gt;&#x3D; cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count&gt;&#x3D;cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt; &amp;citations)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        int max &#x3D; 0, temp,i&#x3D;0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            if(checked(i, citations)&amp;&amp;i&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max&#x3D;i;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; while (i&lt;citations.size());     </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/25/leetcode-274/2.png" class="" title="[leetcode-274]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-56</title>
    <url>/2020/02/24/leetcode-56/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a>  </p>
<a id="more"></a>
  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：首先按区间开头从小到大排序，然后每次比较前两个元素并判断：如果第一个元素的区间结尾</span><br><span class="line">&#x2F;&#x2F;大于第二个元素的区间开头，说明两个区间重合，因为已经排序，所以改变第二个元素，它的区间开头</span><br><span class="line">&#x2F;&#x2F;一定是第一个元素的区间开头，它的区间结尾是第一个元素和第二个元素区间结尾的最大值&#123;比如[0,4],[1,3];和[0,4],[1,5]&#125;</span><br><span class="line">&#x2F;&#x2F;然后删除第一个元素即可</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt; v1, vector&lt;int&gt; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        return v1[0]&lt;v2[0];       </span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt; &amp;intervals)</span><br><span class="line">    &#123;</span><br><span class="line">        if (intervals.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        for (auto it &#x3D; intervals.begin(); it !&#x3D; intervals.end() - 1;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it[0][1] &gt;&#x3D; (it + 1)[0][0])</span><br><span class="line">            &#123;</span><br><span class="line">                (it + 1)[0][0] &#x3D; it[0][0];</span><br><span class="line">                (it + 1)[0][1] &#x3D; max(it[0][1],(it+1)[0][1]);</span><br><span class="line">                it &#x3D; intervals.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                it++;</span><br><span class="line">        &#125;</span><br><span class="line">        return intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-767</title>
    <url>/2020/02/24/leetcode-767/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reorganize-string/">https://leetcode-cn.com/problems/reorganize-string/</a>  </p>
<a id="more"></a>
<img src="/2020/02/24/leetcode-767/1.png" class="" title="[leetcode-767]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;767 lang&#x3D;cpp</span><br><span class="line"> *</span><br><span class="line"> * [767] 重构字符串</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">&#x2F;&#x2F;思路：</span><br><span class="line">&#x2F;*先构造S的哈希表，如果S的最大值-1(就是需要填充的地方)小于剩余元素的和，那么</span><br><span class="line">肯定可以重排使其相邻字符不同，否则不可；</span><br><span class="line">判断出其可以后，只需按P的顺序输出即可*&#x2F;</span><br><span class="line">&#x2F;&#x2F;60,61,62测试点未通过，感觉我的方法有点笨拙，果断换思路</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;char, int&gt; P;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; S.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[S[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int max &#x3D; -1;</span><br><span class="line">        char index;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max &#x3D; it-&gt;second;</span><br><span class="line">                index &#x3D; it-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;first !&#x3D; index)</span><br><span class="line">            &#123;</span><br><span class="line">                sum +&#x3D; it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (max - 1 &gt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag &#x3D; false;</span><br><span class="line">        if (max - 1 &#x3D;&#x3D; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;char, int&gt;&gt; V(P.begin(), P.end());</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        if (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                int cnt &#x3D; 0;</span><br><span class="line">                for (auto it &#x3D; V.begin(); it !&#x3D; V.end(); it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (it-&gt;second !&#x3D; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        str +&#x3D; it-&gt;first;</span><br><span class="line">                        it-&gt;second--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cnt &#x3D;&#x3D; V.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                int cnt &#x3D; 0;</span><br><span class="line">                for (auto it &#x3D; V.begin(); it !&#x3D; V.end(); it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (it-&gt;second !&#x3D; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        str +&#x3D; it-&gt;first;</span><br><span class="line">                        it-&gt;second--;</span><br><span class="line">                        if (it-&gt;first !&#x3D; index)</span><br><span class="line">                        &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cnt &#x3D;&#x3D; V.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*</span><br><span class="line">思路:</span><br><span class="line">根据字母出现的顺序排序，然后每次输出前两项即可(输出后记得减少前两项字母的次数)，输出后立刻再进行排序</span><br><span class="line">直到所有字母的次数都为0</span><br><span class="line">每次排序太麻烦，并且没有数据结构支持(set和优先队列当你进行--操作时就已经排序了所以不能保证第二项--时仍为原来的那一项)</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*</span><br><span class="line">第三个思路：</span><br><span class="line">借鉴的大神思路-先使用哈希表按出现顺序从大到小排列，然后按间隔进行插入</span><br><span class="line">贪心思想</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;char, int&gt; P;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; S.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[S[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;char, int&gt;&gt; V(P.begin(), P.end());</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        for (auto p : V)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp(p.second, p.first); &#x2F;&#x2F;String temp(2,&#39;c&#39;)&#x3D;&#x3D;&quot;cc&quot;</span><br><span class="line">            str +&#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; str.size();</span><br><span class="line">        if (V[0].second &gt; (len+1) &#x2F; 2)&#x2F;&#x2F;如果次数出现最多的字母大于字符串的一半长度，那么肯定是不可以成功的了</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        S.clear();</span><br><span class="line">        S &#x3D; (len, &#39;0&#39;);</span><br><span class="line">        int i &#x3D; 0, j &#x3D; 1, index &#x3D; 0;</span><br><span class="line">        while (i &lt; len &amp;&amp; index &lt; len)&#x2F;&#x2F;按奇数进行插入</span><br><span class="line">        &#123;</span><br><span class="line">            S[i] &#x3D; str[index++];</span><br><span class="line">            i +&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt; len &amp;&amp; index &lt; len)&#x2F;&#x2F;按偶数进行插入</span><br><span class="line">        &#123;</span><br><span class="line">            S[j] &#x3D; str[index++];</span><br><span class="line">            j +&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br></pre></td></tr></table></figure>
<img src="/2020/02/24/leetcode-767/2.png" class="" title="[leetcode-767]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-524</title>
    <url>/2020/02/23/leetcode-524/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/</a>  </p>
<a id="more"></a>
<img src="/2020/02/23/leetcode-524/1.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次做题</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        int count;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.count &#x3D;&#x3D; b.count ? a.str &lt; b.str : a.count &lt; b.count;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checked(string s, string str) &#x2F;&#x2F;看两个字符串是否是相对顺序</span><br><span class="line">    &#123;</span><br><span class="line">        int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">        bool flag &#x3D; true;</span><br><span class="line">        if (s.size() &gt; str.size()) &#x2F;&#x2F;保证双指针在相等时往后移的是长字符串的指针</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        while (first &lt; s.size() &amp;&amp; second &lt; str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[first] &#x3D;&#x3D; str[second])</span><br><span class="line">            &#123;</span><br><span class="line">                first++;</span><br><span class="line">                second++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (!flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#x2F;&#x2F;判断是否是相对顺序是看短字符串是否到了尽头</span><br><span class="line">        &#123;</span><br><span class="line">            if (second &#x3D;&#x3D; str.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (first &#x3D;&#x3D; s.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;node&gt; V;</span><br><span class="line">        map&lt;char, int&gt; P;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[s[i]]++; &#x2F;&#x2F;将字符串s出现的字母次数存入哈希表</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map&lt;char, int&gt; temp &#x3D; P;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            if (!checked(s, d[i])) &#x2F;&#x2F;如果不是相对顺序，那么直接跳过这个字符串</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; d[i].size(); j++) &#x2F;&#x2F;在需要判断的字符串中遍历，并每出现一个</span><br><span class="line">            &#123;                                     &#x2F;&#x2F;字母，就将其在哈希表中的数值-1,</span><br><span class="line">                temp[d[i][j]]--;                  &#x2F;&#x2F;如果出现-1表示不能组成字符串</span><br><span class="line">                if (temp[d[i][j]] &#x3D;&#x3D; -1)          &#x2F;&#x2F;剩余字母的次数相加越小者，说明其本身越长</span><br><span class="line">                &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                int cnt &#x3D; 0;</span><br><span class="line">                for (auto it &#x3D; temp.begin(); it !&#x3D; temp.end(); it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt +&#x3D; it-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">                V.push_back(&#123;d[i], cnt&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (V.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        return V[0].str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/2.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第二次优化，将第一次的大圈子剪短一半，不需要哈希表，双指针即可</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.size() &#x3D;&#x3D; b.size() ? a &lt; b : a.size() &gt; b.size();</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; V;</span><br><span class="line">        if (s.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            if (s.size() &gt; d[i].size()) &#x2F;&#x2F;保证双指针在相等时往后移的是长字符串的指针</span><br><span class="line">            &#123;</span><br><span class="line">                flag &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            while (first &lt; s.size() &amp;&amp; second &lt; d[i].size())</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[first] &#x3D;&#x3D; d[i][second])</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!flag)</span><br><span class="line">                    &#123;</span><br><span class="line">                        first++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        second++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag) &#x2F;&#x2F;判断是否是相对顺序是看短字符串是否到了尽头</span><br><span class="line">            &#123;</span><br><span class="line">                if (second &#x3D;&#x3D; d[i].size())</span><br><span class="line">                &#123;</span><br><span class="line">                    V.push_back(d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (first &#x3D;&#x3D; s.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    V.push_back(d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        if (V.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return V[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/3.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第三次优化，每次不需判断s与d[i]哪个大，都只让s大即可</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.size() &#x3D;&#x3D; b.size() ? a &lt; b : a.size() &gt; b.size();</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; V;</span><br><span class="line">        if (s.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            if (d[i].size() &gt; s.size()) &#x2F;&#x2F;只要一直让s的大小大于d[i],就会省很多行代码</span><br><span class="line">                swap(d[i], s);</span><br><span class="line">            while (first &lt; s.size() &amp;&amp; second &lt; d[i].size())</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[first] &#x3D;&#x3D; d[i][second])</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (second &#x3D;&#x3D; d[i].size())</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        if (V.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return V[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/4.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第四次优化，将所有计算size的操作全部赋值再使用</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string checked(string a, string b)&#x2F;&#x2F;不需要另加vector再排序后输出，进行简单的比较即可</span><br><span class="line">    &#123;</span><br><span class="line">        int size1&#x3D;a.size(),size2&#x3D;b.size();</span><br><span class="line">        if (size1 &#x3D;&#x3D; size2)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a &gt; b)</span><br><span class="line">            &#123;</span><br><span class="line">                return b;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return a;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (size1 &gt; size2)</span><br><span class="line">            &#123;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        int sSize&#x3D;s.size();</span><br><span class="line">        if (sSize &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            int dSize&#x3D;d[i].size();</span><br><span class="line">            if (dSize &gt; sSize) &#x2F;&#x2F;只要一直让s的大小大于d[i],就会省很多行代码</span><br><span class="line">                swap(d[i], s);</span><br><span class="line">            while (first &lt; sSize &amp;&amp; second &lt; dSize)</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[first] &#x3D;&#x3D; d[i][second])</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (second &#x3D;&#x3D; dSize)</span><br><span class="line">            &#123;</span><br><span class="line">                str &#x3D; checked(str,d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/5.png" class="" title="[leetcode-524]">  




]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-75</title>
    <url>/2020/02/22/leetcode-75/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors/">https://leetcode-cn.com/problems/sort-colors/</a>  </p>
<a id="more"></a>
<img src="/2020/02/22/leetcode-75/1.png" class="" title="[leetcode-75]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">我的思路：定两个指针，前指针指向第一个元素和后指针指向最后一个元素，然后从前往后扫描数组，遇到0，</span><br><span class="line">与前指针元素交换，前指针++；遇到1继续走，遇到2，与后指针元素交换，后指针--，前指针与后指针相等时跳出遍历，</span><br><span class="line">这样时间复杂度是O(n),空间复杂度是常数O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        int front &#x3D; 0, rear &#x3D; nums.size() - 1;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (i &lt;&#x3D; rear)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[front]);</span><br><span class="line">                i++;</span><br><span class="line">                front++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i] &#x3D;&#x3D; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[rear]);</span><br><span class="line">                rear--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i] &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>肺都气炸，思路跟迪杰斯特拉解决三色国旗问题的思路是一样的，但跳出循环条件不一样，我一开始写的条件是front!=rear,后来改成front!=rear-1也不对，压根没想到i一直往后走知道i&gt;rear跳出循环，只能说差一点吧，继续加油</p>
<img src="/2020/02/22/leetcode-75/2.png" class="" title="[leetcode-75]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-973</title>
    <url>/2020/02/22/leetcode-969/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/pancake-sorting">https://leetcode-cn.com/problems/pancake-sorting</a>  </p>
<a id="more"></a>
<img src="/2020/02/22/leetcode-969/1.png" class="" title="[leetcode-969]">  
<p>很有趣的一道题，一开始我的思路是找到先遍历一遍找到最大值，然后将最大值翻转到最后一位，然后每次遍历最大值都已经归位了。但是题目中只可以翻转前n项，所以只需要多一步辅助，将最大值翻转到第一位，然后再翻转到最后一位。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; pancakeSort(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        int temp &#x3D; 0;&#x2F;&#x2F;每一次循环最大的元素一定在正确位置，所以使用temp来缩短遍历长度</span><br><span class="line">        for (int j &#x3D; 0; j &lt; A.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int max &#x3D; -1, index &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; A.size() - temp; i++)&#x2F;&#x2F;寻找剩余元素中的最大值，返回其下标</span><br><span class="line">            &#123;</span><br><span class="line">                if (max &lt; A[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    max &#x3D; A[i];</span><br><span class="line">                    index &#x3D; i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (index &#x3D;&#x3D; 0)&#x2F;&#x2F;如果最大值恰好在第一个元素位置，那么直接进行翻转A.size() - temp长度将其转到剩余元素的最大位置</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(A.size() - temp);</span><br><span class="line">                reverseK(A, A.size() - temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(index + 1);&#x2F;&#x2F;先将其翻转到第一个元素位置</span><br><span class="line">                reverseK(A, index + 1);</span><br><span class="line">                V.push_back(A.size() - temp);&#x2F;&#x2F;再将第一个元素位置翻转到剩余元素最大值位置</span><br><span class="line">                reverseK(A, A.size() - temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void reverseK(vector&lt;int&gt; &amp;V, int k) &#x2F;&#x2F;翻转vector的前k个元素</span><br><span class="line">    &#123;</span><br><span class="line">        if (k &gt; V.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(V.begin(), V.begin() + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/22/leetcode-969/2.png" class="" title="[leetcode-969]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-973</title>
    <url>/2020/02/21/leetcode-973/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">https://leetcode-cn.com/problems/k-closest-points-to-origin/</a>  </p>
<a id="more"></a>
<img src="/2020/02/21/leetcode-973/1.png" class="" title="[leetcode-973]">  
<p>跟1030有异曲同工之妙，看1030思路即可  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        int c;</span><br><span class="line">        int dis;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.dis &lt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt; &amp;points, int K)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;node&gt; V;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node temp &#x3D; &#123;points[i][0], points[i][1], pow(points[i][0], 2) + pow(points[i][1], 2)&#125;;&#x2F;&#x2F;因为坐标只有两位，所以使用0,1即可得到点的横纵坐标</span><br><span class="line">            V.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; K; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(&#123;V[i].r, V[i].c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/21/leetcode-973/2.png" class="" title="[leetcode-973]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>解决新发布的文章中文乱码</title>
    <url>/2020/02/20/%E8%A7%A3%E5%86%B3%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>最近遇到了很麻烦的问题，就是我</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>创建了一个新文章之后，使用有道云笔记打开再编辑完后通过记录本的格式复制回去，发现线上的文章就是中文乱码了，包括标题和分类也是乱码，代码中的中文也会乱码。这里总结一下解决方法</p>
<blockquote>
<p>根本问题在于：使用记事本打开新文章后，默认的格式是ANSI,需要改成UTF-8并另存为。</p>
</blockquote>
<p>但有的时候另存为选择所有文件格式还是会存成.txt后缀的文件，所以这时要修改一下文件格式，将.md删掉重新输入.md，然后选择所有格式和UTF-8,这样保存时就会有是否替换的提示，替换后就会恢复中文了。</p>
<img src="/2020/02/20/%E8%A7%A3%E5%86%B3%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/1.png" class="" title="[解决新发布的文章中文乱码]">  
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-147</title>
    <url>/2020/02/20/leetcode-147/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/insertion-sort-list/">https://leetcode-cn.com/problems/insertion-sort-list/</a>  </p>
<img src="/2020/02/20/leetcode-147/1.png" class="" title="[leetcode-147]">  
<a id="more"></a>
<p>最基本的插入排序，难点应该在于数据结构使用的链表所以麻烦一些，不过思路是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *insertionSortList(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!head||!head-&gt;next)&#x2F;&#x2F;链表题这个是套路，必须要在前面加上</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy(0);&#x2F;&#x2F;dummy头结点法，就不多说了</span><br><span class="line">        dummy.next &#x3D; head;</span><br><span class="line">        ListNode *cur &#x3D; head-&gt;next;&#x2F;&#x2F;cur为当前要插入的点</span><br><span class="line">        head-&gt;next&#x3D;NULL;&#x2F;&#x2F;第一个点默认是已经排好的，所以与后面的链表元素断开</span><br><span class="line">        while (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *temp &#x3D; &amp;dummy;</span><br><span class="line">            while (temp-&gt;next-&gt;val &lt; cur-&gt;val)&#x2F;&#x2F;找到第一个比cur大的元素，即在temp后面插入cur元素</span><br><span class="line">            &#123;</span><br><span class="line">                temp &#x3D; temp-&gt;next;</span><br><span class="line">                if (!temp-&gt;next)&#x2F;&#x2F;如果找到最后temp已经到有序链表的结尾处还未找到比cur大的元素，则说明cur元素要插在有序链表的末尾</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;          </span><br><span class="line">            ListNode* res&#x3D;cur-&gt;next;&#x2F;&#x2F;res为保存下一个要插入的点的指针，因为之后cur会改变，所以要保存当前的位置</span><br><span class="line">            cur-&gt;next &#x3D; temp-&gt;next;&#x2F;&#x2F;在temp节点后面插入节点的两部曲</span><br><span class="line">            temp-&gt;next &#x3D; cur;</span><br><span class="line">            cur &#x3D; res;&#x2F;&#x2F;cur继续遍历</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/20/leetcode-147/2.png" class="" title="[leetcode-147]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-148</title>
    <url>/2020/02/20/leetcode-148/</url>
    <content><![CDATA[<img src="/2020/02/20/leetcode-148/1.png" class="" title="[leetcode-148]">  
<p><a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a>  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av31197206?from&#x3D;search&amp;seid&#x3D;13970831847445553437</span><br><span class="line">第一个方法:使用fast，slow快慢指针，这样快指针走到链表结尾时慢指针走到链表中间，使链表一分为二，这样再分别对两个部分进行排序sort(l1),sort(l2)</span><br><span class="line">然后再合并merge(l1,l2).因为排序部分是用到递归，所以空间复杂度为O(logn),时间复杂度为O(nlogn)</span><br><span class="line">注意一开始时fast一定是head-&gt;next，而slow为head，因为如果fast和slow都是同一起点，那么如果链表是1-&gt;3-&gt;5时，fast第二次迭代就会变成野指针了(null-&gt;next)</span><br><span class="line">而fast在初始化时就往后退一格正好避免这种错误情况，这样跳出循环的条件是slow在链表中央时，fast为NULL或fast-&gt;next&#x3D;&#x3D;NULL</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *sortList(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#x2F;&#x2F;如果链表只有一个元素或没有元素，则直接返回即可无需排序</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast &#x3D; head-&gt;next;</span><br><span class="line">        ListNode *slow &#x3D; head;</span><br><span class="line">        while (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *mid &#x3D; slow-&gt;next;</span><br><span class="line">        slow-&gt;next &#x3D; NULL;</span><br><span class="line">        return merge(sortList(mid), sortList(head));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ListNode *merge(ListNode *list1, ListNode *list2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode dummy(0);       &#x2F;&#x2F;链表的构造函数</span><br><span class="line">        ListNode *tail &#x3D; &amp;dummy; &#x2F;&#x2F;这个引用很关键，tail是指针指向dummy，tail伴随着插入的元素一直走到链表尾部</span><br><span class="line">        while (list1 &amp;&amp; list2)   &#x2F;&#x2F;就是merge的标准格式代码，双指针比较</span><br><span class="line">        &#123;</span><br><span class="line">            if (list1-&gt;val &gt; list2-&gt;val) &#x2F;&#x2F;这样的好处就是始终让list1-&gt;val&lt;list2-&gt;val，这样始终是将list1放入tail后面</span><br><span class="line">            &#123;</span><br><span class="line">                swap(list1, list2);</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1-&gt;next;</span><br><span class="line">            tail &#x3D; tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1) &#x2F;&#x2F;如果跳出循环后list1还存在，就将剩余的list1元素接到tail后面即可</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list2) &#x2F;&#x2F;同理</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/20/leetcode-148/2.png" class="" title="[leetcode-148]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">第二个方法：使用for循环进行merge操作，而不是用递归操作，这样时间复杂度不变,空间复杂度为O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *sortList(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!head || !head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp &#x3D; head;</span><br><span class="line">        int len &#x3D; 0;&#x2F;&#x2F;len是链表的长度</span><br><span class="line">        while (temp)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            temp &#x3D; temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy(0);</span><br><span class="line">        dummy.next &#x3D; head;</span><br><span class="line">        ListNode *l;</span><br><span class="line">        ListNode *r;</span><br><span class="line">        ListNode *tail;</span><br><span class="line">        for (int n &#x3D; 1; n &lt; len; n *&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            tail &#x3D; &amp;dummy;</span><br><span class="line">            ListNode *cur &#x3D; dummy.next;</span><br><span class="line">            while (cur)&#x2F;&#x2F;cur走到链表结尾会为NULL</span><br><span class="line">            &#123;</span><br><span class="line">                l &#x3D; cur;&#x2F;&#x2F;l在cur位置上</span><br><span class="line">                r &#x3D; split(l, n);&#x2F;&#x2F;r是l位置取n个元素后(并断开)的剩下元素链表的头指针</span><br><span class="line">                cur &#x3D; split(r, n);&#x2F;&#x2F;cur是r位置取n个元素后(并断开)剩下的元素链表的头指针</span><br><span class="line">                auto result &#x3D; merge(l, r);&#x2F;&#x2F;将l和r两个链表进行merge并将其绑定到tail后</span><br><span class="line">                tail-&gt;next &#x3D; result.first;</span><br><span class="line">                tail &#x3D; result.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ListNode *split(ListNode *head, int n)&#x2F;&#x2F;是将head链表分割n个元素出去，得到n个元素的链表和剩下元素的链表，比如1-&gt;4-&gt;3-&gt;2， n&#x3D;1,</span><br><span class="line">    &#123;&#x2F;&#x2F;那么分割1个元素后head&#x3D;1,rest&#x3D;4-&gt;3-&gt;2，并且head的后续是断开的即head-&gt;next&#x3D;NULL。函数的操作就是分割链表并断开链表</span><br><span class="line">        while (head &amp;&amp; --n)</span><br><span class="line">        &#123;</span><br><span class="line">            head &#x3D; head-&gt;next;&#x2F;&#x2F;找到要分割的最后一个元素</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *rest &#x3D; head ? head-&gt;next : NULL;&#x2F;&#x2F;如果head不为空，那么rest就为head-&gt;next(因为head是分割的最后一个元素，head-&gt;next就是rest链表的头)，否则就将rest置为NULL</span><br><span class="line">        if (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next &#x3D; NULL;&#x2F;&#x2F;别忘了将要分离的元素和rest元素断开</span><br><span class="line">        &#125;</span><br><span class="line">        return rest;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;ListNode *, ListNode *&gt; merge(ListNode *list1, ListNode *list2)&#x2F;&#x2F;相比第一种方法多返回一个链表的尾指针，这样方便在sortList中将tail直接绑定到尾指针上</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode dummy(0);</span><br><span class="line">        ListNode *tail &#x3D; &amp;dummy;</span><br><span class="line">        while (list1 &amp;&amp; list2)</span><br><span class="line">        &#123;</span><br><span class="line">            if (list1-&gt;val &gt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(list1, list2);</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1-&gt;next;</span><br><span class="line">            tail &#x3D; tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1)</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list2)</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list2;</span><br><span class="line">        &#125;</span><br><span class="line">        while (tail-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            tail &#x3D; tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;dummy.next, tail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/20/leetcode-148/3.png" class="" title="[leetcode-148]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-976</title>
    <url>/2020/02/17/leetcode-976/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">https://leetcode-cn.com/problems/largest-perimeter-triangle/</a>  </p>
<img src="/2020/02/17/leetcode-976/1.png" class="" title="[leetcode-976]">  
<a id="more"></a>
<p>第一个算法：先排序，然后从后面往前遍历，因为是三边，所以取三次遍历，每次判断是否是三角形，如果是则返回，不是的话最后函数跳出0，但是一看就超时了  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#x2F;&#x2F;这个算法超时了</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int largestPerimeter(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; i - 1; j &gt;&#x3D; 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int m &#x3D; j - 1; m &gt;&#x3D; 0; m--)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (A[m] + A[j] &gt; A[i]) &#x2F;&#x2F;因为是三角形三边从小到大依次是A[m],A[j]和A[i](因为排序并且从后向前遍历)，所以只需三角形最短的两边比第三边大即可</span><br><span class="line">                    &#123;</span><br><span class="line">                        return A[i] + A[j] + A[m];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/17/leetcode-976/2.png" class="" title="[leetcode-976]">  
<p>第二个算法：在第一个算法的基础上改进，因为如果遍历三次，肯定是这种情况:比如排好序之后数组为1,3,5,7.取得是3,5,7；1,5,7；1,3,5这样取。但实际上如果3,5,7无法组成三角形，那么1,5,7一定也不可以，因为1比3小。<br>所以我们只需一个大小为3的滑动窗口，然后从数组最后往前移动即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int largestPerimeter(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        for (int i &#x3D; A.size() - 3; i &gt;&#x3D; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (A[i]+A[i+1]&gt;A[i+2])&#x2F;&#x2F;因为从小到大为A[i]，A[i+1]，A[i+2]，只要满足最小的两边之和大于第三边即可</span><br><span class="line">            &#123;</span><br><span class="line">                return A[i]+A[i+1]+A[i+2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/17/leetcode-976/3.png" class="" title="[leetcode-976]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1030</title>
    <url>/2020/02/16/leetcode-1030/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">https://leetcode-cn.com/problems/matrix-cells-in-distance-order/</a>  </p>
<img src="/2020/02/16/leetcode-1030/1.png" class="" title="[leetcode-1030]">  

<a id="more"></a>  

<p>我的思路是既然是按距离排序，那我就创建一个struct node，然后使用sort的重载cmp函数进行排序，最后再只将struct node的横纵坐标加入到二维数组中。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        int c;</span><br><span class="line">        int dis;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.dis &lt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        vector&lt;node&gt; V;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; R; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; C; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                node temp &#x3D; &#123;i, j, abs(i - r0) + abs(j - c0)&#125;;&#x2F;&#x2F;创建temp节点并放入V中</span><br><span class="line">                V.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);&#x2F;&#x2F;排序</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(&#123;V[i].r, V[i].c&#125;);&#x2F;&#x2F;将V中的元素放入vec中，但只放入横纵坐标</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/leetcode-1030/2.png" class="" title="[leetcode-1030]">  

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-数组的相对排序</title>
    <url>/2020/02/15/leetcode-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/relative-sort-array/">https://leetcode-cn.com/problems/relative-sort-array/</a>  </p>
<a id="more"></a>
<img src="/2020/02/15/leetcode-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/1.png" class="" title="[leetcode-数组的相对排序]">  
<p>这道题我的思路是只需在arr1中找到arr2中依次出现的元素，然后放入vector中，但是需要将每一个放入vector中的元素删除，这样时间复杂度就会变小。不过我看还有计数排序的方法，也可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt; &amp;arr1, vector&lt;int&gt; &amp;arr2)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        for (auto it1 &#x3D; arr2.begin(); it1 !&#x3D; arr2.end(); it1++)</span><br><span class="line">        &#123;</span><br><span class="line">            auto it2 &#x3D; arr1.begin();</span><br><span class="line">            while (it2 !&#x3D; arr1.end())</span><br><span class="line">            &#123;</span><br><span class="line">                if (*it2 &#x3D;&#x3D; *it1)</span><br><span class="line">                &#123;</span><br><span class="line">                    V.push_back(*it2);</span><br><span class="line">                    it2 &#x3D; arr1.erase(it2);&#x2F;&#x2F;从arr1中删除it2指针指向的元素</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    it2++;&#x2F;&#x2F;如果没匹配成功，必须要指针后移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(), arr1.end());&#x2F;&#x2F;将剩下的元素排序后再放入V中</span><br><span class="line">        for (auto i &#x3D; arr1.begin(); i !&#x3D; arr1.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(*i);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/15/leetcode-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/2.png" class="" title="[leetcode-数组的相对排序]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-按奇偶判断数组</title>
    <url>/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<img src="/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/1.png" class="" title="[leetcode-按奇偶判断数组]">  
<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</a><br>见到这个题的思路是：  </p>
<a id="more"></a>
<p>先将数组排序一遍，然后从头遍历判断每个位置：<br>1.如果当前位置为正确的数(奇数位置为奇数，偶数位置为偶数),那么就continue<br>2.如果当前位置不是正确的数，那么从这个数的下一个数开始一直到数组最后一个元素进行遍历，找到第一个适合当前位置的数，使他俩交换。<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        &#x2F;&#x2F; sort(A.begin(), A.end());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((A[i] % 2 &#x3D;&#x3D; 0 &amp;&amp; i % 2 &#x3D;&#x3D; 0) || (A[i] % 2 !&#x3D; 0 &amp;&amp; i % 2 !&#x3D; 0))&#x2F;&#x2F;当前位置为正确的数</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j &#x3D; i + 1; j &lt; A.size(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if ((A[i] % 2 &#x3D;&#x3D; 0 &amp;&amp; A[j] % 2 !&#x3D; 0) || (A[i] % 2 !&#x3D; 0 &amp;&amp; A[j] % 2 &#x3D;&#x3D; 0))&#x2F;&#x2F;已知当前位置为错误的数，那么我只需往后找和他奇偶相反的数即可</span><br><span class="line">                    &#123;                                                                   &#x2F;&#x2F;比如上面的数是一个奇数，他的i是偶数，那么我只需在后面找一个偶数与自己交换即可</span><br><span class="line">                        swap(A[i], A[j]);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto i &#x3D; 0; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/2.png" class="" title="[leetcode-按奇偶判断数组]">  
<p>其实，最后的答案不是唯一的，不需要从头到尾为正序，所以第一步的sort没必要，优化以后就是只将代码中sort那一行注释即可  </p>
<img src="/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/3.png" class="" title="[leetcode-按奇偶判断数组]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-两个数组的交集</title>
    <url>/2020/02/13/leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<img src="/2020/02/13/leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/2.png" class="" title="[leetcode-两个数组的交集]">  
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">https://leetcode-cn.com/problems/intersection-of-two-arrays/</a><br>这道题我的思路一开始是我先把两个数组进行排序，然后使用双指针思想，分别从两个数组的开头进行遍历，遇到相等时就把它们放到vector中，不相等时数小的指针往后移，直到数组超界。</p>
<a id="more"></a>
<p>结果我想的太复杂，实际上两个数组排好序后只要有一个超界，那么就可以break了，因为你已经排好了序，当一个数组超界时，另外一个数组就算没超界，其后面的元素也无法与超界数组进行匹配。而且最简单的办法就是引入一个set，先把相等的元素放入set中，再放到vector里，但是我一开始想着不想再多使用另一个数据结构了。但实际上使用set更简单一点。<br>代码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;349 lang&#x3D;cpp</span><br><span class="line"> *</span><br><span class="line"> * [349] 两个数组的交集</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        set&lt;int&gt;S;</span><br><span class="line">        if (nums1.size() &#x3D;&#x3D; 0 || nums2.size() &#x3D;&#x3D; 0)&#x2F;&#x2F;如果一开始其中一个数组没有元素，那么就不会有相同的元素，输出空即可</span><br><span class="line">        &#123;</span><br><span class="line">            return V;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums1.begin(), nums1.end());&#x2F;&#x2F;排序</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; nums1.size() || j &#x3D;&#x3D; nums2.size())&#x2F;&#x2F;如果其中一个数组超界，那么直接break</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums1[i] &#x3D;&#x3D; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                S.insert(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;         </span><br><span class="line">            else if (nums1[i] &lt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums1[i] &gt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it &#x3D; S.begin(); it !&#x3D; S.end(); it++)&#x2F;&#x2F;将set中元素拷贝到vector中</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br></pre></td></tr></table></figure>

<img src="/2020/02/13/leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/1.png" class="" title="[leetcode-两个数组的交集]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>you-get批量下载视频</title>
    <url>/2020/02/05/you-get%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>今天在b站上看到了一个很喜欢的网课，怕被和谐，所以想下载下来，但网页端b站没有下载的渠道，使用其他的下载方式还需要下软件，所以又由csdn博客上了解到使用you-get第三方库可以非常轻松的下载b站视频(当然也支持很多其他视频平台)，所以使用一下，效果非常棒，(当然也有缺点，比如下载速度有些慢)不过可以批量下载，所以瑕不掩瑜吧。  </p>
<a id="more"></a>
<p><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E">官方详细中文文档</a><br>直接控制台输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install you-get</span><br></pre></td></tr></table></figure>
<p>即可安装成功  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">you-get --playlist  -o F:\bilibili https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av6731067</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\bilibili</span><br></pre></td></tr></table></figure>
<p>是下载到f盘bilibili文件夹下(需要先自行创建文件夹)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av6731067</span><br></pre></td></tr></table></figure>
<p>是视频的地址，这样后台就可以下载成功了。  </p>
<img src="/2020/02/05/you-get%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/1.png" class="" title="[you-get批量下载视频]">  

<img src="/2020/02/05/you-get%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/2.png" class="" title="[you-get批量下载视频]">  



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>下载视频</tag>
        <tag>python</tag>
        <tag>you-get</tag>
      </tags>
  </entry>
  <entry>
    <title>理解RESTful</title>
    <url>/2020/01/31/%E7%90%86%E8%A7%A3RESTful/</url>
    <content><![CDATA[<p>一、REST  </p>
<blockquote>
<p>REST：即 Representational State Transfer，（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便， 所以正得到越来越多网站的采用。</p>
</blockquote>
<p>具体说，就是 HTTP 协议里面，四个表示操作方式的动 词：<br>GET、POST、PUT、DELETE。<br>它们分别对应四种基本操作：<br>GET 用来获取资源<br>POST 用来新建资源<br>PUT 用来更新资源<br>DELETE 用来删除资源  </p>
<a id="more"></a>
<p>URL示例 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看ticket 12</span><br><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>


<p>二、幂等性<br>理解RESTful的幂等性，并且设计符合幂等规范的高质量RESTful API。</p>
<p>HTTP幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p>
<p>HTTP GET方法<br>HTTP GET方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看ticket 12</span><br></pre></td></tr></table></figure>

<p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p>
<p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个HTTP GET方法可能会每次得到不同的返回内容，但并不影响资源。</p>
<p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     &#x2F;service_time # 获取服务器当前时间</span><br></pre></td></tr></table></figure>

<p>它本身不会对资源本身产生影响，因此满足幂等性。</p>
<p>HTTP POST方法<br>HTTP POST方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br></pre></td></tr></table></figure>

<p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p>
<p>HTTP PUT方法<br>HTTP PUT方法是不是幂等的呢？我们来看下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p>
<p>HTTP PATCH方法<br>HTTP PATCH方法是非幂等的。HTTP POST方法和HTTP PUT方法可能比较好理解，但是HTTP PATCH方法只是更新部分资源，怎么是非幂等的呢? 我们举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条ticket记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p>
<p>HTTP DELETE方法<br>HTTP DELETE方法用于删除资源，会将资源删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>

<p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p>
<p>三、如何设计符合幂等性的高质量RESTful API<br>HTTP GET方法 vs HTTP POST方法<br>也许，你会想起一个面试题。HTTP请求的GET与POST方式有什么区别？你可能会回答到：GET方式通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。但是，我们现在从RESTful的资源角度来看待问题，HTTP GET方法是幂等的，所以它适合作为查询操作，HTTP POST方法是非幂等的，所以用来表示新增操作。</p>
<p>但是，也有例外，我们有的时候可能需要把查询方法改造成HTTP POST方法。比如，超长（1k）的GET URL使用POST方法来替代，因为GET受到URL长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p>
<p>HTTP POST方法 vs HTTP PUT方法<br>对于HTTP POST方法和HTTP PUT方法，我们一般的理解是POST表示创建资源，PUT表示更新资源。当然，这个是正确的理解。</p>
<p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST方法是非幂等，所以用来表示创建资源，HTTP PUT方法是幂等的，因此表示更新资源更加贴切。</p>
<p>HTTP PUT方法 vs HTTP PATCH方法<br>此时，你看会有另外一个问题。HTTP PUT方法和HTTP PATCH方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是PUT表示更新全部资源，PATCH表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH方法是非幂等的，因此我们在设计我们服务端的RESTful API的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用HTTP PUT方法。</p>
]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus实战-5</title>
    <url>/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-5/</url>
    <content><![CDATA[<p>sql性能分析插件：<br>在MyBatisPlusConfig中添加性能分析插件：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * SQL 执行性能分析插件</span><br><span class="line">     * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)&#x2F;&#x2F; 设置 dev test 环境开启</span><br><span class="line">    public PerformanceInterceptor performanceInterceptor() &#123;</span><br><span class="line">        PerformanceInterceptor performanceInterceptor &#x3D; new PerformanceInterceptor();</span><br><span class="line">        performanceInterceptor.setMaxTime(100);&#x2F;&#x2F;ms，超过此处设置的ms则sql不执行，抛出异常信息，提示优化程序</span><br><span class="line">        performanceInterceptor.setFormat(true);</span><br><span class="line">        return performanceInterceptor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在配置文件中设置dev环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#环境设置：dev、test、prod</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties</p>
</blockquote>
<p>测试CRUDTest中的插入操作：</p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-5/1.png" class="" title="[Mybatis-plus实战-5]">  
<p>若将setMaxTime的参数值改小为小于40的数，就会报错。</p>
<p>学完MyBatis-plus大体功能后，整个项目结构是这样的：</p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-5/2.png" class="" title="[Mybatis-plus实战-5]">  
]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus实战-4</title>
    <url>/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/</url>
    <content><![CDATA[<p>1.Delete<br>1.1 根据id删除记录  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteById(8L);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/1.jpg" class="" title="[Mybatis-plus实战-4]">  
<p>1.2 根据id批量删除记录  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteBatchIds() &#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteBatchIds(Arrays.asList(8, 9, 10));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/2.jpg" class="" title="[Mybatis-plus实战-4]">  
<p>1.3 使用map进行简单查询删除  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    简单条件删除：先组装hashmap，再使用deleteByMap方法进行删除</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testDeleteByMap() &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;name&quot;, &quot;Sandy&quot;);</span><br><span class="line">        map.put(&quot;age&quot;, 21);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.deleteByMap(map);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/3.jpg" class="" title="[Mybatis-plus实战-4]">  
<p><strong>1.4 逻辑删除</strong>  </p>
<blockquote>
<p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据<br>逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p>
</blockquote>
<p>(1)  逻辑删除即在表中新加一个逻辑字段deleted，类型是tinyint，长度为1，默认为0(新版mysql没有布尔类型，都是用一位长度的tinyint类型表示，默认为0表示没有被删除，1表示被删除了)<br>(2)  在实体类中加入以下字段  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@TableLogic</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>

<p>(3)在配置文件中添加以下字段  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#逻辑删除的配置</span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-value&#x3D;1</span><br><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value&#x3D;0</span><br></pre></td></tr></table></figure>

<p>在做删除操作时，mybatis-plus检测到有逻辑删除，那么就会自动的将删除操作更改为更新操作，并将deleted字段更新为1。<br>(4)在MyBatisPlusConfig类中注册逻辑删除插件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;逻辑删除插件</span><br><span class="line">    @Bean</span><br><span class="line">    public ISqlInjector sqlInjector() &#123;</span><br><span class="line">        return new LogicSqlInjector();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑删除功能成功！现在开始测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 测试 逻辑删除</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testLogicDelete() &#123;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.deleteById(5L);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>==测试后发现，数据并没有被删除，deleted字段的值由0变成了1<br>测试后分析打印的sql语句，是一条update<br>注意：被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作==  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/4.png" class="" title="[Mybatis-plus实战-4]">  
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/5.jpg" class="" title="[Mybatis-plus实战-4]">  

<p>逻辑查询测试：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 测试 逻辑删除后的查询：</span><br><span class="line">     * 不包括被逻辑删除的记录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testLogicDeleteSelect() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(null);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时查询将不会带有逻辑删除后的结果  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/6.png" class="" title="[Mybatis-plus实战-4]">  




]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus实战-3</title>
    <url>/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/</url>
    <content><![CDATA[<p>1.Select<br>1.1根据id查询记录：  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectById()&#123;</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/1.png" class="" title="[Mybatis-plus实战-3]">  
<p>1.2根据多个id查询记录：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectBatchIds()&#123;&#x2F;&#x2F;多个id查询</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectBatchIds(Arrays.asList(1, 2, 3));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/2.png" class="" title="[Mybatis-plus实战-3]">  
<p>1.3 使用map进行条件查询  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectByMap()&#123;&#x2F;&#x2F;使用map封装查询条件</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;name&quot;, &quot;Helen&quot;);</span><br><span class="line">        map.put(&quot;age&quot;, 18);</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectByMap(map);</span><br><span class="line"></span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/3.png" class="" title="[Mybatis-plus实战-3]">  
<blockquote>
<p>需要注意的一点是：map中的key对应==数据库中的列名==。如：数据库user_id，实体类是userId，这时map的key需要填写user_id</p>
</blockquote>
<p>使用map进行条件查询的<strong>缺点</strong>：只能精确匹配，无法查询大于小于等等。</p>
<p>1.4 分页插件<br>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能<br>在MyBatisPlusConfig中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">        return new PaginationInterceptor();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新建分页测试，其最终通过page对象获取相关数据：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectPage() &#123;</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(1,5);&#x2F;&#x2F;第一个参数:页码，第二个参数:每页的数量</span><br><span class="line">        userMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">        page.getRecords().forEach(System.out::println);</span><br><span class="line">        System.out.println(page.getCurrent());&#x2F;&#x2F;当前页码</span><br><span class="line">        System.out.println(page.getPages());&#x2F;&#x2F;总页数</span><br><span class="line">        System.out.println(page.getSize());&#x2F;&#x2F;每页记录数</span><br><span class="line">        System.out.println(page.getTotal());&#x2F;&#x2F;总记录数</span><br><span class="line">        System.out.println(page.hasNext());&#x2F;&#x2F;是否有下一页内容</span><br><span class="line">        System.out.println(page.hasPrevious());&#x2F;&#x2F;是否有上页内容</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/4.png" class="" title="[Mybatis-plus实战-3]">  
<p>1.5 分页使用map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectMapsPage() &#123;&#x2F;&#x2F;结果集是Map</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(1, 5);</span><br><span class="line"></span><br><span class="line">        IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage &#x3D; userMapper.selectMapsPage(page, null);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;注意：此行必须使用 mapIPage 获取记录列表，否则会有数据类型转换错误</span><br><span class="line">        mapIPage.getRecords().forEach(System.out::println);</span><br><span class="line">        System.out.println(page.getCurrent());</span><br><span class="line">        System.out.println(page.getPages());</span><br><span class="line">        System.out.println(page.getSize());</span><br><span class="line">        System.out.println(page.getTotal());</span><br><span class="line">        System.out.println(page.hasNext());</span><br><span class="line">        System.out.println(page.hasPrevious());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.6使用条件构造器进行查询</strong><br>1.6.1 wrapper介绍  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/5.png" class="" title="[Mybatis-plus实战-3]">  
<p>创建一个新的测试类用于测试12种wrapper查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class QueryWrapperTests &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.6.2 12种常见语句(使用时字段均为数据库内字段)：<br>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    ge:greater and equals 大于等于</span><br><span class="line">    gt:greater than 大于</span><br><span class="line">    le:less and equals 小于等于</span><br><span class="line">    lt:less than 小于</span><br><span class="line">    isNull: 为空</span><br><span class="line">    isNotNull：不为空</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testDelete() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper</span><br><span class="line">                .isNull(&quot;name&quot;)</span><br><span class="line">                .ge(&quot;age&quot;, 12)</span><br><span class="line">                .isNotNull(&quot;email&quot;);</span><br><span class="line">        int result &#x3D; userMapper.delete(queryWrapper);</span><br><span class="line">        System.out.println(&quot;delete return count &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    eq:equals 等于</span><br><span class="line">    ne:not equals 不等于</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectOne() &#123;&#x2F;&#x2F;只能查询一条记录，多于一条便报错</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(&quot;name&quot;, &quot;Tom&quot;);</span><br><span class="line"></span><br><span class="line">        User user &#x3D; userMapper.selectOne(queryWrapper);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    between: 包括</span><br><span class="line">    notBetween ：不包括</span><br><span class="line">     *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">    public void testSelectCount() &#123;&#x2F;&#x2F;包括大小边界，即可以取到20和30</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.between(&quot;age&quot;, 20, 30);</span><br><span class="line"></span><br><span class="line">        Integer count &#x3D; userMapper.selectCount(queryWrapper);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;allEq: 所有条件都是等于的</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectList() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;id&quot;, 2);</span><br><span class="line">        map.put(&quot;name&quot;, &quot;Jack&quot;);</span><br><span class="line">        map.put(&quot;age&quot;, 20);</span><br><span class="line"></span><br><span class="line">        queryWrapper.allEq(map);</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>5.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    like: 包含</span><br><span class="line">    notLike: 不包含</span><br><span class="line">    likeLeft: 这个val左边模糊匹配(%val)</span><br><span class="line">    likeRight: 这个val右面模糊匹配(val%)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectMaps() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper</span><br><span class="line">                .notLike(&quot;name&quot;, &quot;e&quot;)</span><br><span class="line">                .likeRight(&quot;email&quot;, &quot;t&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; userMapper.selectMaps(queryWrapper);&#x2F;&#x2F;返回值是Map列表</span><br><span class="line">        maps.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>6.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    in: notIn(&quot;age&quot;,&#123;1,2,3&#125;)---&gt;age not in (1,2,3)</span><br><span class="line">    notIn: notIn(&quot;age&quot;, 1, 2, 3)---&gt;age not in (1,2,3)</span><br><span class="line">    inSql:子查询中包括 ：inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)---&gt;age in (1,2,3,4,5,6)；inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3)</span><br><span class="line">    notinSql: 子查询中不包括：</span><br><span class="line">    exists:</span><br><span class="line">    notExists:</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectObjs() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;queryWrapper.in(&quot;id&quot;, 1, 2, 3);</span><br><span class="line">        queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; objects &#x3D; userMapper.selectObjs(queryWrapper);&#x2F;&#x2F;返回值是Object列表</span><br><span class="line">        objects.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    不调用or则默认为使用 and ，</span><br><span class="line">    or表示或</span><br><span class="line">    and表示和</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testUpdate1() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改值</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setAge(99);</span><br><span class="line">        user.setName(&quot;Andy&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改条件</span><br><span class="line">        UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">        userUpdateWrapper</span><br><span class="line">                .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">                .or()</span><br><span class="line">                .between(&quot;age&quot;, 20, 30);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>8.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   使用lambda表达式进行嵌套or、嵌套and操作，跟testUpdate1类似，</span><br><span class="line">   当需要组装较为复杂的sql查询条件时，可以使用lambda表达式提升语句优先级，即可做到嵌套</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Test</span><br><span class="line">   public void testUpdate2() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;修改值</span><br><span class="line">       User user &#x3D; new User();</span><br><span class="line">       user.setAge(99);</span><br><span class="line">       user.setName(&quot;Andy&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;修改条件</span><br><span class="line">       UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">       userUpdateWrapper</span><br><span class="line">               .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">               .or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;age&quot;, 20));&#x2F;&#x2F;or里面有and</span><br><span class="line"></span><br><span class="line">       int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>9.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    orderBy:</span><br><span class="line">    orderByDesc:查询结果倒序排列</span><br><span class="line">    orderByAsc:查询结果正序排列</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectListOrderBy() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByDesc(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>10.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接拼接到 sql 的最后，只能调用一次,多次调用以最后一次为准，谨慎使用，有sql注入风险</span><br><span class="line">&#x2F;&#x2F;在sql最后添加自定义代码片段</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectListLast() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.last(&quot;limit 1&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>11.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指定要查询的列,不需要展示表中所有的列</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectListColumn() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>12.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为更新操作指定查询条件</span><br><span class="line">    @Test</span><br><span class="line">    public void testUpdateSet() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改值</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setAge(99);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改条件</span><br><span class="line">        UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">        userUpdateWrapper</span><br><span class="line">                .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">                .set(&quot;name&quot;, &quot;老李头&quot;)&#x2F;&#x2F;除了可以查询还可以使用set设置修改的字段</span><br><span class="line">                .setSql(&quot; email &#x3D; &#39;123@qq.com&#39;&quot;);&#x2F;&#x2F;可以有子查询</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus实战-2</title>
    <url>/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/</url>
    <content><![CDATA[<p><strong>实现CURD接口：</strong><br>1、Insert:<br>新建Insert测试类  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class CRUDTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testInsert()&#123;</span><br><span class="line"></span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setName(&quot;Helen&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line">        user.setEmail(&quot;55317332@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.insert(user);</span><br><span class="line">        System.out.println(result); &#x2F;&#x2F;影响的行数</span><br><span class="line">        System.out.println(user); &#x2F;&#x2F;id自动回填</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入的id为19位  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/1.jpg" class="" title="[mybatis-plus实战-2]">
<p><em>1.1主键策略</em><br>MyBatis-Plus默认的主键策略是：ID_WORKER  全局唯一ID<br>参考资料：分布式系统唯一ID生成方案汇总：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a><br><em>1.2自增策略</em><br>实现主键自增，要进行如下配置  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/2.png" class="" title="[mybatis-plus实战-2]">
<p>如果想要想影响所有实体的配置，可以在配置文件中设置全局主键配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局设置主键生成策略</span><br><span class="line">mybatis-plus.global-config.db-config.id-type&#x3D;auto</span><br></pre></td></tr></table></figure>

<p>主键配置的其他类型(通过源码可得)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum IdType &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数据库ID自增</span><br><span class="line">     *&#x2F;</span><br><span class="line">    AUTO(0),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 该类型为未设置主键类型</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NONE(1),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用户输入ID</span><br><span class="line">     * 该类型可以通过自己注册自动填充插件进行填充</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INPUT(2),</span><br><span class="line"></span><br><span class="line">    &#x2F;* 以下3种类型、只有当插入对象ID 为空，才自动填充。 *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局唯一ID (idWorker)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ID_WORKER(3),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局唯一ID (UUID)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    UUID(4),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 字符串全局唯一ID (idWorker 的字符串表示)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ID_WORKER_STR(5);</span><br><span class="line"></span><br><span class="line">    private int key;</span><br><span class="line"></span><br><span class="line">    IdType(int key) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Update<br><em>2.1编写Update测试类–此时是根据id进行更新</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testUpdate() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setId(1222451509303422980L);&#x2F;&#x2F;设置要修改的id</span><br><span class="line"></span><br><span class="line">        user.setEmail(&quot;text@mail.com&quot;);&#x2F;&#x2F;设置要修改的内容</span><br><span class="line">        int result &#x3D; userMapper.updateById(user);&#x2F;&#x2F;result为影响的行数，传entity类型参数即user</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>2.2自动填充</em><br>例如创建时间和更新时间，这是每个表必须有的，但不需要我们手动填充，应配置并根据当时的时间自动填充。<br>为实体配置：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/3.png" class="" title="[mybatis-plus实战-2]">
<p>相关的类型如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum FieldFill &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认不处理</span><br><span class="line">     *&#x2F;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入填充字段</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INSERT,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 更新填充字段</span><br><span class="line">     *&#x2F;</span><br><span class="line">    UPDATE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入和更新填充字段</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INSERT_UPDATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在包下创建Handler文件夹并创建MyMetaObjectHandler类继承MetaObjectHandler，重写其两个方法insertFill和updateFill  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;必须要写</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;&#x2F;&#x2F;插入时自动填充</span><br><span class="line">        System.out.println(&quot;插入时自动填充：-------&quot;);</span><br><span class="line">        this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);&#x2F;&#x2F;第一个字段必须是entity中的fieldName，并且第二个字段必须与第一个字段的类型一样</span><br><span class="line">        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;&#x2F;&#x2F;更新时自动填充</span><br><span class="line">        System.out.println(&quot;更新时自动填充：-------&quot;);</span><br><span class="line">        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别使用之前的InsertTest和UpdateTest测试，发现成功  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/4.jpg" class="" title="[mybatis-plus实战-2]">

<hr>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/5.jpg" class="" title="[mybatis-plus实战-2]">
<p><em>2.3乐观锁</em>  </p>
<blockquote>
<p>主要适用场景：当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新。分为四个步骤：<br>1.取出记录时，获取当前version：假设取出的version=1<br>2.更新时，带上这个version<br>3.执行更新时， set version = newVersion where version = oldVersion<br>4.如果version不对，就更新失败</p>
</blockquote>
<p>在数据库中新建version字段，类型为int，默认值是0  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/6.jpg" class="" title="[mybatis-plus实战-2]">
<p>在User类中新加属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Version</span><br><span class="line">    private Integer version;</span><br></pre></td></tr></table></figure>

<p>在包中新建一个文件夹config，里面建一个类MyBatisPlusConfig并配置乐观锁插件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span><br><span class="line">public class MyBatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;</span><br><span class="line">        return new OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乐观锁的测试  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 测试 乐观锁插件</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testOptimisticLocker() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;必须要先查询，用于获取version的值</span><br><span class="line">        User user &#x3D; userMapper.selectById(1222451509303422980L);</span><br><span class="line">        &#x2F;&#x2F;修改数据</span><br><span class="line">        user.setName(&quot;Helen Yao&quot;);</span><br><span class="line">        user.setEmail(&quot;helen@qq.com&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行更新</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/7.png" class="" title="[mybatis-plus实战-2]">
<p>一共执行两个sql语句，注意第二个sql语句，后面的条件不光是id是否等于id，而且version是否等于oldversion<br>数据库内：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/8.jpg" class="" title="[mybatis-plus实战-2]">
<p>version以加一</p>
]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus实战-1</title>
    <url>/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/</url>
    <content><![CDATA[<p><strong>1、创建数据库</strong><br>mybatis_plus  </p>
<a id="more"></a>
<p><strong>2.创建User表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS user;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user</span><br><span class="line">(</span><br><span class="line">	id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,</span><br><span class="line">	name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,</span><br><span class="line">	age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,</span><br><span class="line">	email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,</span><br><span class="line">	PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM user;</span><br><span class="line"></span><br><span class="line">INSERT INTO user (id, name, age, email) VALUES</span><br><span class="line">(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),</span><br><span class="line">(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),</span><br><span class="line">(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),</span><br><span class="line">(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),</span><br><span class="line">(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);</span><br></pre></td></tr></table></figure>

<p>最后的表结构如下：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/1.png" class="" title="[mybatis-plus实战-1]">
<p><strong>3、使用 Spring Initializr 快速初始化一个 Spring Boot 工程</strong><br>==Group：com.atguigu<br>Artifact：mybatis_plus<br>版本：2.0.7.RELEASE==<br>引入三个新依赖：<br>mybatis-plus-boot-starter、MySQL、lombok  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--mybatis-plus--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.0.5&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!--mysql--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--lombok用来简化实体类--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>别忘下载lombok插件。<br><strong>4、配置</strong>  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/2.png" class="" title="[mybatis-plus实战-1]">  
<p><strong>5、编写</strong><br>新建entity文件夹后新建User类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建mapper文件夹后新建UserMapper接口  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动类中添加MapperScan注解，文件夹就是上面创建的文件夹目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span><br><span class="line">public class MybatisPlusApplication &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、测试</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class MybatisPlusApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectList() &#123;</span><br><span class="line">        System.out.println((&quot;----- selectAll method test ------&quot;));</span><br><span class="line">        &#x2F;&#x2F;UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper</span><br><span class="line">        &#x2F;&#x2F;所以不填写就是无任何条件</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(null);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/3.png" class="" title="[mybatis-plus实战-1]">  
<p>成功!</p>
]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战-第一章-Spring之旅-2</title>
    <url>/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/</url>
    <content><![CDATA[<p>继续上节内容：  </p>
<a id="more"></a>  
<p>2.容纳你的Bean<br>2.1 使用应用上下文  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/1.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>在基于Spring的应用中，应用对象生存于Spring容器中，且容器负责创建对象，装载它们，配置它们并管理整个生命周期，从生存到死亡。<br>Spring容器有多个容器实现：<br>==bean工厂==和==应用上下文==，bean工厂对大多数企业级开发太低级，所以主要讨论应用上下文。<br>下列是可能用得到的应用上下文：  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/2.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>可以使用上述方法加载bean。且上下文准备就绪后，可以调用上下文的getBean()方法从Spring容器中获取bean。<br>2.2 bean的生命周期<br>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用， 则由Java自动进行垃圾回收。 而Spring容器中的bean的生命周期相对复杂，大体如下图所示：  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/3.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>3.俯瞰Spring风景线  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/4.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>4.Spring新功能<br>没什么好说的，因为之前几个版本我也没学过，从Spring 4.0开始算起。<br>5.小结<br>Spring致力于简化企业级Java开发，促进代码的松散耦合。==成功的关键在于依赖注入和AOP==。DI是组装应用对象的一种方式，==借助这种方式对象无需知道依赖来自何处或者依赖的实现方式==。不同于自己获取依赖对象，对象会在运行期赋予它们所依赖的对象。依赖对象通常会通过接口了解所注入的对象，这样的话就能确保低耦合。<br>除了DI，我们还简单介绍了Spring对AOP的支持。AOP可以帮助应用将散落在各处的逻辑汇集于一处——切面。当Spring装配bean的时候，这些切面能够在运行期编织起来，这样就能非常有效地赋予bean新的行为。==DI和AOP是Spring框架最核心的部分。==</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战-第一章-Spring之旅</title>
    <url>/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p><strong><em>Spring之旅</em></strong><br>Spring是一个开源框架，用于简化Java企业级应用开发，并且可以使JAVA应用变得简单，可测试和松耦合。  </p>
<a id="more"></a>  
<p>本章内容：<br>1.激发POJO的潜能<br>1.1 Spring可以通过依赖注入使得普通的类变成Spring组件。  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/1.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>DamselRescuingKnight在构造函数中自行创建了RescueDamselQuest类，==这使得两个类耦合到了一起==，这样如果DamselRescuingKnight想要修改功能时RescueDamselQuest也需要改变，并且为其编写单元测试非常困难。  </p>
<blockquote>
<p>耦合具有两面性：一方面，紧密耦合的代码难以测试，难以服用，难以理解，并且表现出打地鼠式bug特性(修一个又出一个)；另一方面，一定程度的耦合是必须的，只要对于两个类想要交互，必须就有耦合。</p>
</blockquote>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/2.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/3.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>通过依赖注入，对象的依赖关系将由系统中负责协调个对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理他们的依赖关系，依赖关系奖杯自动注入到需要它们的对象当中去。</p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/4.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>这一次BraveKnight没有自行创建任务，而是在构造函数中传入参数来规定其任务是什么(Quest就是任务),这是依赖注入的方式之一，即构造器注入(Constructor Injection)  </p>
<blockquote>
<p>这种形式，大大降低耦合度，如果一个对象通过接口来表明依赖关系，那么这种依赖就能在对象不知情的情况下用不同的具体实现进行替换。  </p>
</blockquote>
<p>由上面的类，它现在可以接受任何我传递给他的Quest的实现，下面是把特定的Quest传送给它的办法:  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/5.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>SlayDragonQuest是要注入到BraveKnight的特定Quest实现，它实现了Quest接口，准备注入到BraveKnight。<br>创建应用组件之间协作的行为通常称为装配(wiring)，Spring有多重装备bean的方式，XML是其中一种也是最常见的一种，使用Spring配置文件便可以将其装配在一起。<br>==XML方式：==  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/6.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>==Java类方式：==  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/7.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>在具体工作时，Spring通过应用上下文(Application Context)装载bean的定义并把他们组装起来，<br>加载方式：  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/8.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>这里的main方法导入knights.xml并获取id为knight的bean，得到Knight对象的引用后，只需要简单调用该对象的embarkOnQuest方法即可，并且这个类完全不知道骑士要接受哪种探险任务，也没有意识到是由BraveKnight执行的。</p>
<p>1.2 应用切面：</p>
<blockquote>
<p>面向切面编程(Aspect-oriented programming,AOP)：系统由许多不同的组件构成，每个组件各负责一块特定功能，除了实现自身核心的功能之外，还需要承担着额外的职责(比如事务管理和安全这样的系统服务),但这会带来双重复杂性：</p>
</blockquote>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/9.png" class="" title="[Spring实战-第一章-Spring之旅]">   

<hr>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/10.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>但AOP能够使这些服务模块化，并以声明的形式将他们应用到他们需要影响到的组件中去。简单来说，AOP能够确保POJO(Plain Ordinary Java Object，简单JAVA对象)的简单性  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/11.png" class="" title="[Spring实战-第一章-Spring之旅]">   

<hr>
<p>举例说明：  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/12.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/13.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>Minstrel有两个类，分别在探险任务之前和之后调用，但是这样的话BraveKnight肯定要调用Minstrel，并且在他自己的方法中，但吟游诗人应该做他分内的事情，并不需要骑士提醒他这么做，并且这样做使BraveKnight的代码变得复杂。==解决的方法就是将Minstrel抽象为一个切面，只需在Spring配置文件中声明即可。==</p>
<hr>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/14.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>注意几个标签：<br>&lt;aop:aspect ref=”bean”&gt;引用bean<br>&lt;aop:pointcut &gt;定义切点<br>&lt;aop:before &gt;前置通知<br>&lt;aop:after &gt;后置通知<br>通过这样调用，Minstrel可以被应用到BraveKnight中，并且BraveKnight不需要显式地调用它，即BraveKnight根本不知道Minstrel的存在。<br>1.3 使用模板消除样板式代码  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/15.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>如图所示的样板式代码，最核心的查询员工数据代码只占很小一部分，因为都由创建数据库连接，创建语句对象，捕捉异常，关闭数据库连接，再捕捉异常所占满。  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/16.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>而使用Spring的JdbcTemplate重写的getEmployeeById()只关注查询员工数据的逻辑，这样大大减少了样板式代码的冗余。</p>
<p>第一章剩余内容：</p>
<p>2.容纳你的Bean<br>3.俯瞰Spring风景线<br>4.Spring新功能<br>5.小结  </p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>添加总站访问量和文章访问量</title>
    <url>/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/</url>
    <content><![CDATA[<p>1、配置是否开启不蒜子访问量统计功能<br>在<strong>themes/yilia/_config.yml</strong>添加属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否开启访问量统计功能(不蒜子)</span><br><span class="line">busuanzi:</span><br><span class="line"> enable: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<img src="/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/1.png" class="" title="[添加总站访问量和文章访问量]">
<p>2、引入不蒜子并添加站点访问量<br><strong>在themes/yilia/layout/_partial/footer.ejs</strong>对应位置(不能超过&lt;footer/)添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">                本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot; style&#x3D;&#39;display:none&#39;&gt;</span><br><span class="line">                本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/2.png" class="" title="[添加总站访问量和文章访问量]">
<p>3、添加文章访问量<br>在<strong>themes/yilia/layout/_partial/post/date.ejs</strong>开头添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_page_pv&quot; style&#x3D;&#39;display:none&#39; class&#x3D;&quot;&lt;%&#x3D; class_name %&gt;&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;icon-smile icon&quot;&gt;&lt;&#x2F;i&gt; 阅读数：&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/3.png" class="" title="[添加总站访问量和文章访问量]">

<p>重启即可查看效果啦~</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>修改hexo博客代码块样式</title>
    <url>/2020/01/22/%E4%BF%AE%E6%94%B9hexo%E5%8D%9A%E5%AE%A2%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>直接修改编译好的文件。路径为： theme/yilia/source/main.0cf68a.css<br>修改代码背景色，搜索 .article-entry .highlight, 修改background后面的颜色</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pre&#123;background:#272822;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pre&#123;background:#1a0139;</span><br></pre></td></tr></table></figure>
<p>修改行号颜色，搜索 .article-entry .highlight .gutter pre .line<br>将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .gutter pre .line&#123;</span><br><span class="line">    color:#666</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .gutter pre .line&#123;</span><br><span class="line">      color:#fc0000</span><br></pre></td></tr></table></figure>
<p>修改代码字体颜色 .article-entry .highlight .line</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .line&#123;</span><br><span class="line">color:#fff;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .line&#123;</span><br><span class="line">color:#00ff0d;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>由树的前序遍历和中序遍历推后序遍历&amp;&amp;由树的中序遍历和后序遍历推前序遍历</title>
    <url>/2020/01/22/%E7%94%B1%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E7%94%B1%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>假设树是酱婶的  </p>
<img src="/2020/01/22/%E7%94%B1%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E7%94%B1%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/1.png" class="" title="[由树的前序遍历和中序遍历推后序遍历&amp;&amp;由树的中序遍历和后序遍历推前序遍历]">  
<p>首先前序遍历为 123456，中序遍历为324165，没什么问题，如果不会求前序或中序百度一下就好</p>
<a id="more"></a>
<h2 id="1-由树的前序遍历和中序遍历推后序遍历"><a href="#1-由树的前序遍历和中序遍历推后序遍历" class="headerlink" title="1.由树的前序遍历和中序遍历推后序遍历"></a>1.由树的前序遍历和中序遍历推后序遍历</h2><p>定义函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postorder(int root,int start,int end)</span><br></pre></td></tr></table></figure>

<p>root是前序遍历中当前树的根节点索引（单看中序遍历找不到根节点，前序遍历就可以）<br>start为当前树在中序遍历中的起点索引<br>end为当前树在中序遍历中的终点索引<br><strong>所以函数入口为(0,0,5)</strong><br><strong>因为整个树的根节点在前序遍历的索引为0，整个树的起点在中序遍历中的起点为0，终点为最后一个点下标即5</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void postorder(int root, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	if (start &gt; end)&#x2F;&#x2F;如果左区间大于右区间，直接返回函数，当这个区间只有一个元素之后的下一个递归函数就是在这里弹出</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int rot &#x3D; preorder[root];&#x2F;&#x2F;当前根节点</span><br><span class="line">	int index;&#x2F;&#x2F;index找到inorder中对应根节点的索引</span><br><span class="line">	for (int i &#x3D; 0; i &lt; inorder.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (inorder[i] &#x3D;&#x3D; rot)</span><br><span class="line">		&#123;</span><br><span class="line">			index &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	post(root + 1, start, index - 1);&#x2F;&#x2F;递归左子树，root+1就是左子树的根节点在preorder中的索引</span><br><span class="line">	post(root + 1 + index -  start, index + 1, end);&#x2F;&#x2F;递归右子树，第一个参数中index-start是指左子树的个数，root+1+左子树的个数就是右子树的根节点在preorder中的索引</span><br><span class="line">	postorder.push_back(preorder[root]);&#x2F;&#x2F;将当前根节点放入postorder中（后序遍历是左右根的顺序）</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：preorder，inorder，postorder分别是前序遍历，中序遍历和后序遍历的向量。</em></strong></p>
<h2 id="2-由树的中序遍历和后序遍历推前序遍历"><a href="#2-由树的中序遍历和后序遍历推前序遍历" class="headerlink" title="2.由树的中序遍历和后序遍历推前序遍历"></a>2.由树的中序遍历和后序遍历推前序遍历</h2><p>基本思想跟上述一样，只不过根节点每次都是从后序遍历中从后往前找（1中是从前序遍历中从前往后找，所以总的函数基本一样，只不过后面递归函数参数以及将当前根节点放入向量中的顺序不太一样）<br><strong>函数入口为(5,0,5)</strong><br><strong>因为整个树的根节点在后序遍历的索引为5（后序遍历最后一个值），整个树的起点在中序遍历中的起点为0，终点为最后一个点下标即5</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void preorder(int root, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	if (start &gt; end)&#x2F;&#x2F;如果左区间大于右区间，直接返回函数，当这个区间只有一个元素之后的下一个递归函数就是在这里弹出</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int rot &#x3D; postorder[root];&#x2F;&#x2F;当前根节点</span><br><span class="line">	int index;&#x2F;&#x2F;index找到inorder中对应根节点的索引</span><br><span class="line">	for (int i &#x3D; 0; i &lt; inorder.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (inorder[i] &#x3D;&#x3D; rot)</span><br><span class="line">		&#123;</span><br><span class="line">			index &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	preorder.push_back(postorder[root]);&#x2F;&#x2F;将当前根节点放入preorder中（后序遍历是根左右的顺序）</span><br><span class="line">	post(root-(end-index)-1, start, index - 1);&#x2F;&#x2F;递归左子树，第一个参数中end-index是指右子树的个数，root-右子树的个数-1就是左子树的根节点在preorder中的索引	</span><br><span class="line">	post(root-1, index + 1, end);&#x2F;&#x2F;递归右子树，root-1就是右子树的根节点在preorder中的索引</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：preorder，inorder，postorder仍然分别是前序遍历，中序遍历和后序遍历的向量。</em></strong><br>其次，最难的部分就是函数中第一个参数，只要找准左子树跟右子树的根节点索引即可<br>因为前序遍历是根左右，所以左子树的根节点是root+sth（这里是加号）<br>因为后序遍历是左右根，所以得左右子树根节点时是root-sth（这里是减号）<br><strong>同时注意:前序遍历中root+1先得到的是左子树根节点（因为是根左右），其次加上右子树的个数就是右子树根节点。而后序遍历中root-1先得到的是右子树根节点（因为是左右根），其次减上左子树的个数就是左子树根节点。</strong>  </p>
<p>成了，以上就是简单模式下的由树的前序遍历和中序遍历推后序遍历&amp;&amp;由树的中序遍历和后序遍历推前序遍历，简单模式下假定树的所有节点的值都是不相同的，所以困难模式下还有树中有相等的值，此时会有一些变式，有时间我会在写下来。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的基本操作（数据结构）</title>
    <url>/2020/01/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<p>看了很多博客许多大牛的文章，发现他们的方法即巧妙又简便，果断学习并理解。结合所学的知识，把二叉树的基本操作罗列了下来。<br>废话不多说，直接上源码，一些不容易理解的地方会有注释，要是有问题也可以私信我QQ``:790567648交个朋友互相学习鸭~</p>
<a id="more"></a>
<p><strong>———头文件，宏定义以及树ADT的实现**</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;头文件</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;宏定义</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">&#x2F;&#x2F;ADT</span><br><span class="line">typedef int TElemType;</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef struct BiTNode              &#x2F;&#x2F;定义二叉树节点数据类型 </span><br><span class="line">&#123;</span><br><span class="line">	TElemType data;</span><br><span class="line">	struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;           &#x2F;&#x2F;bitree为指向bitnode这种结构的指针</span><br></pre></td></tr></table></figure>
<p><strong>———-基本操作的声明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BiTree CreateTree();&#x2F;&#x2F;按先序次序输入二叉树中结点的值（一个字符）空格字符表示空数</span><br><span class="line">Status PreOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;先序遍历二叉树T,对每个结点调用函数VIsit一次且仅一次</span><br><span class="line">Status InOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;中序。。。</span><br><span class="line">Status PostOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;后序。。。</span><br><span class="line">Status LevelOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;层序。。。</span><br><span class="line">Status Deepth(BiTree T);&#x2F;&#x2F;求树的高度</span><br><span class="line">Status PreorderPrintLeaves(BiTree BT);&#x2F;&#x2F;先序输出树的结点</span><br></pre></td></tr></table></figure>
<p><strong>———-具体的函数的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BiTree CreateTree()&#x2F;&#x2F;二叉树的建立</span><br><span class="line">&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	TElemType item;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;item);</span><br><span class="line">	if (item &#x3D;&#x3D; 0)              &#x2F;&#x2F;叶节点数据标志：其后根两个0 </span><br><span class="line">		T &#x3D; NULL;            &#x2F;&#x2F;若某一节点为叶子结点，则其左右子树均为NULL，0表示建空树</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		T &#x3D; (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">		T-&gt;data &#x3D; item;</span><br><span class="line">		T-&gt;lchild &#x3D; CreateTree();             &#x2F;&#x2F;递归创建其左子树 </span><br><span class="line">		T-&gt;rchild &#x3D; CreateTree();            &#x2F;&#x2F;递归创建其右子树 </span><br><span class="line">	&#125;</span><br><span class="line">	return T;                              &#x2F;&#x2F;返回根节点 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PrintElement(TElemType e)&#x2F;&#x2F;应用函数具体实现</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d &quot;, e);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PreOrderTraverse1(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;先序遍历递归</span><br><span class="line">&#123;</span><br><span class="line">	if (T)</span><br><span class="line">	&#123;</span><br><span class="line">		if (Visit(T-&gt;data))</span><br><span class="line">			if (PreOrderTraverse1(T-&gt;lchild, Visit))</span><br><span class="line">				if (PreOrderTraverse1(T-&gt;rchild, Visit))</span><br><span class="line">					return OK;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status InOrderTraverse1(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;中序遍历递归</span><br><span class="line">&#123;</span><br><span class="line">	if (T)</span><br><span class="line">	&#123;</span><br><span class="line">		if (PreOrderTraverse1(T-&gt;lchild, Visit))</span><br><span class="line">			if (Visit(T-&gt;data))</span><br><span class="line">				if (PreOrderTraverse1(T-&gt;rchild, Visit))</span><br><span class="line">					return OK;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PostOrderTraverse1(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;后序遍历递归</span><br><span class="line">&#123;</span><br><span class="line">	if (T)</span><br><span class="line">	&#123;</span><br><span class="line">		if (PreOrderTraverse1(T-&gt;lchild, Visit))</span><br><span class="line">			if (PreOrderTraverse1(T-&gt;rchild, Visit))</span><br><span class="line">				if (Visit(T-&gt;data))</span><br><span class="line">					return OK;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status PreOrderTraverse2(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;先序遍历非递归</span><br><span class="line">&#123;	</span><br><span class="line">	BiTree P &#x3D; T;</span><br><span class="line">	stack&lt;BiTree&gt;S;</span><br><span class="line">	while (P!&#x3D;NULL||!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		while (P!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			Visit(P-&gt;data);</span><br><span class="line">			S.push(P);</span><br><span class="line">			P &#x3D; P-&gt;lchild;</span><br><span class="line">		&#125;	</span><br><span class="line">	if (!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		P&#x3D;S.top();</span><br><span class="line">		S.pop();</span><br><span class="line">		P &#x3D; P-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status InOrderTraverse2(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;中序遍历非递归</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;BiTree&gt;S;</span><br><span class="line">	BiTree P &#x3D; T;</span><br><span class="line">	while (P!&#x3D;NULL||!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		while (P!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			S.push(P);</span><br><span class="line">			P &#x3D; P-&gt;lchild;			</span><br><span class="line">		&#125;</span><br><span class="line">		if (!S.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			P &#x3D; S.top();</span><br><span class="line">			S.pop();</span><br><span class="line">			Visit(P-&gt;data);		</span><br><span class="line">			P&#x3D;P-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PostOrderTraverse2(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;后序遍历非递归</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;BiTree&gt;S;</span><br><span class="line">	BiTNode *cur;&#x2F;&#x2F;当前结点</span><br><span class="line">	BiTNode *ptr&#x3D;NULL;&#x2F;&#x2F;之前访问的结点</span><br><span class="line">	S.push(T);</span><br><span class="line">	while (!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		cur &#x3D; S.top();</span><br><span class="line">		if ((cur-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;cur-&gt;rchild&#x3D;&#x3D;NULL)||(ptr!&#x3D;NULL&amp;&amp;(ptr&#x3D;&#x3D;cur-&gt;lchild||ptr&#x3D;&#x3D;cur-&gt;rchild)))</span><br><span class="line">		&#123;</span><br><span class="line">			Visit(cur-&gt;data);</span><br><span class="line">			S.pop();</span><br><span class="line">			ptr &#x3D; cur;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (cur-&gt;rchild!&#x3D;NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				S.push(cur-&gt;rchild);</span><br><span class="line">			&#125;</span><br><span class="line">			if (cur-&gt;lchild!&#x3D;NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				S.push(cur-&gt;lchild);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status LevelOrderTraverse(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;层序遍历二叉树(借助于队列)</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;BiTree&gt;Q;</span><br><span class="line">	BiTree P &#x3D; T;</span><br><span class="line">	Q.push(P);</span><br><span class="line">	while (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		BiTree temp &#x3D; Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		Visit(temp-&gt;data);		</span><br><span class="line">		if (temp-&gt;lchild!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			Q.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp-&gt;rchild!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			Q.push(temp-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status LevelOrderTraverse(BiTree T)&#x2F;&#x2F; 二叉树的层序遍历(数组实现)</span><br><span class="line">&#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) return ERROR;</span><br><span class="line"></span><br><span class="line">	BiTree q[MAXSIZE];&#x2F;&#x2F;树中最大的结点数为10.</span><br><span class="line">	q[0] &#x3D; T;</span><br><span class="line"></span><br><span class="line">	int front &#x3D; 0;</span><br><span class="line">	int rear &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	while (front&lt;rear)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;,q[front]-&gt;data);</span><br><span class="line">		if (q[front]-&gt;lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			q[rear] &#x3D; q[front]-&gt;lchild;</span><br><span class="line">			rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (q[front]-&gt;rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			q[rear] &#x3D; q[front]-&gt;rchild;</span><br><span class="line">			rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		front++;&#x2F;&#x2F;最后跳出循环的条件为front&#x3D;rear</span><br><span class="line">		&#x2F;&#x2F;rear为除了根节点以外所有结点的总数，front为算上根节点的所有结点总数，遍历所有结点后rear&#x3D;front</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Deepth(BiTree T)&#x2F;&#x2F;求树的高度</span><br><span class="line">&#123;</span><br><span class="line">	int deepthLeft &#x3D; 0;</span><br><span class="line">	int deepthRight &#x3D; 0;</span><br><span class="line">	int deepCount &#x3D; 0;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		deepCount &#x3D; 0;</span><br><span class="line">		return deepCount;</span><br><span class="line">	&#125;	</span><br><span class="line">	deepthLeft &#x3D; Deepth(T-&gt;lchild);</span><br><span class="line">	deepthRight &#x3D; Deepth(T-&gt;rchild);</span><br><span class="line">	deepCount &#x3D; 1 + ((deepthLeft &gt; deepthRight) ? deepthLeft : deepthRight);&#x2F;&#x2F;在左子树和右子树中求最高的那棵树，总树高为其加1</span><br><span class="line">	return deepCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PreorderPrintLeaves(BiTree BT)&#x2F;&#x2F;先序输出树的结点</span><br><span class="line">&#123;</span><br><span class="line">	if (BT &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (BT-&gt;lchild &#x3D;&#x3D; NULL&amp;&amp;BT-&gt;rchild &#x3D;&#x3D; NULL) printf(&quot;%d &quot;, BT-&gt;data);</span><br><span class="line">		PreorderPrintLeaves(BT-&gt;lchild);</span><br><span class="line">		PreorderPrintLeaves(BT-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>———–随便写了一下主函数，，，都用的非递归的遍历，，，觉得递归的遍历时间复杂度太高了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	printf(&quot;请输入数据先序创建一棵二叉树:(结点为空时输入0)\n&quot;);</span><br><span class="line">	T &#x3D; CreateTree();               &#x2F;&#x2F;先序创建一棵二叉树 </span><br><span class="line">	printf(&quot;先序遍历结果为：\n&quot;);</span><br><span class="line">	PreOrderTraverse2(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;中序遍历结果为：\n&quot;);</span><br><span class="line">	InOrderTraverse2(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;后序遍历结果为：\n&quot;);</span><br><span class="line">	PostOrderTraverse2(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;层序遍历结果为：\n&quot;);</span><br><span class="line">	LevelOrderTraverse(T);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	LevelOrderTraverse(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;此树的高度为:\n&quot;);</span><br><span class="line">	printf(&quot;%d\n&quot;, Deepth(T));</span><br><span class="line">	printf(&quot;其树结点为:(先序)\n&quot;);</span><br><span class="line">	PreorderPrintLeaves(T);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也算是我对数据结构二叉树这一章的总结吧，记录一下自己的学习历程！冲鸭！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表和双向链表基本操作的实现（数据结构 C语言实现版)</title>
    <url>/2020/01/22/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%89%88/</url>
    <content><![CDATA[<p>大家吼我又来了，今天我给大家带来的是单向链表和双向链表的基本操作（基本上挺全的。。。）<br>    <strong>数据结构</strong>这门课程是学计算机的学生们感觉很重要很困难的学科。而链表也基本上算是数据结构刚入门时所写的了吧。<br>    我把自己学习数据结构的历程分享到自己的博客里，供大家学习也供我自己查阅自己的学习历程。若是感觉还不错或者有任何问题的话，欢迎加我的qq：790567648来跟我进一步的交流。hhh<br>    话不多说，我先上代码为敬，（基本上操作内我都写上注释了，再有什么看不懂的地方可以私信我聊）</p>
<a id="more"></a>
<p><strong>单向链表的基本操作实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------老规矩，头文件，宏定义以及ADT和基本数据操作的声明</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;Node, *List;</span><br><span class="line"></span><br><span class="line">List InitList();&#x2F;&#x2F;带头结点的链表的建立</span><br><span class="line">int Listlength(List L);&#x2F;&#x2F;求链表的长度</span><br><span class="line">void ListInsert(List L, int i, ElemType e);&#x2F;&#x2F;在L中第i个位置之后插入一个结点的数值为e</span><br><span class="line">void ListDelete(List L, int i);&#x2F;&#x2F;链表第i个结点的删除</span><br><span class="line">int GetElemtype(List L, int i);&#x2F;&#x2F; 返回L中第i个位置的数据元素的值</span><br><span class="line">void GetElem(List L, ElemType e);&#x2F;&#x2F;查找在链表中是否有e这个元素，有的话返回它在链表中的位置，没有的话显示无</span><br><span class="line">void ListCleaner(List L);&#x2F;&#x2F;链表的清除</span><br><span class="line">void print(List L);&#x2F;&#x2F;链表的输出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List InitList()&#x2F;&#x2F;带头结点的链表的建立（需要参数和不需要参数同理）</span><br><span class="line">&#123;</span><br><span class="line">	Node *last;&#x2F;&#x2F;p为插入结点，last始终指向末节点;</span><br><span class="line">	List L;</span><br><span class="line">	L &#x3D; (Node *)malloc(sizeof(Node));</span><br><span class="line">	L-&gt;next &#x3D;&#x3D; NULL;</span><br><span class="line">	last &#x3D; L;</span><br><span class="line">	ElemType elem;</span><br><span class="line">	printf(&quot;已为您创建链表，请输入每个元素的值（以空格隔开并且以-1为结尾且不计入链表之中）\n&quot;);</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;elem) &amp;&amp; elem !&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *p;</span><br><span class="line">		p &#x3D; (Node *)malloc(sizeof(Node));</span><br><span class="line">		p-&gt;data &#x3D; elem;</span><br><span class="line">		last-&gt;next &#x3D; p;</span><br><span class="line">		last &#x3D; p;</span><br><span class="line">	&#125;</span><br><span class="line">	last-&gt;next &#x3D; NULL;</span><br><span class="line">	printf(&quot;链表以创建成功！\n&quot;);</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line">int Listlength(L)&#x2F;&#x2F;求链表的长度</span><br><span class="line">&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	int temp &#x3D; 0;</span><br><span class="line">	while (p-&gt;next !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		temp++;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void ListInsert(List L, int i, ElemType e)&#x2F;&#x2F;在L中第i个位置之后插入一个结点的数值为e</span><br><span class="line">&#123;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	Node *p, *temp;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	while (j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	temp &#x3D; (Node *)malloc(sizeof(Node));&#x2F;&#x2F;新建一个结点</span><br><span class="line">	temp-&gt;data &#x3D; e;</span><br><span class="line">	temp-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void print(List L)&#x2F;&#x2F;链表的输出</span><br><span class="line">&#123;</span><br><span class="line">	List tempList;</span><br><span class="line">	tempList &#x3D; L-&gt;next;</span><br><span class="line">	while (tempList)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, tempList-&gt;data);</span><br><span class="line">		tempList &#x3D; tempList-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ListDelete(List L, int i)&#x2F;&#x2F;链表第i个结点的删除</span><br><span class="line">&#123;</span><br><span class="line">	if (i&lt;1 || i&gt;Listlength(L) + 1)</span><br><span class="line">	&#123;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	Node *p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	while (p&amp;&amp;j &lt; i - 1)&#x2F;&#x2F;找到第i个位置前的结点</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next &#x3D; p-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">int GetElemtype(List L, int Position)&#x2F;&#x2F; 返回L中第i个数据元素的值</span><br><span class="line">&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; Position; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListCleaner(List L)&#x2F;&#x2F;链表的清除</span><br><span class="line">&#123;</span><br><span class="line">	List p &#x3D; NULL, q &#x3D; NULL;&#x2F;&#x2F;让p指向当前要删除的结点，q指向p之后的结点，等p释放空间后再重复上述操作</span><br><span class="line">	p &#x3D; L-&gt;next;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		q &#x3D; p-&gt;next;</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; q;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next &#x3D; NULL;</span><br><span class="line">	printf(&quot;链表已经清除！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void GetElem(List L, ElemType e)&#x2F;&#x2F;查找在链表中是否有e这个元素，有的话返回它在链表中的位置</span><br><span class="line">&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	int temp &#x3D; 0;</span><br><span class="line">	p &#x3D; L-&gt;next;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		temp++;</span><br><span class="line">		if (p-&gt;data &#x3D;&#x3D; e)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;结果：该元素在第%d个位置\n&quot;, temp);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;结果：未找到相关元素！\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己写的main函数，大家看看就好，，，，不必当真（QAQ我知道看到这里大佬要开始吐槽我了，手下留情）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int n, i, e;</span><br><span class="line">	List L;</span><br><span class="line">	L &#x3D; InitList();</span><br><span class="line">	printf(&quot;链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line">	printf(&quot;此时，链表的元素为：&quot;);</span><br><span class="line">	print(L);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;请输入需要插入的位置以及元素：&quot;);</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;i, &amp;e);</span><br><span class="line">	ListInsert(L, i, e);</span><br><span class="line">	printf(&quot;此时，链表的元素为：&quot;);</span><br><span class="line">	print(L);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;此时链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line"></span><br><span class="line">	int deletenum;</span><br><span class="line">	printf(&quot;请输入要删除的元素的位置为：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;deletenum);</span><br><span class="line">	ListDelete(L, deletenum);</span><br><span class="line">	printf(&quot;此时，链表的元素为：&quot;);</span><br><span class="line">	print(L);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;此时，链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line"></span><br><span class="line">	int test;</span><br><span class="line">	printf(&quot;请输入要查询第几个位置的元素：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;test);</span><br><span class="line">	printf(&quot;该位置的元素为：%d\n&quot;, GetElemtype(L, test));</span><br><span class="line"></span><br><span class="line">	int temp;</span><br><span class="line">	printf(&quot;请输入此元素来查询该链表中是否有该元素：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">	GetElem(L, temp);</span><br><span class="line"></span><br><span class="line">	printf(&quot;正在进行清空操作，请稍候。。。\n&quot;);</span><br><span class="line">	ListCleaner(L);</span><br><span class="line">	printf(&quot;此时，链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line">	</span><br><span class="line">	printf(&quot;恭喜您以完成全部操作！\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双向链表的基本操作实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct DuLNode &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct DuLNode *prior;</span><br><span class="line">	struct DuLNode *next;</span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br><span class="line"></span><br><span class="line">DuLinkList InitList();&#x2F;&#x2F;带头结点的链表的建立</span><br><span class="line">int Listlength(DuLinkList L);&#x2F;&#x2F;求链表的长度</span><br><span class="line">void ListInsert(DuLinkList L, int i, ElemType e);&#x2F;&#x2F;在L中第i个位置之后插入一个结点的数值为e</span><br><span class="line">void ListDelete(DuLinkList L, int i);&#x2F;&#x2F;链表第i个结点的删除</span><br><span class="line">int GetElemtype(DuLinkList L, int i);&#x2F;&#x2F; 返回L中第i个位置的数据元素的值</span><br><span class="line">void GetElem(DuLinkList L, ElemType e);&#x2F;&#x2F;查找在链表中是否有e这个元素，有的话返回它在链表中的位置，没有的话显示无</span><br><span class="line">void ListCleaner(DuLinkList L);&#x2F;&#x2F;链表的清除</span><br><span class="line">void print(DuLinkList L);&#x2F;&#x2F;链表的输出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DuLinkList InitList()</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList L,Last;</span><br><span class="line">	L &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">	L-&gt;prior &#x3D; NULL;</span><br><span class="line">	L-&gt;next &#x3D; NULL;</span><br><span class="line">	Last &#x3D; L;&#x2F;&#x2F;last一直指向链表的最后一个元素，便于循环内部的初始化链表的值</span><br><span class="line">	int data;</span><br><span class="line">	printf(&quot;请输入双向链表的值:(以空格为间隔，结尾为-1且不算在链表中)&quot;);</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;data)&amp;&amp;data!&#x3D;-1)&#x2F;&#x2F;出现-1则跳出循环，-1不在链表之内</span><br><span class="line">	&#123;</span><br><span class="line">		DuLNode *p &#x3D; (DuLNode *)malloc(sizeof(DuLNode));</span><br><span class="line">		p-&gt;data &#x3D; data;</span><br><span class="line">		Last-&gt;next&#x3D;p;</span><br><span class="line">		p-&gt;prior &#x3D; Last;</span><br><span class="line">		p-&gt;next &#x3D; NULL;</span><br><span class="line">		Last &#x3D; p;</span><br><span class="line">	&#125;</span><br><span class="line">	Last-&gt;next &#x3D; NULL;&#x2F;&#x2F;最后last指向最后一个有效的结点p，使其的next指向NULL</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Listlength(DuLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	while (p-&gt;next)&#x2F;&#x2F;若p-&gt;next不空，则temp++，temp即为链表的长度</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		length++;</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetElemtype(DuLinkList L, int i)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p &#x3D; L;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	if (L&#x3D;NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		while (p-&gt;next&amp;&amp;j &lt; i)&#x2F;&#x2F;找到第i个元素所在的位置</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;&#x2F;&#x2F;跳出循环时p当前的位置即为第i个元素所在的位置(判断并输出的条件是j&#x3D;&#x3D;i)</span><br><span class="line">		if (j&#x3D;&#x3D;i)</span><br><span class="line">		&#123;</span><br><span class="line">			return p-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetElem(DuLinkList L, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p &#x3D; L;</span><br><span class="line">	int temp &#x3D; 0;</span><br><span class="line">	while (p-&gt;next)&#x2F;&#x2F;p-&gt;next若不空，则继续进行遍历，知道找到p</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		temp++;</span><br><span class="line">		if (p-&gt;data&#x3D;&#x3D;e)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;存在该元素，且它的位置在链表的第%d个位置上\n&quot;, temp);</span><br><span class="line">			temp &#x3D; -1;&#x2F;&#x2F;若元素在最后一个位置上，则下面的话也会输出，所以改变temp的值，使其跳出循环时不会被下面的判断句所接收</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (temp&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;该链表中不存在该元素！\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListCleaner(DuLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p;</span><br><span class="line">	p &#x3D; L-&gt;next;&#x2F;&#x2F;L为头结点，所以p要指向链表中第一个有效的结点即头结点的next</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;next &#x3D; p-&gt;next;&#x2F;&#x2F;将L-&gt;next指向p-&gt;next，便于删除p时影响链表的结构</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; L-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;链表已清除完毕！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(DuLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	int i &#x3D; 1;</span><br><span class="line">	DuLinkList p &#x3D; L-&gt;next;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;链表的第%d个元素为：%d\n&quot;, i, p-&gt;data);</span><br><span class="line">		i++;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListInsert(DuLinkList L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p &#x3D; L-&gt;next;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	if (i&lt;0||i&gt;Listlength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;所插入的位置不存在！\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		while (p&amp;&amp;j &lt; i - 1)&#x2F;&#x2F;找到p为所要插入的位置(即i之后的位置)</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i&#x3D;&#x3D;0)&#x2F;&#x2F;想在头结点之后插入元素时</span><br><span class="line">		&#123;</span><br><span class="line">			DuLinkList inserted;</span><br><span class="line">			inserted &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">			&#x2F;&#x2F;四步走，把四个线连起来</span><br><span class="line">			inserted-&gt;data &#x3D; e;</span><br><span class="line">			L-&gt;next &#x3D; inserted;</span><br><span class="line">			inserted-&gt;prior &#x3D; L;</span><br><span class="line">			inserted-&gt;next &#x3D; p;</span><br><span class="line">			p-&gt;prior &#x3D; inserted;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (p-&gt;next)&#x2F;&#x2F;i&gt;0&amp;&amp;p之后还有结点时</span><br><span class="line">		&#123;</span><br><span class="line">			DuLinkList inserted;</span><br><span class="line">			inserted &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">			inserted-&gt;data &#x3D; e;</span><br><span class="line">			&#x2F;&#x2F;四步走，把四个线连起来</span><br><span class="line">			inserted-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">			p-&gt;next-&gt;prior &#x3D; inserted;</span><br><span class="line">			p-&gt;next &#x3D; inserted;</span><br><span class="line">			inserted-&gt;prior &#x3D; p;</span><br><span class="line">			printf(&quot;插入成功！\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;i&gt;0&amp;&amp;p为链表最后一个结点时</span><br><span class="line">			DuLinkList inserted;</span><br><span class="line">			inserted &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">			inserted-&gt;data &#x3D; e;</span><br><span class="line">			&#x2F;&#x2F;三步走</span><br><span class="line">			p-&gt;next &#x3D; inserted;</span><br><span class="line">			inserted-&gt;prior &#x3D; p;</span><br><span class="line">			inserted-&gt;next &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListDelete(DuLinkList L, int i)</span><br><span class="line">&#123;</span><br><span class="line">	if (i&lt;0||i&gt;Listlength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;位置不存在！\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		int j &#x3D; 0;</span><br><span class="line">		DuLinkList p &#x3D; L-&gt;next;&#x2F;&#x2F;L为头结点，所以p要指向链表中第一个有效的结点即头结点的next</span><br><span class="line">		&#x2F;&#x2F;先找到被删除结点的位置</span><br><span class="line">		while (p&amp;&amp;j &lt; i - 1)</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (p-&gt;next)&#x2F;&#x2F;p的next后还有结点时</span><br><span class="line">		&#123;&#x2F;&#x2F;两步走</span><br><span class="line">			p-&gt;next-&gt;prior &#x3D; p-&gt;prior;</span><br><span class="line">			p-&gt;prior-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;p为链表最后一个元素</span><br><span class="line">			p-&gt;prior-&gt;next &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;双向链表的定义及初始化</span><br><span class="line">	DuLinkList L;</span><br><span class="line">	L &#x3D; InitList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;求链表的长度</span><br><span class="line">	printf(&quot;该链表的长度为;%d\n&quot;, Listlength(L));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;&#x2F;&#x2F;求链表的第i个位置上的元素</span><br><span class="line">	int temp;</span><br><span class="line">	printf(&quot;请输入想要知道的第几个位置：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">	printf(&quot;该位置上的数为:%d\n&quot;, GetElemtype(L, temp));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;求链表是否存在元素的某个值</span><br><span class="line">	printf(&quot;请输入想知道链表中是否存在该元素的值：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">	GetElem(L, temp);</span><br><span class="line">	&#x2F;&#x2F;遍历输出链表的元素</span><br><span class="line">	print(L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;在链表中指定位置后插入元素</span><br><span class="line">	printf(&quot;输入你想在第几个位置之后插入元素:&quot;);</span><br><span class="line">	int yuansu, weizhi;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;weizhi);</span><br><span class="line">	printf(&quot;输入你想插入元素的值:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;yuansu);</span><br><span class="line">	ListInsert(L, weizhi, yuansu);</span><br><span class="line">	&#x2F;&#x2F;遍历</span><br><span class="line">	print(L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;在链表中指定位置删除元素</span><br><span class="line">	printf(&quot;输入你想删除的结点在链表中的位置:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;weizhi);</span><br><span class="line">	ListDelete(L, weizhi);</span><br><span class="line">	&#x2F;&#x2F;遍历</span><br><span class="line">	print(L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;选择是否进行摧毁链表操作</span><br><span class="line">	printf(&quot;是否选择进行摧毁链表操作，1是确定，2是不进行：&quot;);</span><br><span class="line">	int boolean;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;boolean);	</span><br><span class="line">	if (boolean&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;链表正在删除当中。。。\n&quot;);</span><br><span class="line">		ListCleaner(L);</span><br><span class="line">		printf(&quot;该链表的长度为:%d\n&quot;, Listlength(L));</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;恭喜你完成双向链表的全部基本操作!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表代码里面的基本内容也都是参照单向链表里面写的，只不过更进一步而已。而循环链表我没再写是因为只要把最后last-next从指向NULL改为指向头结点即可。具体操作跟单向链表几乎一模一样（当然你也可以从双向链表的基础上做也就是双向循环链表hhh）</p>
<p>还有就是，emmmm…我写的两个基本操作集里面的链表都是带头结点的，而且Ctrl A+Crtl C+Ctrl V是可以直接使用C语言编译器通过的。。。刚想起来补充上，还有一些可能想不起来了想起来的时候会更新哦！</p>
<p>大家也要加油鸭！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>android 右上角3个点的menu菜单的创建</title>
    <url>/2020/01/22/android-%E5%8F%B3%E4%B8%8A%E8%A7%923%E4%B8%AA%E7%82%B9%E7%9A%84menu%E8%8F%9C%E5%8D%95%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>直接在res文件中新建一个文件夹叫menu，往里面放menu文件，在需要的xml上面建立,<br>比如我在layout文件夹下有activity_catalog，那么我想在这个布局上面建立一个三个点的菜单，则我在menu下建立一个menu_catalog,然后下列代码就是一个例子<br>其中</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:context&#x3D;&quot;.CatalogActivity&quot;</span><br></pre></td></tr></table></figure>
<p>用来指定你要在哪个布局上建立三个点的菜单栏，然后<br>item用来添加菜单项，对应的属性就不多说了可以网上搜到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- Options menu for the CatalogActivity --&gt;</span><br><span class="line">    &lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">        xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">        xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">        tools:context&#x3D;&quot;.CatalogActivity&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;item</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;action_insert_dummy_data&quot;</span><br><span class="line">            android:title&#x3D;&quot;@string&#x2F;action_insert_dummy_data&quot;</span><br><span class="line">            app:showAsAction&#x3D;&quot;never&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;item</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;action_delete_all_entries&quot;</span><br><span class="line">            android:title&#x3D;&quot;@string&#x2F;action_delete_all_entries&quot;</span><br><span class="line">            app:showAsAction&#x3D;&quot;never&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio FloatingActionButton 在现版本的添加方式（3.4.2）</title>
    <url>/2020/01/22/android-studio-FloatingActionButton-%E5%9C%A8%E7%8E%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%BC%8F%EF%BC%883-4-2%EF%BC%89/</url>
    <content><![CDATA[<p>之前我在看优达学城的android基础开发（<a href="https://classroom.udacity.com/courses/ud845/lessons/f5bb088f-6cc0-4e7d-9985-1418654bb141/concepts/e6620651-469b-4754-9ac9-dc34f6f0b781/">https://classroom.udacity.com/courses/ud845/lessons/f5bb088f-6cc0-4e7d-9985-1418654bb141/concepts/e6620651-469b-4754-9ac9-dc34f6f0b781/</a>）<br>时遇到了问题（<a href="https://github.com/udacity/ud845-Pets/">https://github.com/udacity/ud845-Pets/</a>），就是它创建的主界面有一个floatingActionButton,但是需要特殊的支持。<br>百度后很多人说要引用这个：</p>
<a id="more"></a>
<p><strong>在build.gradle中加入：<br>　compile ‘com.android.support:design:26.0.0’</strong><br>实际上我的IDE中还是不可以，但是我使用了默认的方法，alt加enter，这样IDE自动加上了引用<br><strong>import com.google.android.material.floatingactionbutton.FloatingActionButton;</strong><br>原因可能是因为安卓版本的更新导致引用发生了变化，特记录下来方便以后查看。<br>引用时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;com.google.android.material.floatingactionbutton.FloatingActionButton</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;fab&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_alignParentRight&#x3D;&quot;true&quot;</span><br><span class="line">        android:layout_alignParentBottom&#x3D;&quot;true&quot;</span><br><span class="line">        android:layout_margin&#x3D;&quot;@dimen&#x2F;fab_margin&quot;</span><br><span class="line">        android:src&#x3D;&quot;@drawable&#x2F;ic_add_pet&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git将本地仓库push到远程仓库上(包括readme.md)</title>
    <url>/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/</url>
    <content><![CDATA[<p>1.在本地项目目录文件下右键鼠标点击git bash here，使用git init命令初始化一个新的仓库<br>2.在github上面新建一个项目（不初始化readme.md，最后我们会处理它）<br>3.git remote add origin + 远程仓库url</p>
<a id="more"></a>
<p>4.git add .<br>   git commit -m “说明”<br>   git push -u origin master<br>5.此时，刷新github上面的内容，发现已经提交到远程仓库上面了。<br>6.在github下面有一个create readme.md选项（如果你项目中没有readme.md的话），创建并编辑。<br>7.使用git pull origin master:master命令，将远程仓库上面的内容pull到本地仓库（因为此时远程仓库比本地仓库多一个readmd.md）<br>8.大功告成，给自己鼓掌，切记以后尽量不要再github上面直接编辑文件，需要在本地仓库改变文件后进行第4步即可。<br>9.若不小心在github上面动了代码也不要紧，使用第7步即可。</p>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/1.jpg" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]">  

<hr>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/2.png" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]">  

<hr>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/3.jpg" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]"> 

<hr>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/4.png" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]">  
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题</title>
    <url>/2020/01/22/leetcode%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>上篇博客提到过，我在备战PAT时也是边看《大话数据结构》边做PAT和leetcode两个平台上面的题，而leetcode平台的题只需要写函数即可，不需要大局观的细节让你实现，所以对于练习算法还是很有帮助的，<a id="more"></a>  我大体就是按线性表-栈队列-树-图等顺序和专题刷的，这是我的链接：<a href="https://leetcode-cn.com/u/user4002g/">https://leetcode-cn.com/u/user4002g/</a></p>
<img src="/2020/01/22/leetcode%E5%88%B7%E9%A2%98/1.png" class="" title="[leetcode刷题]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年冬季PAT考试</title>
    <url>/2020/01/21/2019%E5%B9%B4%E5%86%AC%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>2019年12月7日，去参加了2019年冬季PAT考试，之前很早就知道PAT考试，而真正想开始考甲级还是2019年暑假，所以从8月5日，我就直接回学校，开始准备刷题，学数据结构了。</p>
<p>这篇博客虽然是写2019年冬季PAT考试的博客，但还是要记录一下自己备考那段经历，到现在一想确实觉得很感谢当时的自己。</p>
<a id="more"></a>

<hr>
<p>1.2019-8-5~2019-10-1：<br>这段时间一直在全身心备考，大概的时间段就是每天上午8-11：30和下午2-5点，然后5点过后就开始去健身房健身(每周1,3,5,7),晚上就放松玩一会，大概每天都是这么度过，当有课的话还是去上课的。学习的时间呢，就在PAT和leetcode两个平台上面刷题，分别用的IDE是VS2017和VS code，同时在ipad上下载了大话数据结构并跟着看，基本上考试之前都看完了。这段时间也是我感觉提升非常快的一段时间。</p>
<hr>
<p>2.2019-10-7~2019-12-7：<br>自从国庆跟女朋友去青岛玩之后一直到回来，因为玩的确实比较好，所以感觉从这后没有之前般努力了。不过即使这样，我还仍是坚持每天一道PAT甲级题库的题，leetcode的题反而不做了，因为确实两个题库侧重点不一样，我为了考PAT还是着重刷PAT的题。</p>
<p>so，最终考试考了98分，问题出在第一题，也就是20分的题，其实临最后一分钟的时候知道那个测试点问题出在哪里了，但我改完想提交上去时间也结束了。怎么说呢，确实有点可惜，不过这也说明我平时踩的坑比较少吧。不过第一次考了98分我还是比较满意(虽然后来得知确实题目很简单),但可能以后还会再继续备考吧，不过也说不准。</p>
<p>我今天从PAT甲级平台上看了一下，还是155道题，考试的四道题并没有传到题库中，不过大体依稀记得：<br>1.HelloWorld，输入输出题，但踩坑点在输入的字符中#位置不一定在哪，这也是我最后掉分的地方。<br>2.链表题，因为之前总结了链表题所以觉得不是很难，大概半小时写完了得了25(其实5分钟就写完了，但有个测试点错误，debug了25分钟)<br>3.非常简单的图论，我记得是一道给分配位置的DFS题，考前好像正好做到了<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552/">类似的题</a>。<br>4.一道建树题，应该是用的递归吧，我忘记了。当时一眼没看出来以为和根据前序遍历中序遍历推后序遍历类似，最后发现是用递归就可。</p>
<p>以上就是我的考试经历，我大二上半学期学的数据结构，当时学到后面觉得很难就放松了对它的努力，其实现在觉得，软件的最基本的内容就是数据结构，所以也是下定了决心要好好把它学好。我不是最聪明的学生，只想做最努力的，大三下半学期，考研加油！</p>
<p>我的个人博客友情链接里面有PAT我就不贴了，我每刷完一道题都会把它放到github上, 链接:<a href="https://github.com/MrSunCodes/PAT_AdvanceLevel/">https://github.com/MrSunCodes/PAT_AdvanceLevel</a></p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样在Hexo上写博客</title>
    <url>/2020/01/20/%E6%80%8E%E6%A0%B7%E5%9C%A8Hexo%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>编写博客的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>title是博客的名称，即显示到主页的title<br>此条命令会在source/posts文件夹中新建一个以title命名的md文件，只需修改其md文件后再</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<a id="more"></a>  

<p>执行上面两条命令即可将修改的md文件push到github上，即可通过网站访问，不过推荐先使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>在本地进行测试，这样更快而且只要本地服务器开着，就不需要再上传一遍才能看效果了，可以边看效果边修改，之后一并将修改的最终内容push到github。  </p>
<p>编写博客时，推荐使用有道云笔记(我使用的就是有道云笔记)：<a href="http://note.youdao.com/download.html">官网下载</a>  </p>
<p>使用有道云笔记编写Markdown文件后可以边编写边预览效果，最后编写完成后只需复制粘贴到之前的md文件中(使用记录本复制粘贴即可)</p>
<p>如果博客中有图片需要上传，首先找到项目根目录的_config.yml文件,修改post_asset_folder属性为true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>别忘再</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>此时再使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>创建新博客时，在source/posts中会生成title同名文件夹,只需将所有该博客需要的图片放入其中，然后在图片引用位置加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名.图片后缀 [title] %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>title直接就是该博客的title，不需要再加引号</strong></p>
<p>至于修改博客的样式，需要修改主目录下的 _config.yml文件，以及themes/你的主题下的 _config.yml文件，<br>这两个文件修改的部分请见示例：<br><a href="https://github.com/litten/hexo-theme-yilia/blob/master/_config.yml">主目录的_config.yml文件</a><br><a href="https://github.com/litten/BlogBackup/blob/master/_config.yml">主题下的 _config.yml文件</a></p>
<p>最后需要注意的是，默认情况主页会显示博客的所有内容，如果想让其精简，加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>即可<br>此时，该位置会显示more，点击就是该博客剩下的内容，而剩下的内容在主页中不会显示。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客-Hexo博客的建立与部署</title>
    <url>/2020/01/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<ol>
<li>首先下载node.js以及git(这两个都是hexo博客框架所需要的)<br>node.js:<a href="https://nodejs.org/en/">官网</a><br>git<a href="https://git-scm.com/downloads/">官网</a>  </li>
<li>安装Hexo<br>2.1首先，node.js下载并安装后是默认安装npm(项目管理工具)<br>2.2 因为npm是使用国外镜像，所以我们修改并使用淘宝的镜像，这样之后的命令执行速度会变快， 其下载命令是:  </li>
</ol>
<a id="more"></a>  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>别忘测试hh，之前测试的命令分别为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">cnpm</span><br></pre></td></tr></table></figure>
<p>完成之后安装Hexo：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>检验Hexo是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>3.创建一个目录：(我的是放在了F:/MyBlog)<br>使用命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>这步是将框架初始化的内容添加到你刚才创建的文件夹中<br>4.运行测试：<br>常使用的四个命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   #上传到服务器</span><br></pre></td></tr></table></figure>
<p>运行时，先使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>打开浏览器的<strong>localhost:4000</strong>，即可发现本地登录成功。<br>我是部署到github上，不需要关心服务器租赁费以及域名等等问题，<br>首先在github上面创建一个新的仓库，名字就叫做[github用户名].github.io,然后在自己所创建的目录中[我的是F:/MyBlog]打开<strong>_config.yml文件</strong>，将其中的  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br></pre></td></tr></table></figure>
<p>字段填补完整为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;MrSunCodes&#x2F;MrSunCodes.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>repo中的地址及你在github上面创建的仓库地址。<br>最后，只需执行一条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>即可将本地的所有文件push到github仓库中，此时访问<br><a href="https://mrsuncodes.github.io/">blog</a>即你的用户名.github.io即可(可能需要多刷新几下)</p>
<img src="/2020/01/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%83%A8%E7%BD%B2/1.png" class="" title="[第一篇博客-Hexo博客的建立与部署]">  

<p>大功告成！个人博客已经搞起来了！剩下的就是编写博客以及修改主题等样式了，具体可看我的下一篇博客。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
