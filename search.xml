<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode-215</title>
    <url>/2020/06/30/leetcode-215/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">题目链接</a>  </p>
<img src="/2020/06/30/leetcode-215/1.png" class="" title="[title]">  
<a id="more"></a>
<p>刚学到的算法就用到了，这是一个变相求第k小的值的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;215 lang&#x3D;cpp</span><br><span class="line"> *</span><br><span class="line"> * [215] 数组中的第K个最大元素</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void swap(int &amp;a, int &amp;b)&#x2F;&#x2F;交换函数</span><br><span class="line">    &#123;</span><br><span class="line">        int t &#x3D; a;</span><br><span class="line">        a &#x3D; b;</span><br><span class="line">        b &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    int randomPartition(vector&lt;int&gt; &amp;nums, int start, int end)&#x2F;&#x2F;进行随机化partition，不然时间复杂度会退化到O(n^2)</span><br><span class="line">    &#123;</span><br><span class="line">        int i &#x3D; rand() % (end - start + 1) + start;</span><br><span class="line">        swap(nums[i], nums[end]);</span><br><span class="line">        return partition(nums, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int partition(vector&lt;int&gt; &amp;nums, int start, int end)&#x2F;&#x2F;快排划分函数</span><br><span class="line">    &#123;</span><br><span class="line">        int i &#x3D; start - 1, j &#x3D; start;</span><br><span class="line">        int x &#x3D; nums[end];</span><br><span class="line">        while (j &lt;&#x3D; end - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[j] &lt;&#x3D; x)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i + 1], nums[end]);</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(vector&lt;int&gt; &amp;nums, int start, int end, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        int i &#x3D; partition(nums, start, end);&#x2F;&#x2F;对序列进行划分一次</span><br><span class="line">        if (k &#x3D;&#x3D; i)&#x2F;&#x2F;如果划分的位置恰好为第k位，直接输出即可</span><br><span class="line">        &#123;</span><br><span class="line">            return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (k &gt; i)&#x2F;&#x2F;如果划分的位置在k前面，那么对前面半区进行递归调用</span><br><span class="line">        &#123;</span><br><span class="line">            return helper(nums, i + 1, end, k);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return helper(nums, start, i - 1, k);&#x2F;&#x2F;对后面半区进行递归调用</span><br><span class="line">    &#125;</span><br><span class="line">    int findKthLargest(vector&lt;int&gt; &amp;nums, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        srand(time(0));</span><br><span class="line">        return helper(nums, 0, nums.size() - 1, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br></pre></td></tr></table></figure>
<img src="/2020/06/30/leetcode-215/2.png" class="" title="[title]">  

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-中位数和顺序统计量</title>
    <url>/2020/06/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/</url>
    <content><![CDATA[<p>这一章的篇幅只有四页，但却十分重要，因为它提出了一个重要问题的解决方法，就是在O(n)的时间复杂度下找到序列最值以及序列中第k大的值。</p>
<a id="more"></a>
<ul>
<li>寻找最大最小值</li>
</ul>
<p>这个很简单了，只需要遍历一遍，然后记录最大或最小值，最后返回即可。</p>
<ul>
<li>寻找第k小的元素的期望为线性时间的选择算法</li>
</ul>
<p>这个算法比较重要，思想是借助快速排序的随机partition选择函数，因为这个函数的作用是在序列中随机选择一个元素并将其排列到序列中正确位置，并保证其前边所有元素小于它，后边所有元素大于它。然后判断这个元素所在位置跟要找的k的关系，如果相等那么就是正好排序的数就是第k大的数，否则就递归的在前半段或后半段进行查找。</p>
<p>具体代码可以看一下我做的题<br><a href="https://note.youdao.com/">link</a></p>
<p>对这个算法时间复杂度的证明，可以参考我课本上记录的内容，因为太过繁琐并且太多就不在博客上写了。</p>
<ul>
<li>最坏情况为线性时间的选择算法</li>
</ul>
<p>这个算法是助教讲的说至今为止学过最难的算法，不过有前面算法的铺垫，感觉难度还好。<br>思路是:  </p>
<ol>
<li>将输入的元素分成n/5取下整的组，每组5个元素，最后一组可能由剩下的n%5个元素组成。</li>
<li>寻找这所有组里面每个组的中位数：直接对每个组的五个元素进行排序（排序可以选择任意一个稳定排序，插入排序或归并都可，课本给的是插入排序），然后就可以确定每个组的中位数了。</li>
<li>对第二步找出的n/5取下整个中位数(因为有这么多组，每组会有一个中位数，中位数的个数就是组数)，递归调用select函数用来找出其中位数x。</li>
<li>然后用修改过的partition函数，对找出的中位数的中位数x进行划分，让k比划分的低区中的元素数目多1，因此x是第k小的元素，并且有n-k个元素在划分的高区。</li>
<li>剩下步骤同寻找第k小的元素最后步骤一样，如果i==k，返回x;如果i&lt;k，低区递归调用select，否则高区递归调用select。<br>总的来说，这个算法可能比之前的算法多了前面分组并找中位数的步骤。下面注重分析一下它。</li>
</ol>
<img src="/2020/06/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/1.png" class="" title="[title]">  
<p>由这个图片我们可以清楚地看到，除了包含x的组以及最后一个可能不能被5整除的组以外，其余组至少有三个元素大于x，即最后大于x的元素至少为</p>
<img src="/2020/06/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/2.png" class="" title="[title]">  
<p>那么，第五步中调用，最多[即最坏情况]为T(7n/10+6)[由n-大于x的元素得到]<br>第一步中时间复杂度为O(n),第二步也是O(n),[用插入排序对5个元素进行排序，时间复杂度是O(1),然后对n/5个组进行排序，所以为O(n)],第三步为O(n/5),第四步为O(n),那么总的递归式为：   </p>
<img src="/2020/06/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/3.png" class="" title="[title]">  
<p>那个140怎么来的暂时不用管。我们用substitution方法可以得到最后其运行时间为O(n)，因为上述五步都是最坏情况下的时间复杂度，所以总的O(n)就是这个算法的最坏情况下的时间复杂度。</p>
<hr>
<p>总的来说，这些个算法确实需要我们好好掌握。如果是我寻找序列中第k小的元素，我肯定先排序再输出第k个元素，但时间复杂度一定为O(nlogn)以上。但既然可以用线性时间可以解决问题，那么这个算法最好掌握。<br>顺便说一下，如果你使用这个算法去leetcode上做题的话[例如215题],很可能做的时间复杂度比直接排序要低，，原因一是现在的库里面的排序算法执行效率实在太高了，二是如果你在partition之前没有随机化的话，它的时间复杂度为退化到O(n^2),毕竟快排引入随机化就是降低其最坏情况发生的概率。<br>还有一个令我头秃的问题，我写的代码跟官方的代码基本上一样，为什么它的执行时间好高超过90%多的人16ms，我写的才148ms…比它慢了十倍。。。烦死了[还是我太菜了]</p>
]]></content>
      <categories>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最值</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-线性时间排序</title>
    <url>/2020/06/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>助教昨天讲的线性时间排序，主要内容有三个，决策树模型，计数排序和基数排序，桶排序没讲，估计是实验课的时候讲的吧，毕竟堆排就是实验课讲的正课没讲直接用，咱也不知道咱也不敢问。  </p>
<a id="more"></a>
<ul>
<li>决策树模型<br>任何基于比较排序的算法都可以抽象为决策树模型，其实很简单，就是每次比较a和b，如果a大于b就走左子树否则走右子树（或者反过来，看具体怎么规定）。而决策树的叶节点个数就是n!,n是输入的序列规模。因为在高度为h的决策树中，叶节点的数目最多不超过2^h（可用树的性质得到），所以可以得到式子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n! &lt;&#x3D; 2^h</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lg(n!)&lt;&#x3D;h</span><br></pre></td></tr></table></figure>
<p>由斯特林近似公式(导论33页公式3.19)可得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h&#x3D;O(nlgn)</span><br></pre></td></tr></table></figure>
<p>所以我们可得出结论，在最坏情况下，任何基于比较排序的算法都需要做O(nlogn)次比较。同时堆排序和归并排序是渐进最优的比较算法。上下界都是O(nlogn)</p>
<ul>
<li>计数排序<br>当时大三上学算法就没怎么看懂代码。。。流程和思想懂了，但是没看懂当时代码，现在根据助教上课讲的例子懂了。。。别问，问就是菜。  <img src="/2020/06/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/1.png" class="" title="[title]">  
可以看下这个例子，看一遍结合代码就可以懂。这里主要说一下注意的点。<img src="/2020/06/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/2.png" class="" title="[title]">  </li>
</ul>
<ol>
<li>计数排序需要使用多余的C[k]和B[n]的数组，所以不属于原址排序。</li>
<li>计数排序是稳定的，同属稳定的排序还有之前学过的冒泡，插入，归并。其余(快排，堆排，选择，希尔)都是不稳定。</li>
<li>计数排序的时间复杂度是O(k+n),k=O(n)时，就是线性时间复杂度了。</li>
</ol>
<ul>
<li>基数排序<br>这个排序很简单，大体就是从最低位开始排序，依次排序到最高位，导论上这个算法只有两行，就不在写出，知道思想即可。主要讨论下基数排序运行时间为线性的证明。<blockquote>
<p>引理8.3，给定n个d位数，每个数位都是k个可能的取值，那么基数排序使用稳定排序方法耗时O(n+k)时，就可以在O(d*(n+k))的时间内将这些数排好序。</p>
</blockquote>
</li>
</ul>
<p>这个引理很好理解，因为基数排序是每一步对一个数位进行排序，那么d个数位就会进行d次排序，就用d乘上之前得到的稳定排序时间即可。那么有了定理8.3就可以推出8.4了</p>
<blockquote>
<p>引理8.4，如果给定n个b位数和任何正整数r&lt;=b，上述条件不变还是使用稳定排序方法耗时O(n+k)时，最后的需要时间是O((b/r)*(n+2^r))</p>
</blockquote>
<p>这个也很好理解，因为每个关键字可以看做d=(b/r)个r位数[意思就是原来每次排序一个数位现在排序r个数位，那么总需要排序次数就是d=(b/r)].而k是每个数位可以取到的所有取值个数。r位可以取值的区间为[0,2^r-1],所以分别使用(b/r)和2^r代替d和k即可得到引理8.4。</p>
<p>而通过对O((b/r)*(n+2^r))内部式子求导，就可得取得最优解，此时r=lgn,整体运行时间就会是O(n).</p>
<hr>
<p>总结一下，如果我是备考PAT或者其他oj考试的话，我肯定背会这个算法，知道它的时间复杂度空间复杂度就止步于此，而《导论》会将这个算法的分析证明都推导出来，可以让我学到很多新思想和新知识，不过确实有点难度，可能概率论不太可吧毕竟考研考数二不考概率论。</p>
]]></content>
      <categories>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-快速排序</title>
    <url>/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序重要性我就不多说了吧，老师上课主要是对其最差表现和最好表现以及平均表现做了数学推导，我这里简单一写，当做自己肝《导论》的记录。 </p>
<a id="more"></a>
<p>对比归并排序，快排是在原地排序，不需要额外的存储空间。而最关键的步骤就是Partition，也就是排序一个数并且将所有小于它的数以及大于它的数全部分到它的左右两边。之前这里我一直没看懂，用的是网上看的方法即外层一个while循环，里面两个while循环，然后分别从两边向中间遍历。而实际上书上给的算法是一遍从左到右遍历（跟你选的主元位置没有关系），不过确实书上的算法更好些（我大概知道为啥我当时算法才考了89分了，当时老师考试提醒我你这个快排写的不对。。我写的就是网上看的方法，但他教的是导论那本书上写的算法。。我真菜）  </p>
<hr>
<p>分析一下快排的性能，我这里就不做推导了，只有结论，推导书上都有。  </p>
<ul>
<li><p>最坏情况划分<br>每次划分都是划分为n-1个数和1个数，递归式为  </p>
<blockquote>
<p>T(n) = T(n-1) + T(0) + O(n) = T(n-1) + O(n) = O(n^2)[算术级数得出]</p>
</blockquote>
</li>
<li><p>最好情况划分<br>每次划分都是中间划分，递归式为</p>
<blockquote>
<p>T(n) = 2T(n/2) + O(n) = O(nlogn)[Master定理得出]</p>
</blockquote>
</li>
<li><p>平衡的划分<br>递归式为  </p>
<blockquote>
<p>T(n) = T(9n/10) + T(n/10) + O(n) = O(nlogn)[导论上有递归树得出]</p>
</blockquote>
</li>
<li><p>对于平均情况的直观观察<br>如果每次是一次最好情况划分，一次最坏情况划分这样反复交替[好坏情况随机分布]呢？可由递归式推导出其时间复杂度仍是O(nlogn)</p>
</li>
</ul>
<hr>
<p>快速排序的随机化版本<br>由上面分析我们知道，影响快排因素的主要是输入的序列，如果输入的序列是已经排好序或者是已经逆序，那么此时就是最坏情况，那么时间复杂度跟插入排序是一样的，发挥不出快排O(nlogn)的优势，那么我们使用随机抽样的技术，使得不需要假设输入的序列是无序的，这样可以最大化的发挥快排的优势，方法有两种：</p>
<ol>
<li>随机打乱序列，使得序列不是排好序或逆序</li>
<li>随机选择主元<br>这两种方法都是属于随机抽样的随机化技术，这里重点讨论下2。只需每次在选择主元之前随机生成一个随机数种子，然后用次随机数对应的序列元素同选择的主元[一般都选最后一个或者是第一个]进行交换。此时，我们就可以分析它的期望。<br>老师上课讲的式子与课本上的不一样，但老师讲的是课后题7-3用的方法，具体可以看课后题7-3，如果不会可以看课上讲的板书（是的没错，最后老师让证明那个期望的上界我没有看懂。。。我太菜了），这里就不再写出。</li>
</ol>
<hr>
<p>总结，快排是一个非常有意思的算法，其思想也可以给我们很多启发。而在C++做题时可以很方便的使用sort()函数直接进行快排的调用，当然，快排是不稳定的排序算法，如果题目中给的是最后输出按某某属性排序，如果相同按输入顺序先后来输出，此时就不可以使用任何不稳定的排序算法，不过可以简单调用stable_sort(),跟sort函数使用方法一模一样只不过是稳定的排序算法。</p>
]]></content>
      <categories>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-分治策略</title>
    <url>/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>接着上次学到的求解递归式，这节课学的是分治。助教主要是给了几个小例子来分析问题。</p>
<ul>
<li><p>归并排序<br>这个算法上节课已经说了，递归式也给出来，这里就不多赘述.  </p>
<a id="more"></a></li>
<li><p>二分搜索<br>实际上二分搜索也是分治策略，在排好序的序列中，每次都取中间元素进行比较，来确定下一次是从这个点的左侧或者右侧继续进行搜索。这个算法的递归式是</p>
<blockquote>
<p>T(n) = T(n / 2) + O(1) = O(logn)</p>
</blockquote>
</li>
<li><p>求x的n次幂<br>给定浮点数或整数x和整数n，求x的n次方，实际上就是实现C++中pow()函数的功能。<br>实际上，这个问题如果不用递归的话，非常简单，只需一个for循环遍历n次，每次在原基础上乘x即可得最后结果。但这样做的时间复杂度是O(n),如果用分治策略我们可以实现更好的O(logn).<br>具体方法是：</p>
</li>
</ul>
<ol>
<li><p>n为偶数时，将x^n 分为 x^(n/2)* x^ (n/2),这样在求出x^(n/2)后只需平方一次即一次操作即可得到x的n次方。所以最后递归式为：  </p>
<blockquote>
<p>T(n) = T(n / 2) + O(1) = O(logn)</p>
</blockquote>
</li>
<li><p>n为奇数时，将x^n 分为x^(n-1/2) * x^(n-1/2) * x,这样比n为偶数时多一次运算，递归式仍为上式。</p>
</li>
</ol>
<ul>
<li>斐波那契数列求解<br>斐波那契数列可由下式推出(这个式子我之前从未听说，不过确实是正确的)，其正确性可以很简单的通过数学归纳法证明。  <img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/1.png" class="" title="[title]">  
这样，我们可以通过优化矩阵乘法来使其算法分治。但课程最后并未给出具体算法。</li>
<li>Strassen算法应用于矩阵乘法<br>普通的将矩阵分块之后进行计算并没有使最初的矩阵乘法算法的时间复杂度得到明显下降。其递归式为<blockquote>
<p>T(n) = 8T(n / 2) + O(n^2) = O(n^3)</p>
</blockquote>
</li>
</ul>
<p>不过Strassen算法通过使前面递归的次数从8次减少到7次来使得算法的复杂度降低到  </p>
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/8.webp" class="" title="[title]">  
<p>具体做法参加下图：(我确实不知道他是怎么想出解决这个问题的方法的，他一定非常聪明吧–助教原话hh)</p>
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/2.webp" class="" title="[title]">  
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/3.webp" class="" title="[title]">  
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/4.webp" class="" title="[title]">  
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/5.webp" class="" title="[title]">  
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/6.webp" class="" title="[title]">  
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/7.webp" class="" title="[title]">  

<ul>
<li>最大子数组问题<br>这个问题助教在课上并没有讲，但是实际上这是算法导论分治这一章的第一个例子。<br>具体就是给定一个无序数组，里面的数字有大有小，有正有负，然后需要你找到一个区间使得里面所有元素的和最大。<br>这个问题实际上我很久之前做leetcode就见过类似的题，当时使用的是dp，而实际上分治策略也是一个很好的解决此问题的方法。  <img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/9.png" class="" title="[title]">  
<img src="/2020/06/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/10.jpg" class="" title="[title]">  
注释写的已经很清楚了，算法的思路一目了然。  </li>
</ul>
<hr>
<p>总体来说，分治策略是一个我们在解决问题时一个很好用的方法，但有些时候(特别是对于leetcode做题时)，有些可以用分治策略写的题也同时可以用dp做，个人觉得dp甚至更简单，时间复杂度更低。但分治策略也是一个重要的方法，需要去掌握的。</p>
]]></content>
      <categories>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-求解递归式的三种方法</title>
    <url>/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>大三上学期学过算法课，但是这一部分当时听的时候就迷迷糊糊，感觉似懂非懂，今天看了MIT的算法导论课程（虽然有点老是2005年的）但查尔斯charles教授依然给了我很多的新的思想和帮助。</p>
<a id="more"></a>
<p>之前我从来没有仔细研究过分析递归这一类问题的运行时间，只觉得递归肯定是调用系统栈啊，空间复杂度肯定更高，然后时间复杂度你就稍微看看代码几个循环然后随便写写。其实真的大错特错。我学习算法的目的不仅是可以应用自如，更应该是使自己有具备分析和设计算法的能力，并且来比较哪个算法更优，或者对已有算法进行优化。（虽然考研挺忙，但是自己肯定还是每天可以抽出点时间学习学习自己喜欢的科目）<br>首先，分析递归（分治）问题时，最重要的就是写出他的递归式。所谓递归式就是把这个算法在用分治思想解决具体问题时所分的步骤记录下来，写成一个递推式。最常见的就是归并排序的递归式  </p>
<blockquote>
<p>T(n) = 2T(n / 2) + cn</p>
</blockquote>
<p>显而易见，归并排序首先在devide步骤时将所排序列分成两部分，每部分是原来规模的二分之一，然后分别对这两个进行排序，所以分成了2T(n / 2) ，而后续治理加合并步骤一共是线性时间即cn。<br>其次，我们求出递归式后，就可以通过递归式来分析他的运行时间，或者是时间复杂度。方法有三种</p>
<ul>
<li>代入法  （Substitution method）<br>最简单也是最难的一种方法，因为这种方法需要你猜测一个解的形式，然后带入使用归纳法进行求证，之前老师ppt上有个例子<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/1.png" class="" title="[title]">  
<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/2.png" class="" title="[title]">  
注意有几点需要注意的地方：<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/3.png" class="" title="[title]">  
这是什么意思呢，例如我们想求解<blockquote>
<p>T(n) = 4T(n / 2) + n</p>
</blockquote>
</li>
</ul>
<p>我们假设T(n)=O(n^2),<br>那么就是T(k)&lt;=ck^2<br>T(n)=4T(n / 2) + n &lt;= 4c(n/2)^2 + n = cn^2 + n = cn^2 - (-n)<br>[我们习惯用最后期望得到的结果==减去余项==，所以改写成了最后一个形式]<br>此时，我们需要-n非负才能保证T(n) &lt;= cn^2 ，即n&lt;=0,此时我们知是不可能的，因为n是很大的数肯定大于0。此时陷入僵局，需要改进思路，这是就可能要在guess中减去一个低阶项看是否可以work。<br>改进策略：假设T(n) &lt;= ck^2  - dk,即减去一个低阶项，这样带入原式得<br>T(n)=4T(n / 2) + n &lt;= 4[c(n/2)^2 - d(n/2)] +n = cn^2 + (1-2d)n=cn^2 - dn - (d-1)n<br>此时，我们还是需要余项非负，即(d-1)n &gt;= 0,即当d &gt;= 1时上述式成立，此时归纳成功。</p>
<hr>
<ul>
<li>递归树法（Iteration method）<br>这个方法比较简单，所以我直接帖另一位博主的帖子里面的图片，解下述递归式 ：  <img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/61.jpg" class="" title="[title]">  
<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/62.jpg" class="" title="[title]">  
<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/63.jpg" class="" title="[title]">  

</li>
</ul>
<hr>
<ul>
<li>主方法(master method)<br>非常好用的一种方法，强烈推荐，这个方法需要用到Master定理。证明过程在算法导论上大体意思就是使用它的递归树来进行求解，细节没看懂（我还是太菜了，可能等几年再回头看就会看懂吧）。<br>这个方法我就不在多赘述了，既有定理也有现成的例子，很好理解，最根本的就是比较n^logb a和f(n)的大小，有三种情况小于等于大于，每种情况都不一样，特别注意相等时的情况。  <img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/64.jpg" class="" title="[title]">  
<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/65.jpg" class="" title="[title]">  
需要注意的一点是，最后一个例子中，问题出在其并不是多项式意义上的大于。递归式落入了case2和case3的间隙，即下述图  <img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/66.png" class="" title="[title]">  
<img src="/2020/06/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/67.png" class="" title="[title]">  
总体而言，算法导论真的是一本神书，对于提高内功有很大的帮助，也对我有很多启发。有时思维不可以局限到一点，更不能太片面，只想着追求最新的技术，基础往往更重要。然后MIT这个课程配套的作业其实我蛮想写的，看着题可能稍微有点多，但是都有配套答案，但我真的时间不够用。如果等我考上研究生了以后时间充足，可能会反过头再做一遍练习的。</li>
</ul>
<p>参考博客：<br><a href="https://blog.csdn.net/spaceyqy/article/details/38819959">1</a><br><a href="https://blog.csdn.net/qq_27123591/article/details/81047497">2</a></p>
]]></content>
      <categories>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 42. 连续子数组的最大和</title>
    <url>/2020/06/19/%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<img src="/2020/06/19/%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/1.png" class="" title="[title]">
<a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">题目链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分治算法思想，三种可能性，最大值的区间可能只在左边或只在右边或横跨左边和右边，这种需要分三次情况来讨论，分别</span><br><span class="line">&#x2F;&#x2F;求出这三种情况下的最大值然后取最大的来作为最后结果</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int cross_max(vector&lt;int&gt; &amp;nums, int left, int right, int mid)&#x2F;&#x2F;如果区间横跨中间时计算其最大值</span><br><span class="line">    &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        int i &#x3D; mid, j &#x3D; mid + 1;</span><br><span class="line">        int max_left&#x3D;-101;</span><br><span class="line">        int max_right&#x3D;-101;</span><br><span class="line">        while (i &gt;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; nums[i];</span><br><span class="line">            if (max_left &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_left &#x3D; sum;</span><br><span class="line">            &#125;   </span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        sum &#x3D; 0;</span><br><span class="line">        while (j &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; nums[j];</span><br><span class="line">            if (max_right &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_right &#x3D; sum;</span><br><span class="line">            &#125;            </span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_left+max_right;</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(vector&lt;int&gt; &amp;nums, int left, int right)</span><br><span class="line">    &#123;</span><br><span class="line">        if (left &gt;&#x3D; right)</span><br><span class="line">        &#123;</span><br><span class="line">            return nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        int max_left &#x3D; helper(nums, left, mid);</span><br><span class="line">        int max_right &#x3D; helper(nums, mid + 1, right);</span><br><span class="line">        int corss &#x3D; cross_max(nums, left, right, mid);</span><br><span class="line">        return max(max(max_left, max_right), corss);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSubArray(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        return helper(nums, 0, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/06/19/%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/2.png" class="" title="[title]">  
<p>不要在意时间。。。主要是思想。。。看时间可以用dp，时间复杂度为O(n)…</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题25. 合并两个排序的链表</title>
    <url>/2020/06/19/%E9%9D%A2%E8%AF%95%E9%A2%9825-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<img src="/2020/06/19/%E9%9D%A2%E8%AF%95%E9%A2%9825-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/1.png" class="" title="[title]">
<a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">题目链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分治算法思想：寻找当前两个链表中最小元素的那个链表，选取他，然后再从剩余两个序列中最小的值连接到他后面组成有序链表</span><br><span class="line">&#x2F;&#x2F;如果有一个链表为空，那么直接返回另外一个链表即可</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if (l1&#x3D;&#x3D;NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2&#x3D;&#x3D;NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l1-&gt;val&lt;l2-&gt;val)&#x2F;&#x2F;l1为最小值</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next&#x3D;mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l2-&gt;next&#x3D;mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/06/19/%E9%9D%A2%E8%AF%95%E9%A2%9825-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/2.png" class="" title="[title]">
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>169. 多数元素</title>
    <url>/2020/06/18/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<img src="/2020/06/18/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/1.png" class="" title="[title]">
<a id="more"></a>
<p><a href="https://leetcode-cn.com/problems/majority-element/">题目链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;int, int&gt; P;&#x2F;&#x2F;建立map来保存每个值的个数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int max &#x3D; -1;</span><br><span class="line">        for (auto i &#x3D; P.begin(); i !&#x3D; P.end(); i++)&#x2F;&#x2F;遍历寻找出现次数最大的值</span><br><span class="line">        &#123;</span><br><span class="line">            if (i-&gt;second &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max &#x3D; i-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/06/18/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/2.png" class="" title="[title]">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分治算法思想</span><br><span class="line">&#x2F;&#x2F;将整个序列分成两部分，分别求两部分的出现次数最多的数；如果分开的部分只有一个元素，那么就返回那个元素。</span><br><span class="line">&#x2F;&#x2F;如果分开后两边元素返回次数最多的数是一样的，那么直接返回即可。如果不一样，则看两边元素返回值哪个出现的个数大于序列总长度的一半就返回哪个数</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int times(vector&lt;int&gt;&amp; nums, int target, int left, int right)</span><br><span class="line">    &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; left; i &lt;&#x3D; right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    int max(vector&lt;int&gt;&amp; nums, int left, int right)</span><br><span class="line">    &#123;</span><br><span class="line">        if (left &gt;&#x3D; right)</span><br><span class="line">        &#123;</span><br><span class="line">            return nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">            int max_left &#x3D; max(nums, left, mid);</span><br><span class="line">            int max_right &#x3D; max(nums, mid + 1, right);</span><br><span class="line">            int tleft &#x3D; times(nums, max_left, left, right);</span><br><span class="line">            int tright &#x3D; times(nums, max_right, left, right);</span><br><span class="line">            if (tleft &gt; (right-left+1) &#x2F; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                return max_left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (tright &gt; (right-left+1) &#x2F; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                return max_right;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int majorityElement(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        return max(nums, 0, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/3.png" class="" title="[title]">
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习-第三课作业</title>
    <url>/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>其实据我上次更新已经间隔了许久。。。不是没学，而是因为要学的东西太多了，要改的东西也太多了。光作业3我大概就将近写了5天，才把他的要求全做完。(渣渣1050Ti没办法，贫穷不配深度学习)，今天将所有模型跑完以及把代码搞懂，还填了很多坑，特记录下来。我还是按照前几次作业的步骤，慢慢来，可能稍微有点变动。</p>
<h1 id="Step1：明确目标"><a href="#Step1：明确目标" class="headerlink" title="Step1：明确目标"></a><strong>Step1：明确目标</strong></h1><p>这一次的目标是进行多分类，给你一张食物照片来分辨出它是第几类，因为没有给我们具体类的名字，所以我们就不用太在意它是什么分类，只需知道是第几类就好(我看着几个图片感觉蛋糕华夫饼啥的没啥区别。。。)<br>训练集一共9866张，验证集3430张(给我们验证集这样我们就不用在训练集中分出一部分做验证啦)，测试集3347张，其实测试集是我们最不用管的，因为根本就没有给我们任何信息，只是让我们的模型做出预测而已。</p>
<a id="more"></a>
<h1 id="Step2：数据预处理及Normalize"><a href="#Step2：数据预处理及Normalize" class="headerlink" title="Step2：数据预处理及Normalize"></a><strong>Step2：数据预处理及Normalize</strong></h1><img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/1.jpg" class="" title="[李宏毅机器学习-第三课作业]">  
<p>从训练集与验证集中我们可以看到，图片的命名大概是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;类别_第几张.jpg&quot;</span><br></pre></td></tr></table></figure>
<p>而且我们根本不用在意第几张，只需将该所有类别对应的图片的通通放入x_train中，将类别对应的数字放到y_train中(val_x，val_y和test_x同理)。这样就可以对数据进行简单的处理了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当label等于false时即不需要返回label，用来处理test集，方便统一管理</span><br><span class="line">#利用 OpenCV (cv2) 讀入照片並存放在 numpy array 中</span><br><span class="line">def readfile(path, label):</span><br><span class="line">    # label 是一個 boolean variable，代表需不需要回傳 y 值</span><br><span class="line">    image_dir &#x3D; sorted(os.listdir(path))</span><br><span class="line">    x &#x3D; np.zeros((len(image_dir), 128, 128, 3), dtype&#x3D;np.uint8)</span><br><span class="line">    y &#x3D; np.zeros((len(image_dir)), dtype&#x3D;np.uint8)</span><br><span class="line">    for i, file in enumerate(image_dir):</span><br><span class="line">        img &#x3D; cv2.imread(os.path.join(path, file))</span><br><span class="line">        x[i, :, :] &#x3D; cv2.resize(img, (128, 128))</span><br><span class="line">        if label:</span><br><span class="line">            y[i] &#x3D; int(file.split(&quot;_&quot;)[0])</span><br><span class="line">    if label:</span><br><span class="line">        return x, y</span><br><span class="line">    else:</span><br><span class="line">        return x</span><br></pre></td></tr></table></figure>
<p>而具体调用时是下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;Reading data&quot;)</span><br><span class="line">train_x, train_y &#x3D; readfile(&quot;.&#x2F;dataset&#x2F;training&quot;, True)</span><br><span class="line">print(&quot;Size of training data &#x3D; &#123;&#125;&quot;.format(len(train_x)))</span><br><span class="line">val_x, val_y &#x3D; readfile(&quot;.&#x2F;dataset&#x2F;validation&quot;, True)</span><br><span class="line">print(&quot;Size of validation data &#x3D; &#123;&#125;&quot;.format(len(val_x)))</span><br><span class="line">test_x &#x3D; readfile(&quot;.&#x2F;dataset&#x2F;testing&quot;, False)</span><br><span class="line">print(&quot;Size of Testing data &#x3D; &#123;&#125;&quot;.format(len(test_x)))</span><br></pre></td></tr></table></figure>
<h1 id="Step3：定义数据调用接口"><a href="#Step3：定义数据调用接口" class="headerlink" title="Step3：定义数据调用接口"></a><strong>Step3：定义数据调用接口</strong></h1><p>因为我是pytorch小白，前两节课是自己写函数，不需要调用任何的框架。而这次因为是做深度学习，不使用框架的话，那就是真的大佬了。<br>下面这段话是李老师给的参考代码里面的解释说明为什么我们要进行定义数据调用接口：</p>
<blockquote>
<p>在 Pytorch 中，我們可以利用 torch.utils.data 的 Dataset 及 DataLoader<br>來”包裝” data，使後續的 training 及 testing 更為方便。</p>
<p>Dataset 需要 overload 兩個函數：__len__ 及 __getitem__</p>
<p>__len__ 必須要回傳 dataset 的大小，而 __getitem__<br>則定義了當程式利用 [ ] 取值時，dataset 應該要怎麼回傳資料。</p>
<p>實際上我們並不會直接使用到這兩個函數，但是使用 DataLoader 在<br>enumerate Dataset 時會使用到，沒有實做的話會在程式運行階段出現 error。</p>
</blockquote>
<p>大体意思我给大家翻译一下就是，使用pytorch的Dataset和dataloader这个api来管理数据的调用以及返回数据量(当然还有很多方面，必须通过batch_size来管理每次取的数据量，这个下面代码会有所体现)，这是非常方便的，比我们直接使用上面的train_x等数据集方便了很多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对train和validation进行数据增强(data augmentation),可参考链接https:&#x2F;&#x2F;blog.csdn.net&#x2F;lanmengyiyu&#x2F;article&#x2F;details&#x2F;79658545</span><br><span class="line">train_transform &#x3D; transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),</span><br><span class="line">    transforms.RandomHorizontalFlip(),  # 随即将图片水平翻转</span><br><span class="line">    transforms.RandomRotation(15),  # 随即旋转图片15度</span><br><span class="line">    transforms.ToTensor(),  # 将图片转成 Tensor</span><br><span class="line">    # transforms.Normalize([0.34361264, 0.45097706, 0.5550434], [0.2783836, 0.27154413, 0.26915196])  # Normalize</span><br><span class="line">])</span><br><span class="line"># testing 時不需做 data augmentation</span><br><span class="line">test_transform &#x3D; transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),</span><br><span class="line">    transforms.ToTensor(),  # 将图片转成 Tensor</span><br><span class="line">    # transforms.Normalize([0.35057753, 0.45622048, 0.5620281], [0.2769976, 0.27097332, 0.26702392])  # Normalize</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>上面的代码大家看我的注释应该很明白，就是封装data Normalization和data augmentation，这点也是李老师ppt最后对我们的要求。<br>当然大家可以看下Normalize的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Normalize(object):</span><br><span class="line">    &quot;&quot;&quot;Normalize a tensor image with mean and standard deviation.</span><br><span class="line">    Given mean: &#96;&#96;(M1,...,Mn)&#96;&#96; and std: &#96;&#96;(S1,..,Sn)&#96;&#96; for &#96;&#96;n&#96;&#96; channels, this transform</span><br><span class="line">    will normalize each channel of the input &#96;&#96;torch.*Tensor&#96;&#96; i.e.</span><br><span class="line">    &#96;&#96;input[channel] &#x3D; (input[channel] - mean[channel]) &#x2F; std[channel]&#96;&#96;</span><br><span class="line"></span><br><span class="line">    .. note::</span><br><span class="line">        This transform acts out of place, i.e., it does not mutates the input tensor.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        mean (sequence): Sequence of means for each channel.</span><br><span class="line">        std (sequence): Sequence of standard deviations for each channel.</span><br><span class="line">        inplace(bool,optional): Bool to make this operation in-place.</span><br></pre></td></tr></table></figure>
<p>后面的我没再截，大体就是他根据你给函数的mean以及std来进行Normalize,使用的方法就是我们一直使用的均值标准差方法，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input[channel] &#x3D; (input[channel] - mean[channel]) &#x2F; std[channel]</span><br></pre></td></tr></table></figure>
<p>那么里面的[0.34361264, 0.45097706, 0.5550434], [0.2783836, 0.27154413, 0.26915196]这种数据是怎么得来的呢，后续会讲到。</p>
<p>还有对图片类的封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 集成了一个 Dataset类之后，我们需要重写 len 方法，该方法提供了dataset的大小；</span><br><span class="line"># getitem 方法， 该方法支持从 0 到 len(self)的索引</span><br><span class="line">class ImgDataset(Dataset):</span><br><span class="line">    def __init__(self, x, y&#x3D;None, transform&#x3D;None):</span><br><span class="line">        self.x &#x3D; x</span><br><span class="line">        # label is required to be a LongTensor</span><br><span class="line">        self.y &#x3D; y</span><br><span class="line">        if y is not None:</span><br><span class="line">            self.y &#x3D; torch.LongTensor(y)</span><br><span class="line">        self.transform &#x3D; transform</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.x)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        X &#x3D; self.x[index]</span><br><span class="line">        if self.transform is not None:</span><br><span class="line">            X &#x3D; self.transform(X)</span><br><span class="line">        if self.y is not None:</span><br><span class="line">            Y &#x3D; self.y[index]</span><br><span class="line">            return X, Y</span><br><span class="line">        else:  # 如果没有标签那么只返回X</span><br><span class="line">            return X</span><br></pre></td></tr></table></figure>

<p>调用时用到下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Dataset是一个包装类，用来将数据包装为Dataset类，</span><br><span class="line"># 然后传入DataLoader中，我们再使用DataLoader这个类来更加快捷的对数据进行操作。</span><br><span class="line">batch_size &#x3D; 50</span><br><span class="line">train_set &#x3D; ImgDataset(train_x, train_y, train_transform)</span><br><span class="line">val_set &#x3D; ImgDataset(val_x, val_y, test_transform)</span><br><span class="line">train_loader &#x3D; DataLoader(train_set, batch_size&#x3D;batch_size, shuffle&#x3D;True)  # 进行shuffle随机</span><br><span class="line">val_loader &#x3D; DataLoader(val_set, batch_size&#x3D;batch_size, shuffle&#x3D;False)</span><br></pre></td></tr></table></figure>
<h1 id="Step3：定义模型"><a href="#Step3：定义模型" class="headerlink" title="Step3：定义模型"></a><strong>Step3：定义模型</strong></h1><p>下面是最重要的一步，就是定义我们的模型，其实也没什么，李老师上课都已经讲过了，pytorch只是一个便于实现的框架而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;定义模型以及设置其中架构和一些参数&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Classifier(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Classifier, self).__init__()</span><br><span class="line">        # torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)</span><br><span class="line">        # torch.nn.MaxPool2d(kernel_size, stride, padding)</span><br><span class="line">        # input 維度 [3, 128, 128]</span><br><span class="line">        self.cnn &#x3D; nn.Sequential(</span><br><span class="line">            # 第一层卷积层和池化层的配置</span><br><span class="line">            # 第一个参数代表输入数据的通道数，例RGB图片通道数为3；</span><br><span class="line">            # 第二个参数代表输出数据的通道数，这个根据模型调整；</span><br><span class="line">            # 第三个参数是卷积核大小</span><br><span class="line">            # 第四个参数是stride，步长</span><br><span class="line">            # 第五个参数是padding，补1</span><br><span class="line">            nn.Conv2d(3, 64, 3, 1, 1),  # [64, 128, 128]，即输出是64*128*128维的图片</span><br><span class="line"></span><br><span class="line">            nn.BatchNorm2d(64),  # Normalize</span><br><span class="line">            nn.ReLU(),  # activate函数是relu函数</span><br><span class="line"></span><br><span class="line">            # 第一个参数是kernel_size，max pooling的窗口大小，</span><br><span class="line">            # 第二个参数是stride，max pooling的窗口移动的步长。默认值是kernel_size</span><br><span class="line">            # 第三个参数输入的每一条边补充0的层数，默认是0</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [64, 64, 64]</span><br><span class="line"></span><br><span class="line">            # 第二层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(64, 128, 3, 1, 1),  # [128, 64, 64]</span><br><span class="line">            nn.BatchNorm2d(128),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [128, 32, 32]</span><br><span class="line"></span><br><span class="line">            # 第三层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(128, 256, 3, 1, 1),  # [256, 32, 32]</span><br><span class="line">            nn.BatchNorm2d(256),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [256, 16, 16]</span><br><span class="line"></span><br><span class="line">            # 第四层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(256, 512, 3, 1, 1),  # [512, 16, 16]</span><br><span class="line">            nn.BatchNorm2d(512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [512, 8, 8]</span><br><span class="line"></span><br><span class="line">            # 第五层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(512, 512, 3, 1, 1),  # [512, 8, 8]</span><br><span class="line">            nn.BatchNorm2d(512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [512, 4, 4]</span><br><span class="line">        )</span><br><span class="line">        self.fc &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(512 * 4 * 4, 1024),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(1024, 512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(512, 11)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        out &#x3D; self.cnn(x)</span><br><span class="line">        out &#x3D; out.view(out.size()[0], -1)</span><br><span class="line">        return self.fc(out)</span><br></pre></td></tr></table></figure>
<h1 id="Step4：训练"><a href="#Step4：训练" class="headerlink" title="Step4：训练"></a><strong>Step4：训练</strong></h1><p>这一步也是我困扰最长时间的地方。众所周知，做深度学习基本上都会用到GPU进行并行计算来加速，不然用CPU跑一来是容易爆内存，而是运算速度实在太慢根本没法等。但有一个问题，我的GPU是1050ti，且一月份刚刚更新了显卡驱动，然后我发现我的显卡驱动支持的cuda版本是10.2，(什么是cuda以及cudnn，可以百度一下，我就不费口舌了)，我安装好了10.2版本的cuda以及对应的cudnn后，突然发现下载的pytorch 1.4稳定版最高只支持10.1版本的cuda。这样比较麻烦了，我的模型就没法跑了。通过大量的google以及百度并用，发现<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a>  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/2.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>而我的显卡是441.7+，意味着我的显卡就是只支持cuda10.2，于是有了一个大胆的想法，卸载当前的显卡驱动并安装旧版本的显卡驱动，还好nvida显卡驱动安装程序有个好处就是可以直接在安装程序里卸载当前的显卡驱动并直接安装。<br>下载显卡驱动各版本的页面：<a href="https://www.nvidia.com/Download/Find.aspx?lang=en-us">https://www.nvidia.com/Download/Find.aspx?lang=en-us</a><br>但有个小主意事项，显卡驱动分DCP以及标准两个版本，我一开始下的DCP，但我的电脑是只支持标准版本的，所以一开始没安装成功，又百度了好久。具体怎么看自己电脑支持什么版本的可以百度一下。  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/3.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>我一开始下载的441.20版本，只比那条基准线低了一点，安装后发现这个版本还是只支持cuda10.1，所以我又重新安装436.15版本，终于！成功了，是10.1版本的cuda，于是再把cuda和cudnn对应的10.1版本安装好，<a href="https://www.bilibili.com/video/BV1k4411C7Vb?from=search&seid=18053259594701605132">这个安装可以参考</a><br>至此，大部分的坑已经走过了，但也耗费了一天(具体不能说一天，因为我白天还得学高等数学线代以及英语来准备考研，大概就是一晚上多点)，如果你们遇到了相同的情况可以参考一下，再有问题可以加我qq跟我联系我们讨论。</p>
<p>训练的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;# Training</span><br><span class="line"></span><br><span class="line">使用training set訓練，並使用validation set尋找好的參數</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">model &#x3D; Classifier().cuda()</span><br><span class="line">loss &#x3D; nn.CrossEntropyLoss()  # 因為是 classification task，所以 loss 使用 CrossEntropyLoss 正交熵</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(model.parameters(), lr&#x3D;0.001)  # optimizer 使用 Adam，学习率是0.1</span><br><span class="line">num_epoch &#x3D; 30  # 迭代30次</span><br><span class="line"></span><br><span class="line">for epoch in range(num_epoch):</span><br><span class="line">    epoch_start_time &#x3D; time.time()</span><br><span class="line">    train_acc &#x3D; 0.0</span><br><span class="line">    train_loss &#x3D; 0.0</span><br><span class="line">    val_acc &#x3D; 0.0</span><br><span class="line">    val_loss &#x3D; 0.0</span><br><span class="line"></span><br><span class="line">    model.train()  # 確保 model 是在 train model (開啟 Dropout 等...)</span><br><span class="line">    for i, data in enumerate(train_loader):</span><br><span class="line">        optimizer.zero_grad()  # 用 optimizer 將 model 參數的 gradient 歸零</span><br><span class="line">        train_pred &#x3D; model(data[0].cuda())  # 利用 model 得到預測的機率分佈 這邊實際上就是去呼叫 model 的 forward 函數</span><br><span class="line">        batch_loss &#x3D; loss(train_pred, data[1].cuda())  # 計算 loss （注意 prediction 跟 label 必須同時在 CPU 或是 GPU 上）</span><br><span class="line">        batch_loss.backward()  # 利用 back propagation 算出每個參數的 gradient</span><br><span class="line">        optimizer.step()  # 以 optimizer 用 gradient 更新參數值</span><br><span class="line"></span><br><span class="line">        train_acc +&#x3D; np.sum(np.argmax(train_pred.cpu().data.numpy(), axis&#x3D;1) &#x3D;&#x3D; data[1].numpy())</span><br><span class="line">        train_loss +&#x3D; batch_loss.item()</span><br><span class="line"></span><br><span class="line">    model.eval()</span><br><span class="line">    with torch.no_grad():  # 防止GPU爆</span><br><span class="line">        for i, data in enumerate(val_loader):</span><br><span class="line">            val_pred &#x3D; model(data[0].cuda())</span><br><span class="line">            batch_loss &#x3D; loss(val_pred, data[1].cuda())</span><br><span class="line"></span><br><span class="line">            val_acc +&#x3D; np.sum(np.argmax(val_pred.cpu().data.numpy(), axis&#x3D;1) &#x3D;&#x3D; data[1].numpy())</span><br><span class="line">            val_loss +&#x3D; batch_loss.item()</span><br><span class="line"></span><br><span class="line">        # 將結果 print 出來</span><br><span class="line">        print(&#39;[%03d&#x2F;%03d] %2.2f sec(s) Train Acc: %3.6f Loss: %3.6f | Val Acc: %3.6f loss: %3.6f&#39; % \</span><br><span class="line">              (epoch + 1, num_epoch, time.time() - epoch_start_time, \</span><br><span class="line">               train_acc &#x2F; train_set.__len__(), train_loss &#x2F; train_set.__len__(), val_acc &#x2F; val_set.__len__(),</span><br><span class="line">               val_loss &#x2F; val_set.__len__()))</span><br></pre></td></tr></table></figure>
<p>上面的代码可以展示train和val的训练正确率以及loss随迭代的变化，当我们通过各种调参数来使效果达到最好时，别忘了将train和val的数据进行结合重新训练，这样数据更多模型效果会更好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;得到好的參數後，我們使用training set和validation set共同訓練（資料量變多，模型效果較好）&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">train_val_x &#x3D; np.concatenate((train_x, val_x), axis&#x3D;0)</span><br><span class="line">train_val_y &#x3D; np.concatenate((train_y, val_y), axis&#x3D;0)</span><br><span class="line">train_val_set &#x3D; ImgDataset(train_val_x, train_val_y, train_transform)</span><br><span class="line">train_val_loader &#x3D; DataLoader(train_val_set, batch_size&#x3D;batch_size, shuffle&#x3D;True)</span><br><span class="line"></span><br><span class="line">model_best &#x3D; Classifier().cuda()</span><br><span class="line">loss &#x3D; nn.CrossEntropyLoss()  # 因為是 classification task，所以 loss 使用 CrossEntropyLoss</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(model_best.parameters(), lr&#x3D;0.001)  # optimizer 使用 Adam</span><br><span class="line">num_epoch &#x3D; 30</span><br><span class="line"></span><br><span class="line">for epoch in range(num_epoch):</span><br><span class="line">    epoch_start_time &#x3D; time.time()</span><br><span class="line">    train_acc &#x3D; 0.0</span><br><span class="line">    train_loss &#x3D; 0.0</span><br><span class="line"></span><br><span class="line">    model_best.train()</span><br><span class="line">    for i, data in enumerate(train_val_loader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        train_pred &#x3D; model_best(data[0].cuda())  # 预测的结果</span><br><span class="line">        batch_loss &#x3D; loss(train_pred, data[1].cuda())  # data[1]代表真实值</span><br><span class="line">        batch_loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        train_acc +&#x3D; np.sum(np.argmax(train_pred.cpu().data.numpy(), axis&#x3D;1) &#x3D;&#x3D; data[1].numpy())</span><br><span class="line">        train_loss +&#x3D; batch_loss.item()</span><br><span class="line"></span><br><span class="line">        # 將結果 print 出來</span><br><span class="line">    print(&#39;[%03d&#x2F;%03d] %2.2f sec(s) Train Acc: %3.6f Loss: %3.6f&#39; % \</span><br><span class="line">          (epoch + 1, num_epoch, time.time() - epoch_start_time, \</span><br><span class="line">           train_acc &#x2F; train_val_set.__len__(), train_loss &#x2F; train_val_set.__len__()))</span><br></pre></td></tr></table></figure>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/4.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/5.png" class="" title="[李宏毅机器学习-第三课作业]">  

<h1 id="Step5：预测测试集"><a href="#Step5：预测测试集" class="headerlink" title="Step5：预测测试集"></a><strong>Step5：预测测试集</strong></h1><p>然后是预测测试集并得到结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;# Testing</span><br><span class="line">利用剛剛 train 好的 model 進行 prediction</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">test_set &#x3D; ImgDataset(test_x, transform&#x3D;test_transform)</span><br><span class="line">test_loader &#x3D; DataLoader(test_set, batch_size&#x3D;batch_size, shuffle&#x3D;False)</span><br><span class="line"></span><br><span class="line">model_best.eval()</span><br><span class="line">prediction &#x3D; []</span><br><span class="line">with torch.no_grad():</span><br><span class="line">    for i, data in enumerate(test_loader):</span><br><span class="line">        test_pred &#x3D; model_best(data.cuda())</span><br><span class="line">        test_label &#x3D; np.argmax(test_pred.cpu().data.numpy(), axis&#x3D;1)</span><br><span class="line">        for y in test_label:</span><br><span class="line">            prediction.append(y)</span><br><span class="line"></span><br><span class="line"># 將結果寫入 csv 檔</span><br><span class="line">with open(&quot;predict.csv&quot;, &#39;w&#39;) as f:</span><br><span class="line">    f.write(&#39;Id,Category\n&#39;)</span><br><span class="line">    for i, y in enumerate(prediction):</span><br><span class="line">        f.write(&#39;&#123;&#125;,&#123;&#125;\n&#39;.format(i, y))</span><br></pre></td></tr></table></figure>
<p>到现在，最简单的部分完成了，我们也大概将模型跑了一遍得到了结果。</p>
<h1 id="Step6：思考总结"><a href="#Step6：思考总结" class="headerlink" title="Step6：思考总结"></a><strong>Step6：思考总结</strong></h1><p>下面按照李老师的要求我们再进行一下实践:  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/6.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>初始模型我们搞定了，现在搞定一个模型参数量大体相同，但深度减半的模型，注意，只需要替换定义模型那一步的代码即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Classifier(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Classifier, self).__init__()</span><br><span class="line">        # torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)</span><br><span class="line">        # torch.nn.MaxPool2d(kernel_size, stride, padding)</span><br><span class="line">        # input 維度 [3, 128, 128]</span><br><span class="line">        self.cnn &#x3D; nn.Sequential(</span><br><span class="line">            # 第一层卷积层和池化层的配置</span><br><span class="line">            # 第一个参数代表输入数据的通道数，例RGB图片通道数为3；</span><br><span class="line">            # 第二个参数代表输出数据的通道数，这个根据模型调整；</span><br><span class="line">            # 第三个参数是卷积核大小</span><br><span class="line">            # 第四个参数是stride，步长</span><br><span class="line">            # 第五个参数是padding，补1</span><br><span class="line">            nn.Conv2d(3, 64, 3, 1, 1),  # [64, 128, 128]，即输出是64*128*128维的图片</span><br><span class="line"></span><br><span class="line">            nn.BatchNorm2d(64),  # 防止梯度消失或爆炸，设置的参数就是卷积的输出通道数</span><br><span class="line">            nn.ReLU(),  # activate函数是relu函数</span><br><span class="line"></span><br><span class="line">            # 第一个参数是kernel_size，max pooling的窗口大小，</span><br><span class="line">            # 第二个参数是stride，max pooling的窗口移动的步长。默认值是kernel_size</span><br><span class="line">            # 第三个参数输入的每一条边补充0的层数，默认是0</span><br><span class="line">            nn.MaxPool2d(4, 4, 0),  # [64, 32, 32]</span><br><span class="line"></span><br><span class="line">            # 第二层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(64, 512, 3, 1, 1),  # [512, 32, 32]</span><br><span class="line">            nn.BatchNorm2d(512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(4, 4, 0),  # [512, 8, 8]</span><br><span class="line"></span><br><span class="line">            # 第三层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(512, 512, 3, 1, 1),  # [512, 8, 8]</span><br><span class="line">            nn.BatchNorm2d(512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [512,4, 4]</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">        self.fc &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(512 * 4 * 4, 1024),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(1024, 512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(512, 11)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        out &#x3D; self.cnn(x)</span><br><span class="line">        out &#x3D; out.view(out.size()[0], -1)</span><br><span class="line">        return self.fc(out)</span><br></pre></td></tr></table></figure>
<p>一定注意，既然深度减半，那么后面的DNN就不可以轻易改变。从5层变为3层后每一层的输出维度一定要固定好，比如第一层是输出维度是[64,128,128]，池化层是[4,4]则下一层你可以定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nn.Conv2d(64, 512, 3, 1, 1)</span><br></pre></td></tr></table></figure>
<p>即输入是上一层的输出64，输出是512，这样数据的维度就会变为[512,32,32]。然后再进入一个[4,4]的池化层就会变为[512,8,8],依次类推，只要对应好就行，最后CNN结束后输入到神经网络中的维度是[512,4,4]，这里一定是不要动，不然很难保证参数稳住不会爆炸(我试了试修改了这里成[512,8,8]等等其他情况，参数都飙到一亿多了)。我试了很多种架构，最接近第一个模型的架构就是上面的架构，参数量：<br>原始模型：  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/7.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>参数不变CNN深度减半的模型：  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/8.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>训练后的结果：  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/9.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/10.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>获得参数量的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import torch.nn as nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Classifier(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #具体的架构</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        out &#x3D; self.cnn(x)</span><br><span class="line">        out &#x3D; out.view(out.size()[0], -1)</span><br><span class="line">        return self.fc(out)</span><br><span class="line"></span><br><span class="line">def params_count(model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Compute the number of parameters.</span><br><span class="line">    Args:</span><br><span class="line">        model (model): model to count the number of parameters.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return np.sum([p.numel() for p in model.parameters()]).item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    model &#x3D; Classifier()</span><br><span class="line">    print(params_count(model))</span><br></pre></td></tr></table></figure>
<p>然后参数量不变，DNN简单的模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Classifier(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Classifier, self).__init__()</span><br><span class="line">        # torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding)</span><br><span class="line">        # torch.nn.MaxPool2d(kernel_size, stride, padding)</span><br><span class="line">        # input 維度 [3, 128, 128]</span><br><span class="line">        self.cnn &#x3D; nn.Sequential(</span><br><span class="line">            # 第一层卷积层和池化层的配置</span><br><span class="line">            # 第一个参数代表输入数据的通道数，例RGB图片通道数为3；</span><br><span class="line">            # 第二个参数代表输出数据的通道数，这个根据模型调整；</span><br><span class="line">            # 第三个参数是卷积核大小</span><br><span class="line">            # 第四个参数是stride，步长</span><br><span class="line">            # 第五个参数是padding，补1</span><br><span class="line">            nn.Conv2d(3, 64, 3, 1, 1),  # [64, 128, 128]，即输出是64*128*128维的图片</span><br><span class="line"></span><br><span class="line">            nn.BatchNorm2d(64),  # 防止梯度消失或爆炸，设置的参数就是卷积的输出通道数</span><br><span class="line">            nn.ReLU(),  # activate函数是relu函数</span><br><span class="line"></span><br><span class="line">            # 第一个参数是kernel_size，max pooling的窗口大小，</span><br><span class="line">            # 第二个参数是stride，max pooling的窗口移动的步长。默认值是kernel_size</span><br><span class="line">            # 第三个参数输入的每一条边补充0的层数，默认是0</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [64, 64, 64]</span><br><span class="line"></span><br><span class="line">            # 第二层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(64, 128, 3, 1, 1),  # [128, 64, 64]</span><br><span class="line">            nn.BatchNorm2d(128),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [128, 32, 32]</span><br><span class="line"></span><br><span class="line">            # 第三层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(128, 256, 3, 1, 1),  # [256, 32, 32]</span><br><span class="line">            nn.BatchNorm2d(256),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [256, 16, 16]</span><br><span class="line"></span><br><span class="line">            # 第四层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(256, 512, 3, 1, 1),  # [512, 16, 16]</span><br><span class="line">            nn.BatchNorm2d(512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [512, 8, 8]</span><br><span class="line"></span><br><span class="line">            # 第五层卷积层和池化层的配置</span><br><span class="line">            nn.Conv2d(512, 512, 3, 1, 1),  # [512, 8, 8]</span><br><span class="line">            nn.BatchNorm2d(512),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(2, 2, 0),  # [512, 4, 4]</span><br><span class="line">        )</span><br><span class="line">        self.fc &#x3D; nn.Sequential(</span><br><span class="line">            nn.Linear(512 * 4 * 4, 1024),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(1024, 11)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        out &#x3D; self.cnn(x)</span><br><span class="line">        out &#x3D; out.view(out.size()[0], -1)</span><br><span class="line">        return self.fc(out)</span><br></pre></td></tr></table></figure>
<p>同样的思路，但这次只改变DNN的架构即可，参数量为：  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/11.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>训练结果：  </p>
  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/13.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>相比上面所有的模型，我们可以得到的结论：<br>竟然是DNN简单的模型在验证集上表现最好，深度减半第二，原模型最差。但在训练集上的结果大概都是91%左右，所以我觉得都差不多。  </p>
<h1 id="Step7：Normalize的具体代码"><a href="#Step7：Normalize的具体代码" class="headerlink" title="Step7：Normalize的具体代码"></a><strong>Step7：Normalize的具体代码</strong></h1><p>我们在第二步对data进行了Normalize，实际上原始模型是不加Normalize的，这个是实践的部分，只需将第二步的代码取消注释再跑一遍即可。结果如下。</p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/14.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/15.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Import需要的套件</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">import torch</span><br><span class="line">import torchvision.transforms as transforms</span><br><span class="line">from torch.utils.data import DataLoader, Dataset</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;#Read image</span><br><span class="line">利用 OpenCV (cv2) 讀入照片並存放在 numpy array 中</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 当label等于false时即不需要返回label，用来处理test集，方便统一管理</span><br><span class="line">def readfile(path, label):</span><br><span class="line">    # label 是一個 boolean variable，代表需不需要回傳 y 值</span><br><span class="line">    image_dir &#x3D; sorted(os.listdir(path))</span><br><span class="line">    x &#x3D; np.zeros((len(image_dir), 128, 128, 3), dtype&#x3D;np.uint8)</span><br><span class="line">    y &#x3D; np.zeros((len(image_dir)), dtype&#x3D;np.uint8)</span><br><span class="line">    for i, file in enumerate(image_dir):</span><br><span class="line">        img &#x3D; cv2.imread(os.path.join(path, file))</span><br><span class="line">        x[i, :, :] &#x3D; cv2.resize(img, (128, 128))</span><br><span class="line">        if label:</span><br><span class="line">            y[i] &#x3D; int(file.split(&quot;_&quot;)[0])</span><br><span class="line">    if label:</span><br><span class="line">        return x, y</span><br><span class="line">    else:</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 集成了一个 Dataset类之后，我们需要重写 len 方法，该方法提供了dataset的大小；</span><br><span class="line"># getitem 方法， 该方法支持从 0 到 len(self)的索引</span><br><span class="line">class ImgDataset(Dataset):</span><br><span class="line">    def __init__(self, x, y&#x3D;None, transform&#x3D;None):</span><br><span class="line">        self.x &#x3D; x</span><br><span class="line">        # label is required to be a LongTensor</span><br><span class="line">        self.y &#x3D; y</span><br><span class="line">        if y is not None:</span><br><span class="line">            self.y &#x3D; torch.LongTensor(y)</span><br><span class="line">        self.transform &#x3D; transform</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.x)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        X &#x3D; self.x[index]</span><br><span class="line">        if self.transform is not None:</span><br><span class="line">            X &#x3D; self.transform(X)</span><br><span class="line">        if self.y is not None:</span><br><span class="line">            Y &#x3D; self.y[index]</span><br><span class="line">            return X, Y</span><br><span class="line">        else:  # 如果没有标签那么只返回X</span><br><span class="line">            return X</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&quot;Reading data&quot;)</span><br><span class="line">    train_x, train_y &#x3D; readfile(&quot;.&#x2F;dataset&#x2F;training&quot;, True)</span><br><span class="line">    val_x, val_y &#x3D; readfile(&quot;.&#x2F;dataset&#x2F;validation&quot;, True)</span><br><span class="line">    test_x &#x3D; readfile(&quot;.&#x2F;dataset&#x2F;testing&quot;, False)</span><br><span class="line"></span><br><span class="line">    train_transform &#x3D; transforms.Compose([</span><br><span class="line">        # transforms.ToPILImage(),</span><br><span class="line">        # transforms.RandomHorizontalFlip(),  # 随即将图片水平翻转</span><br><span class="line">        # transforms.RandomRotation(15),  # 随即旋转图片15度</span><br><span class="line">        transforms.ToTensor(),  # 将图片转成 Tensor</span><br><span class="line">        # transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))  # 归一化</span><br><span class="line">    ])</span><br><span class="line">    # testing 時不需做 data augmentation</span><br><span class="line">    test_transform &#x3D; transforms.Compose([</span><br><span class="line">        # transforms.ToPILImage(),</span><br><span class="line">        transforms.ToTensor(),  # 将图片转成 Tensor</span><br><span class="line">        # transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))  # 归一化</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    batch_size &#x3D; 50</span><br><span class="line">    train_set &#x3D; ImgDataset(train_x, train_y, train_transform)</span><br><span class="line">    test_set &#x3D; ImgDataset(test_x, transform&#x3D;test_transform)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Normlize</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    dataloader1 &#x3D; DataLoader(train_set, batch_size&#x3D;50, shuffle&#x3D;False, num_workers&#x3D;4)</span><br><span class="line">    dataloader2 &#x3D; DataLoader(test_set, batch_size&#x3D;20, shuffle&#x3D;False, num_workers&#x3D;4)</span><br><span class="line"></span><br><span class="line">    pop_mean0 &#x3D; []</span><br><span class="line">    pop_std0 &#x3D; []</span><br><span class="line"></span><br><span class="line">    pop_mean1 &#x3D; []</span><br><span class="line">    pop_std1 &#x3D; []</span><br><span class="line"></span><br><span class="line">    for i, data in enumerate(dataloader1):</span><br><span class="line">        # shape (batch_size, 3, height, width)</span><br><span class="line">        numpy_image &#x3D; data[0].numpy()  # 将数据转换成矩阵</span><br><span class="line"></span><br><span class="line">        # shape (3,)</span><br><span class="line">        batch_mean &#x3D; np.mean(numpy_image, axis&#x3D;(0, 2, 3))  # 计算mean</span><br><span class="line">        batch_std0 &#x3D; np.std(numpy_image, axis&#x3D;(0, 2, 3))  # 计算std</span><br><span class="line"></span><br><span class="line">        pop_mean0.append(batch_mean)</span><br><span class="line">        pop_std0.append(batch_std0)</span><br><span class="line"></span><br><span class="line">    # shape (num_iterations, 3) -&gt; (mean across 0th axis) -&gt; shape (3,)</span><br><span class="line">    pop_mean0 &#x3D; np.array(pop_mean0).mean(axis&#x3D;0)</span><br><span class="line">    pop_std0 &#x3D; np.array(pop_std0).mean(axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">    for i, data in enumerate(dataloader2):</span><br><span class="line">        # shape (batch_size, 3, height, width)</span><br><span class="line">        numpy_image &#x3D; data.numpy()</span><br><span class="line"></span><br><span class="line">        # shape (3,)</span><br><span class="line">        batch_mean &#x3D; np.mean(numpy_image, axis&#x3D;(0, 2, 3))</span><br><span class="line">        batch_std0 &#x3D; np.std(numpy_image, axis&#x3D;(0, 2, 3))</span><br><span class="line"></span><br><span class="line">        pop_mean1.append(batch_mean)</span><br><span class="line">        pop_std1.append(batch_std0)</span><br><span class="line"></span><br><span class="line">    # shape (num_iterations, 3) -&gt; (mean across 0th axis) -&gt; shape (3,)</span><br><span class="line">    pop_mean1 &#x3D; np.array(pop_mean1).mean(axis&#x3D;0)</span><br><span class="line">    pop_std1 &#x3D; np.array(pop_std1).mean(axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">    print(pop_mean0, pop_std0)</span><br><span class="line">    print(pop_mean1, pop_std1)</span><br></pre></td></tr></table></figure>
<p>这里输出的pop_mean0和pop_std0代表着训练集的mean和std，剩下两个代表着测试集的mean和std。这样计算出来后就可以加载到Normalize函数的参数里面去了。<br>以上，我们就完成了实验3，确实整个实验都挺累人的，但我觉得给我的收获也很大。共勉！</p>
<h1 id="Step8：一些需要注意的点"><a href="#Step8：一些需要注意的点" class="headerlink" title="Step8：一些需要注意的点"></a><strong>Step8：一些需要注意的点</strong></h1><p>测试GPU是否可以使用时，可以使用下面的函数进行判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] &#x3D; &#39;0&#39;</span><br><span class="line">print(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<p>当返回True时，就代表这可以使用GPU，否则就不可以，这个时候你就得看看你的cuda或者cudnn有没有装对，以及pytorch版本有没有装对，或者是其他七七八八的问题。</p>
<p>还有一个点就是，实际上大家可以使用google colab来跑这些实验，因为这些实验的数据集老师都是开放的，所以我们只需通过链接就可以访问，但首先你的科学上网，否则一切都是白谈。</p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/16.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/17.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/18.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/19.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>这数据集加载速度！这训练速度！爽到！但记得在设置里开启硬件加速GPU，否则是不会很快的。(甚至出错),而且最重要的，google colab完全免费，我当时跑模型用的GPU是16G的显存！足足比我的小1050ti快了3倍！<br>colab大家都说不好用的原因是因为我们需要挂载google drive来存放数据集进而进行训练，而google drive只有50g的免费空间，如果数据集过大，一是国内上传速度太慢，而是如果50g不够就得缴费了。所以大家好像都不是很感冒。但！因为我们做的作业数据集是保存在李老师网盘中的，而且给了链接任何人都可以访问，所以完美的解决我们的问题！</p>
<p>最后还有一个需要注意的点，在训练时，如果你的显存够大，那么你可以在设置batch_size时设置的大一点，但如果像我这种渣渣1050ti，最好设置50左右就可以了，64会爆(亲测)，所以如果你在运行时发现显卡爆了，你就检查一下看看是不是batch_size设置的太大了，调小一点试试。</p>
<h1 id="Step8：kaggle-rank"><a href="#Step8：kaggle-rank" class="headerlink" title="Step8：kaggle rank"></a><strong>Step8：kaggle rank</strong></h1><p><a href="https://www.kaggle.com/c/ml2020spring-hw3/">https://www.kaggle.com/c/ml2020spring-hw3/</a>  </p>
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/20.png" class="" title="[李宏毅机器学习-第三课作业]">  
<img src="/2020/03/28/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%BD%9C%E4%B8%9A/21.png" class="" title="[李宏毅机器学习-第三课作业]">  
<p>这是将四个模型得到的结果传到kaggle上的分数：可以看到原始模型才0.57…而最高的得分模型就是简单的DNN模型，这样跟我们的预期也类似。<br>继续加油吧！</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
        <tag>多分类问题</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习-keras demo</title>
    <url>/2020/03/23/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-keras-demo/</url>
    <content><![CDATA[<p>因为讲了很多deep learning的内容，李老师给我们举了一个使用keras作deep learning的例子，因为keras做神经网络非常方便，里面函数也很全，所以非常简单就可以上手，首先先写处理数据集的函数，因为我们用手写数字识别，那么最著名的就是mnist数据集了，因为我的网络访问keras数据库网站太慢，所以我提前下好了然后改了一下它的数据库源码来映射到我自己下载好的数据库中</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mnist.py中：</span><br><span class="line">def load_data(path&#x3D;&#39;mnist.npz&#39;):</span><br><span class="line">    &quot;&quot;&quot;Loads the MNIST dataset.</span><br><span class="line"></span><br><span class="line">    # Arguments</span><br><span class="line">        path: path where to cache the dataset locally</span><br><span class="line">            (relative to ~&#x2F;.keras&#x2F;datasets).</span><br><span class="line"></span><br><span class="line">    # Returns</span><br><span class="line">        Tuple of Numpy arrays: &#96;(x_train, y_train), (x_test, y_test)&#96;.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # path &#x3D; get_file(path,</span><br><span class="line">    #                 origin&#x3D;&#39;https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;img-datasets&#x2F;mnist.npz&#39;,</span><br><span class="line">    #                 file_hash&#x3D;&#39;8a61469f7ea1b51cbae51d4f78837e45&#39;)</span><br><span class="line">    path&#x3D;&#39;F:\\python\\Lib\\site-packages\\keras\\datasets\\mnist.npz&#39; #当前目录下的文件</span><br><span class="line">    f &#x3D; np.load(path)</span><br><span class="line">    x_train, y_train &#x3D; f[&#39;x_train&#39;], f[&#39;y_train&#39;]</span><br><span class="line">    x_test, y_test &#x3D; f[&#39;x_test&#39;], f[&#39;y_test&#39;]</span><br><span class="line">    f.close()</span><br><span class="line">    return (x_train, y_train), (x_test, y_test)</span><br></pre></td></tr></table></figure>

<p>导入库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from keras.datasets import mnist</span><br><span class="line">from keras.utils import np_utils</span><br><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers.core import Dense, Dropout, Activation</span><br><span class="line">from keras.layers import Conv2D, MaxPooling2D, Flatten</span><br><span class="line">from keras.optimizers import SGD, adam</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br></pre></td></tr></table></figure>

<p>先写一个loaddata的函数用来获取训练集，测试集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def load_data():</span><br><span class="line">    (x_train, y_train), (x_test, y_test) &#x3D; mnist.load_data()</span><br><span class="line">    number &#x3D; 10000</span><br><span class="line">    x_train &#x3D; x_train[0:number]</span><br><span class="line">    y_train &#x3D; y_train[0:number]</span><br><span class="line">    x_train &#x3D; x_train.reshape(number, 28 * 28)</span><br><span class="line">    x_test &#x3D; x_test.reshape(x_test.shape[0], 28 * 28)</span><br><span class="line">    x_train &#x3D; x_train.astype(&#39;float32&#39;)</span><br><span class="line">    x_test &#x3D; x_test.astype(&#39;float32&#39;)</span><br><span class="line"></span><br><span class="line">    y_train &#x3D; np_utils.to_categorical(y_train, 10)</span><br><span class="line">    y_test &#x3D; np_utils.to_categorical(y_test, 10)</span><br><span class="line">    x_train &#x3D; x_train</span><br><span class="line">    x_test &#x3D; x_test</span><br><span class="line"></span><br><span class="line">    x_train &#x3D; x_train &#x2F; 255</span><br><span class="line">    x_test &#x3D; x_test &#x2F; 255</span><br><span class="line"></span><br><span class="line">    return (x_train, y_train), (x_test, y_test)</span><br></pre></td></tr></table></figure>
<p>接下来跑一下看看分的数据集的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x_train, y_train), (x_test, y_test) &#x3D; load_data()</span><br><span class="line"></span><br><span class="line">print(x_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(x_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure>
<img src="/2020/03/23/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-keras-demo/1.png" class="" title="[李宏毅机器学习-keras demo]">  

<p>下一步，进行一些神经网络的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model &#x3D; Sequential()  # 建立一个神经网络</span><br><span class="line">model.add(Dense(input_dim&#x3D;28 * 28, units&#x3D;689, activation&#x3D;&#39;relu&#39;))  # 增加第一层输入层，维度是28*28，后面连接的第一层隐藏层的神经元个数是689，激活函数是relu</span><br><span class="line">model.add(Dropout(0.7))  # 使用dropout</span><br><span class="line">model.add(Dense(units&#x3D;689, activation&#x3D;&#39;relu&#39;))  # 第二层隐藏层神经元个数689，激活函数是relu</span><br><span class="line">model.add(Dropout(0.7))</span><br><span class="line">model.add(Dense(units&#x3D;10, activation&#x3D;&#39;softmax&#39;))  # 最后一层因为是手写数字识别，那么激活函数一定要用softmax</span><br><span class="line"># 对模型进行设置，设置loss function，learning rate的优化函数，metrics用于设定评估当前训练模型的性能的评估函数</span><br><span class="line"></span><br><span class="line">model.compile(loss&#x3D;&#39;categorical_crossentropy&#39;, optimizer&#x3D;&#39;adam&#39;, metrics&#x3D;[&#39;accuracy&#39;])</span><br></pre></td></tr></table></figure>
<p>神经网络已经配置好了，下面进行训练，并且查看正确率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进行训练，使用x_train作为训练集y_train作为训练集对应的标签，设置batch_size和epochs从而进行小批次循环训练，并且可以使用GPU加速</span><br><span class="line">model.fit(x_train, y_train, batch_size&#x3D;100, epochs&#x3D;20)</span><br><span class="line"></span><br><span class="line"># 输出模型在train set的正确率,一定要看train set的表现，因为test set表现不好可能是因为没有train好或者overfitting，</span><br><span class="line"># 但train set的表现不好就说明不是overfitting，所以再根据需要换函数</span><br><span class="line">result &#x3D; model.evaluate(x_train, y_train, batch_size&#x3D;10000)</span><br><span class="line">print(&#39;\nTrain Acc:&#39;, result[1])</span><br><span class="line"></span><br><span class="line"># 输出模型在test set的正确率</span><br><span class="line">result &#x3D; model.evaluate(x_test, y_test, batch_size&#x3D;10000)</span><br><span class="line">print(&#39;\nTest Acc:&#39;, result[1])</span><br></pre></td></tr></table></figure>
<p>下面的优化是我之前已经做好了但没有截图，所以只有文字</p>
<ol>
<li>loss func选择mse时的表现是<br>Train Acc: 0.31349998712539673<br>Test Acc: 0.31049999594688416</li>
<li>loss func选择categorical_crossentropy表现是<br>Train Acc: 0.899399995803833<br>Test Acc: 0.8867999911308289</li>
<li>激活函数从sigmoid调整为relu时得到<br>Train Acc: 0.9965000152587891<br>Test Acc: 0.9521999955177307</li>
<li>optimizer选择从SGD换成adam<br>Train Acc: 1.0<br>Test Acc: 0.9663000106811523</li>
<li>加了dropout后<br>Train Acc: 0.9934999942779541<br>Test Acc: 0.9635999798774719  </li>
</ol>
<p>而在load_data()中不进行Normalize的话，train的效果一样也不好</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
        <tag>手写数字识别</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习-第二课作业</title>
    <url>/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>第二个作业，是关于逻辑回归的，逻辑回归可以看做是线性回归的拓展。还是将步骤分为7步，实际上我第一遍做的时候类似第一次作业写的代码，获得的正确率大概是80%，说实话有点低，于是参考了一下老师的代码，并优化了一下，最后的正确率从大概是87.89%。这篇博客便是将作业思路做一下总结。</p>
<a id="more"></a>

<h1 id="Step1：明确目标"><a href="#Step1：明确目标" class="headerlink" title="Step1：明确目标"></a><strong>Step1：明确目标</strong></h1><img src="/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/1.png" class="" title="[李宏毅机器学习-第二课作业]">  
<img src="/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/2.png" class="" title="[李宏毅机器学习-第二课作业]">  

<p>给我们的一共是六个：输出结果的格式，需要你预测的不带标签的测试集，训练集，X_train,Y_train,X_test。实际上通过观察后三个文件，发现只需要后三个文件即可，后三个文件是老师事先帮我们将数据整理成csv格式并且全都是数字的数据。经过观察我们可以发现<br>训练数据共54256个，测试集大概20000多个，然后参数共510个。那么可以得出结论</p>
<ul>
<li><input disabled="" type="checkbox"> 模型的输入是510维</li>
<li><input disabled="" type="checkbox"> 模型输出是一个布尔值表示预测的是或不是。<br>所以最适合的模型是<strong>Logistic Regression model</strong>。</li>
</ul>
<h1 id="Step2：数据预处理"><a href="#Step2：数据预处理" class="headerlink" title="Step2：数据预处理"></a><strong>Step2：数据预处理</strong></h1><p>老师已经将数据帮我们处理好了，我们只需获取即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据预处理，将读到的数据分别存入X_train，Y_train,X_test中</span><br><span class="line">np.random.seed(0)</span><br><span class="line">X_train_fpath &#x3D; &#39;.&#x2F;dataset&#x2F;X_train&#39;</span><br><span class="line">Y_train_fpath &#x3D; &#39;.&#x2F;dataset&#x2F;Y_train&#39;</span><br><span class="line">X_test_fpath &#x3D; &#39;.&#x2F;dataset&#x2F;X_test&#39;</span><br><span class="line">output_fpath &#x3D; &#39;.&#x2F;output_&#123;&#125;.csv&#39;</span><br><span class="line"></span><br><span class="line"># Parse csv files to numpy array</span><br><span class="line">with open(X_train_fpath) as f:</span><br><span class="line">    next(f)</span><br><span class="line">    X_train &#x3D; np.array([line.strip(&#39;\n&#39;).split(&#39;,&#39;)[1:] for line in f], dtype&#x3D;float)</span><br><span class="line">with open(Y_train_fpath) as f:</span><br><span class="line">    next(f)</span><br><span class="line">    Y_train &#x3D; np.array([line.strip(&#39;\n&#39;).split(&#39;,&#39;)[1] for line in f], dtype&#x3D;float)</span><br><span class="line">with open(X_test_fpath) as f:</span><br><span class="line">    next(f)</span><br><span class="line">    X_test &#x3D; np.array([line.strip(&#39;\n&#39;).split(&#39;,&#39;)[1:] for line in f], dtype&#x3D;float)</span><br></pre></td></tr></table></figure>

<p>以上做完之后，我们就按步骤继续进行。</p>
<h1 id="Step3：Normalize与训练集分类即其他后续训练所用到的函数定义"><a href="#Step3：Normalize与训练集分类即其他后续训练所用到的函数定义" class="headerlink" title="Step3：Normalize与训练集分类即其他后续训练所用到的函数定义"></a><strong>Step3：Normalize与训练集分类即其他后续训练所用到的函数定义</strong></h1><p>Normalize的方法还是使用标准差标准化方法。但需要注意的是，这一次我们将所有将会用到的操作全部写进函数，所以注意函数的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Normalize函数，对数据进行正规化</span><br><span class="line">def _normalize(X, train&#x3D;True, specified_column&#x3D;None, X_mean&#x3D;None, X_std&#x3D;None):  # 函数内定义的都是默认的参数，参数的意义底下有说明</span><br><span class="line">    # This function normalizes specific columns of X.</span><br><span class="line">    # The mean and standard variance of training data will be reused when processing testing data.</span><br><span class="line">    #</span><br><span class="line">    # Arguments:</span><br><span class="line">    #     X: data to be processed</span><br><span class="line">    #     train: &#39;True&#39; when processing training data, &#39;False&#39; for testing data</span><br><span class="line">    #     specific_column: indexes of the columns that will be normalized. If &#39;None&#39;, all columns</span><br><span class="line">    #         will be normalized.</span><br><span class="line">    #     X_mean: mean value of training data, used when train &#x3D; &#39;False&#39;</span><br><span class="line">    #     X_std: standard deviation of training data, used when train &#x3D; &#39;False&#39;</span><br><span class="line">    # Outputs:</span><br><span class="line">    #     X: normalized data</span><br><span class="line">    #     X_mean: computed mean value of training data</span><br><span class="line">    #     X_std: computed standard deviation of training data</span><br><span class="line"></span><br><span class="line">    if specified_column &#x3D;&#x3D; None:  # 如果等于None的话，意味着所有列都需要正规化</span><br><span class="line">        specified_column &#x3D; np.arange(X.shape[1])  # 新建一个数组，是0-X.shape[1]即0-509</span><br><span class="line">    if train:  # 如果train为True，那么表示处理training data，否则就处理testing data,即不再另算X_mean和X_std</span><br><span class="line">        X_mean &#x3D; np.mean(X[:, specified_column], 0).reshape(1, -1)  # 对X的所有行以及特定列的数组中求各列的平均值（因为axis的参数为0），然后重组为一行的数组</span><br><span class="line">        X_std &#x3D; np.std(X[:, specified_column], 0).reshape(1, -1)  # 同X_mean</span><br><span class="line"></span><br><span class="line">    X[:, specified_column] &#x3D; (X[:, specified_column] - X_mean) &#x2F; (X_std + 1e-8)  # X_std加入一个很小的数防止分母除以0</span><br><span class="line"></span><br><span class="line">    return X, X_mean, X_std</span><br></pre></td></tr></table></figure>
<p>接下来是将训练数据按比例拆成训练数据和验证数据。这样的好处上一次作业我有讲过，可以参考一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将训练集拆成训练集和验证集，默认值是0.25，可以调</span><br><span class="line">def _train_dev_split(X, Y, dev_ratio&#x3D;0.25):</span><br><span class="line">    # This function spilts data into training set and development set.</span><br><span class="line">    train_size &#x3D; int(len(X) * (1 - dev_ratio))</span><br><span class="line">    return X[:train_size], Y[:train_size], X[train_size:], Y[train_size:]</span><br></pre></td></tr></table></figure>

<p>函数定义完了，我们就使用函数进行处理即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Normalize training and testing data</span><br><span class="line">X_train, X_mean, X_std &#x3D; _normalize(X_train, train&#x3D;True)</span><br><span class="line">X_test, _, _ &#x3D; _normalize(X_test, train&#x3D;False, X_mean&#x3D;X_mean, X_std&#x3D;X_std)</span><br><span class="line"></span><br><span class="line"># Split data into training set and development set，按9:1进行拆分</span><br><span class="line">dev_ratio &#x3D; 0.1</span><br><span class="line">X_train, Y_train, X_dev, Y_dev &#x3D; _train_dev_split(X_train, Y_train, dev_ratio&#x3D;dev_ratio)</span><br><span class="line"></span><br><span class="line"># 用来看看拆开的数据，以及数据参数维度是否正确</span><br><span class="line">train_size &#x3D; X_train.shape[0]</span><br><span class="line">dev_size &#x3D; X_dev.shape[0]</span><br><span class="line">test_size &#x3D; X_test.shape[0]</span><br><span class="line">data_dim &#x3D; X_train.shape[1]</span><br><span class="line">print(&#39;Size of training set: &#123;&#125;&#39;.format(train_size))</span><br><span class="line">print(&#39;Size of development set: &#123;&#125;&#39;.format(dev_size))</span><br><span class="line">print(&#39;Size of testing set: &#123;&#125;&#39;.format(test_size))</span><br><span class="line">print(&#39;Dimension of data: &#123;&#125;&#39;.format(data_dim))</span><br></pre></td></tr></table></figure>
<p>下面定义的函数，训练中会用到，具体的用法看我写的注释即可，已经非常明白了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按顺序打乱X和Y，即打乱后，X[i]对应的仍是Y[i]</span><br><span class="line">def _shuffle(X, Y):</span><br><span class="line">    # This function shuffles two equal-length list&#x2F;array, X and Y, together.</span><br><span class="line">    randomize &#x3D; np.arange(len(X))  # 建立一个0-X的行-1的数组</span><br><span class="line">    np.random.shuffle(randomize)  # 生成大小为randomize的随机列表，</span><br><span class="line">    return (X[randomize], Y[randomize])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义sigmoid函数</span><br><span class="line">def _sigmoid(z):</span><br><span class="line">    # Sigmoid function can be used to calculate probability.</span><br><span class="line">    # To avoid overflow, minimum&#x2F;maximum output value is set.</span><br><span class="line">    # 为避免溢出，设置了最大最小值，即如果sigmoid函数的最小值比1e-8小，只会输出1e-8；而比1 - (1e-8)大，则只输出1 - (1e-8)</span><br><span class="line">    return np.clip(1 &#x2F; (1.0 + np.exp(-z)), 1e-8, 1 - (1e-8))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 逻辑回归的方程，输入是X，参数是w，bias是b，注意X与w都是数组，而b是一个数</span><br><span class="line"># 实际上这跟在X中新加一列全1作为b的相乘数的结果是一样的</span><br><span class="line">def _f(X, w, b):</span><br><span class="line">    # This is the logistic regression function, parameterized by w and b</span><br><span class="line">    #</span><br><span class="line">    # Arguements:</span><br><span class="line">    #     X: input data, shape &#x3D; [batch_size, data_dimension]</span><br><span class="line">    #     w: weight vector, shape &#x3D; [data_dimension, ]</span><br><span class="line">    #     b: bias, scalar</span><br><span class="line">    # Output:</span><br><span class="line">    #     predicted probability of each row of X being positively labeled, shape &#x3D; [batch_size, ]</span><br><span class="line">    # 在np.matmul(X, w)的基础上，数列中的每个值都加b得到最终的数列 matmul&#x3D;dot</span><br><span class="line">    return _sigmoid(np.matmul(X, w) + b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 将sigmoid中获得的值四舍五入转换成0或1(int型)，注意如果正好为0.5，(虽然几率很小)结果是0</span><br><span class="line"># 实际上</span><br><span class="line">def _predict(X, w, b):</span><br><span class="line">    # This function returns a truth value prediction for each row of X</span><br><span class="line">    # by rounding the result of logistic regression function.</span><br><span class="line">    return np.round(_f(X, w, b)).astype(np.int)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回模型正确率</span><br><span class="line">def _accuracy(Y_pred, Y_label):</span><br><span class="line">    # This function calculates prediction accuracy</span><br><span class="line">    acc &#x3D; 1 - np.mean(np.abs(</span><br><span class="line">        Y_pred - Y_label))  # np.abs(Y_pred - Y_label) 如果预测正确，则结果是0，否则结果是1，那么我们求mean平均值的话所得值是1的概率(mean相当于 1的个数&#x2F;总个数),那么我们求0的概率就是1-it。这比我的方法两个for循环快多了</span><br><span class="line">    return acc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 交叉熵</span><br><span class="line">def _cross_entropy_loss(y_pred, Y_label):</span><br><span class="line">    # This function computes the cross entropy.</span><br><span class="line">    #</span><br><span class="line">    # Arguements:</span><br><span class="line">    #     y_pred: probabilistic predictions, float vector，即还未放入_predict函数中的_f函数的结果</span><br><span class="line">    #     Y_label: ground truth labels, bool vector 真正的结果，只有0和1两个元素</span><br><span class="line">    # Output:</span><br><span class="line">    #     cross entropy, scalar 输出是交叉熵是一个数,具体公式与推导可看笔记或Logistic Regression ppt11页</span><br><span class="line">    cross_entropy &#x3D; -np.dot(Y_label, np.log(y_pred)) - np.dot((1 - Y_label), np.log(1 - y_pred))</span><br><span class="line">    return cross_entropy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回要调整的w参数的gradient与b参数的gradient，具体公式与推导请看笔记或Logistic Regression ppt11页</span><br><span class="line">def _gradient(X, Y_label, w, b):</span><br><span class="line">    # This function computes the gradient of cross entropy loss with respect to weight w and bias b.</span><br><span class="line">    y_pred &#x3D; _f(X, w, b)  # 预测值，是float类型而不是bool</span><br><span class="line">    pred_error &#x3D; Y_label - y_pred  # 真实值-预测值，即误差</span><br><span class="line">    w_grad &#x3D; -np.sum(pred_error * X.T, 1)  # X.T就是X的转置，axis取值为1时代表将每一行的元素相加，实际上返回的是1行510列的数组</span><br><span class="line">    b_grad &#x3D; -np.sum(pred_error)  # 对b求偏微分后的结果，黑板上没有，但因为逻辑回归和线性回归的损失函数相似，可由线性回归对b进行求偏微分得到</span><br><span class="line">    return w_grad, b_grad</span><br></pre></td></tr></table></figure>

<h1 id="Step4：训练模型"><a href="#Step4：训练模型" class="headerlink" title="Step4：训练模型"></a><strong>Step4：训练模型</strong></h1><p>这次我们训练的方法使用小批次循环训练。使用小批次进行训练时，当整个训练集的所有小批次都用过后，将所有训练集打散并重新分成很多小批次，继续进行一次，知道特定的次数结束为止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Zero initialization for weights ans bias</span><br><span class="line"># 使用0初始化w和b参数</span><br><span class="line">w &#x3D; np.zeros((data_dim,))</span><br><span class="line">b &#x3D; np.zeros((1,))</span><br><span class="line"></span><br><span class="line"># Some parameters for training</span><br><span class="line">max_iter &#x3D; 20  # 迭代次数</span><br><span class="line">batch_size &#x3D; 8  # 训练的批次中的数据个数</span><br><span class="line">learning_rate &#x3D; 0.05  # 学习率</span><br><span class="line"></span><br><span class="line"># Keep the loss and accuracy at every iteration for plotting</span><br><span class="line"># 将每次迭代的损失和正确率都保存，以方便画出来</span><br><span class="line">train_loss &#x3D; []  # 训练集损失</span><br><span class="line">dev_loss &#x3D; []  # 验证集损失</span><br><span class="line">train_acc &#x3D; []  # 训练集正确率</span><br><span class="line">dev_acc &#x3D; []  # 验证集正确率</span><br><span class="line"></span><br><span class="line"># Calcuate the number of parameter updates</span><br><span class="line"># 记录参数更新的次数</span><br><span class="line">step &#x3D; 1</span><br><span class="line"></span><br><span class="line"># Iterative training</span><br><span class="line">for epoch in range(max_iter):  # max_iter迭代次数</span><br><span class="line">    # Random shuffle at the begging of each epoch</span><br><span class="line">    # 随机的将训练集X和Y按顺序打乱</span><br><span class="line">    X_train, Y_train &#x3D; _shuffle(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">    # Mini-batch training</span><br><span class="line">    for idx in range(int(np.floor(train_size &#x2F; batch_size))):  # 每个批次8个数据，一共48830个数据，共48830&#x2F;8&#x3D;6103次批次</span><br><span class="line">        X &#x3D; X_train[idx * batch_size:(idx + 1) * batch_size]  # 分别取X和Y中的对应8个数据(每个批次8个数据)</span><br><span class="line">        Y &#x3D; Y_train[idx * batch_size:(idx + 1) * batch_size]</span><br><span class="line"></span><br><span class="line">        # Compute the gradient</span><br><span class="line">        # 计算w参数和b参数的梯度</span><br><span class="line">        w_grad, b_grad &#x3D; _gradient(X, Y, w, b)</span><br><span class="line"></span><br><span class="line">        # gradient descent update</span><br><span class="line">        # learning rate decay with time</span><br><span class="line">        # 更新参数，自适应学习率这次使用的是非常简单的学习率除以更新次数的根</span><br><span class="line">        w &#x3D; w - learning_rate &#x2F; np.sqrt(step) * w_grad</span><br><span class="line">        b &#x3D; b - learning_rate &#x2F; np.sqrt(step) * b_grad</span><br><span class="line"></span><br><span class="line">        step &#x3D; step + 1  # 更新次数+1</span><br><span class="line"></span><br><span class="line">    # Compute loss and accuracy of training set and development set</span><br><span class="line">    y_train_pred &#x3D; _f(X_train, w, b)  # 计算预测的值，注意此时数据格式为float</span><br><span class="line">    Y_train_pred &#x3D; np.round(y_train_pred)  # 将数据格式转换为bool类型</span><br><span class="line">    train_acc.append(_accuracy(Y_train_pred, Y_train))  # 将这一轮迭代的正确率记录下来</span><br><span class="line">    train_loss.append(_cross_entropy_loss(y_train_pred, Y_train) &#x2F; train_size)  # 将这一次迭代的损失记录下来</span><br><span class="line"></span><br><span class="line">    y_dev_pred &#x3D; _f(X_dev, w, b)  # 同样的方法处理验证集</span><br><span class="line">    Y_dev_pred &#x3D; np.round(y_dev_pred)</span><br><span class="line">    dev_acc.append(_accuracy(Y_dev_pred, Y_dev))</span><br><span class="line">    dev_loss.append(_cross_entropy_loss(y_dev_pred, Y_dev) &#x2F; dev_size)</span><br><span class="line"></span><br><span class="line">print(&#39;Training loss: &#123;&#125;&#39;.format(train_loss[-1]))  # 输出最后依次迭代的结果</span><br><span class="line">print(&#39;Development loss: &#123;&#125;&#39;.format(dev_loss[-1]))</span><br><span class="line">print(&#39;Training accuracy: &#123;&#125;&#39;.format(train_acc[-1]))</span><br><span class="line">print(&#39;Development accuracy: &#123;&#125;&#39;.format(dev_acc[-1]))</span><br><span class="line"></span><br><span class="line">np.save(&#39;weight_hw2.npy&#39;, w)  # 将参数保存下来</span><br></pre></td></tr></table></figure>

<p>我们可以选择将训练集与验证集的loss和accuracy画出来，这样更直观</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Loss curve</span><br><span class="line">plt.plot(train_loss)</span><br><span class="line">plt.plot(dev_loss)</span><br><span class="line">plt.title(&#39;Loss&#39;)</span><br><span class="line">plt.legend([&#39;train&#39;, &#39;dev&#39;])</span><br><span class="line">plt.savefig(&#39;loss.png&#39;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># Accuracy curve</span><br><span class="line">plt.plot(train_acc)</span><br><span class="line">plt.plot(dev_acc)</span><br><span class="line">plt.title(&#39;Accuracy&#39;)</span><br><span class="line">plt.legend([&#39;train&#39;, &#39;dev&#39;])</span><br><span class="line">plt.savefig(&#39;acc.png&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/3.png" class="" title="[李宏毅机器学习-第二课作业]">  
<img src="/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/4.png" class="" title="[李宏毅机器学习-第二课作业]">  

<h1 id="Step5：预测testdata得到预测结果"><a href="#Step5：预测testdata得到预测结果" class="headerlink" title="Step5：预测testdata得到预测结果"></a><strong>Step5：预测testdata得到预测结果</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w &#x3D; np.load(&#39;weight_hw2.npy&#39;)  # 加载参数</span><br><span class="line"></span><br><span class="line"># Predict testing labels</span><br><span class="line">predictions &#x3D; _predict(X_test, w, b)</span><br><span class="line">with open(output_fpath.format(&#39;logistic&#39;), &#39;w&#39;) as f:</span><br><span class="line">    f.write(&#39;id,label\n&#39;)</span><br><span class="line">    for i, label in enumerate(predictions):</span><br><span class="line">        f.write(&#39;&#123;&#125;,&#123;&#125;\n&#39;.format(i, label))</span><br><span class="line">        </span><br><span class="line"># Print out the most significant weights</span><br><span class="line"># 找到权重中最大的前十项，即关联结果的最紧密的参数</span><br><span class="line">ind &#x3D; np.argsort(np.abs(w))[::-1] #将数组从小到大排好后从最后往前取</span><br><span class="line">with open(X_test_fpath) as f:</span><br><span class="line">    content &#x3D; f.readline().strip(&#39;\n&#39;).split(&#39;,&#39;)</span><br><span class="line">features &#x3D; np.array(content)</span><br><span class="line">for i in ind[0:10]:</span><br><span class="line">    print(features[i], w[i])</span><br></pre></td></tr></table></figure>
<p>最后一步的意思是，找到影响最后结果最直接的参数是什么，这样看起来更直观一点。排序的规则就是看w参数的大小从大到小排序。</p>
<h1 id="Step6：generative-model的二元分类器"><a href="#Step6：generative-model的二元分类器" class="headerlink" title="Step6：generative model的二元分类器"></a><strong>Step6：generative model的二元分类器</strong></h1><p>老师上课共讲了两种方法，一种是逻辑回归，一种是generative model的二元分类器。只不过generative model的二元分类器的w和b是可以通过平均值和协方差直接求出来，而不需要梯度下降进行收敛获得。但最后结果generative model的二元分类器应该不会比逻辑回归更好，但这种方法我们也可以写下来，具体步骤和用到的Normalize函数和分类函数都一样，就不在赘述了，注释也写的很详细。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">数据预处理与正规化</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Parse csv files to numpy array</span><br><span class="line">with open(X_train_fpath) as f:</span><br><span class="line">    next(f)</span><br><span class="line">    X_train &#x3D; np.array([line.strip(&#39;\n&#39;).split(&#39;,&#39;)[1:] for line in f], dtype&#x3D;float)</span><br><span class="line">with open(Y_train_fpath) as f:</span><br><span class="line">    next(f)</span><br><span class="line">    Y_train &#x3D; np.array([line.strip(&#39;\n&#39;).split(&#39;,&#39;)[1] for line in f], dtype&#x3D;float)</span><br><span class="line">with open(X_test_fpath) as f:</span><br><span class="line">    next(f)</span><br><span class="line">    X_test &#x3D; np.array([line.strip(&#39;\n&#39;).split(&#39;,&#39;)[1:] for line in f], dtype&#x3D;float)</span><br><span class="line"></span><br><span class="line"># Normalize training and testing data</span><br><span class="line">X_train, X_mean, X_std &#x3D; _normalize(X_train, train&#x3D;True)</span><br><span class="line">X_test, _, _ &#x3D; _normalize(X_test, train&#x3D;False, specified_column&#x3D;None, X_mean&#x3D;X_mean, X_std&#x3D;X_std)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">我们需要分别计算两个类别内的数据平均值𝝁1，𝝁2与协方差矩阵𝜮1，𝜮2。Classfication ppt15页</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># Compute in-class mean</span><br><span class="line"># 分别将数据中的两个类别的数据分开，这样才可以计算两个类别的数据平均值𝝁1，𝝁2</span><br><span class="line">X_train_0 &#x3D; np.array([x for x, y in zip(X_train, Y_train) if y &#x3D;&#x3D; 0])  # 训练集中属于类别0的数据</span><br><span class="line">X_train_1 &#x3D; np.array([x for x, y in zip(X_train, Y_train) if y &#x3D;&#x3D; 1])  # 训练集中属于类别1的数据</span><br><span class="line"></span><br><span class="line">mean_0 &#x3D; np.mean(X_train_0, axis&#x3D;0)  # 𝝁1</span><br><span class="line">mean_1 &#x3D; np.mean(X_train_1, axis&#x3D;0)  # 𝝁2</span><br><span class="line"></span><br><span class="line"># Compute in-class covariance</span><br><span class="line"># 计算协方差矩阵𝜮1，𝜮2</span><br><span class="line"># 先用0初始化数组</span><br><span class="line">cov_0 &#x3D; np.zeros((data_dim, data_dim))  # 𝜮1</span><br><span class="line">cov_1 &#x3D; np.zeros((data_dim, data_dim))  # 𝜮2</span><br><span class="line"></span><br><span class="line"># 公式可看https:&#x2F;&#x2F;blog.csdn.net&#x2F;mr_hhh&#x2F;article&#x2F;details&#x2F;78490576</span><br><span class="line">for x in X_train_0:</span><br><span class="line">    cov_0 +&#x3D; np.dot(np.transpose([x - mean_0]), [x - mean_0]) &#x2F; X_train_0.shape[0]</span><br><span class="line">for x in X_train_1:</span><br><span class="line">    cov_1 +&#x3D; np.dot(np.transpose([x - mean_1]), [x - mean_1]) &#x2F; X_train_1.shape[0]</span><br><span class="line"></span><br><span class="line"># print(cov_0)</span><br><span class="line"># print(cov_1)</span><br><span class="line"></span><br><span class="line"># Shared covariance is taken as a weighted average of individual in-class covariance.</span><br><span class="line"># 为了减少参数的个数，采用同样的𝜮使其在两个类别上通用。  Classfication ppt22页，公式是23页</span><br><span class="line">cov &#x3D; (cov_0 * X_train_0.shape[0] + cov_1 * X_train_1.shape[0]) &#x2F; (X_train_0.shape[0] + X_train_1.shape[0])</span><br><span class="line"># print(cov)</span><br><span class="line"></span><br><span class="line"># 有了数据平均值和协方差矩阵，可以直接将唯一的权重矩阵与偏差向量计算出来 Classfication ppt33页</span><br><span class="line"># Compute inverse of covariance matrix.</span><br><span class="line"># Since covariance matrix may be nearly singular, np.linalg.inv() may give a large numerical error.</span><br><span class="line"># Via SVD decomposition, one can get matrix inverse efficiently and accurately.</span><br><span class="line"># 计算出协方差矩阵的逆，用inv表示</span><br><span class="line">u, s, v &#x3D; np.linalg.svd(cov, full_matrices&#x3D;False)</span><br><span class="line">inv &#x3D; np.matmul(v.T * 1 &#x2F; s, u.T)</span><br><span class="line">#</span><br><span class="line"># # Directly compute weights and bias  公式在33页</span><br><span class="line">w &#x3D; np.dot(inv, mean_0 - mean_1)</span><br><span class="line">b &#x3D; (-0.5) * np.dot(mean_0, np.dot(inv, mean_0)) + 0.5 * np.dot(mean_1, np.dot(inv, mean_1)) + np.log(float(X_train_0.shape[0]) &#x2F; X_train_1.shape[0])</span><br><span class="line"></span><br><span class="line">np.save(&#39;weight_hw2_generative.npy&#39;, w)  # 将参数保存下来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w &#x3D; np.load(&#39;weight_hw2_generative.npy&#39;)  # 加载参数</span><br><span class="line"># Compute accuracy on training set</span><br><span class="line">Y_train_pred &#x3D; 1 - _predict(X_train, w, b)</span><br><span class="line">print(&#39;Training accuracy: &#123;&#125;&#39;.format(_accuracy(Y_train_pred, Y_train))) #0.8735</span><br><span class="line"></span><br><span class="line"># Predict testing labels</span><br><span class="line">predictions &#x3D; 1 - _predict(X_test, w, b)</span><br><span class="line">with open(output_fpath.format(&#39;generative&#39;), &#39;w&#39;) as f:</span><br><span class="line">    f.write(&#39;id,label\n&#39;)</span><br><span class="line">    for i, label in enumerate(predictions):</span><br><span class="line">        f.write(&#39;&#123;&#125;,&#123;&#125;\n&#39;.format(i, label))</span><br><span class="line"></span><br><span class="line"># Print out the most significant weights</span><br><span class="line">ind &#x3D; np.argsort(np.abs(w))[::-1]</span><br><span class="line">with open(X_test_fpath) as f:</span><br><span class="line">    content &#x3D; f.readline().strip(&#39;\n&#39;).split(&#39;,&#39;)</span><br><span class="line">features &#x3D; np.array(content)</span><br><span class="line">for i in ind[0:10]:</span><br><span class="line">    print(features[i], w[i])</span><br></pre></td></tr></table></figure>

<h1 id="Step7：总结即优化"><a href="#Step7：总结即优化" class="headerlink" title="Step7：总结即优化"></a><strong>Step7：总结即优化</strong></h1><p>以上，我们就完成了作业2的所有内容。还是按道理可以继续优化，使用正则项，但这里我就没再写。<br>调参结果：对相同的批次(8)，相同的迭代次数(10)时，学习率0.05最好 0.8765 loss 0.2837<br>相同迭代次数10，学习率0.05，批次为10时，结果0.8759，loss0.2837<br>学习率0.05，批次为8时,迭代次数20 ，结果0.8789，loss0.2834<br>可以看出，最好的正确率大概是0.8789左右。本来想提交到kaggle上看看是否得分会提高，但不知为啥就算挂了梯子它也提交不上去，估计人太多了吧，下次再试试。<br>我自己第一遍写的代码以及最后获得的两个参数文件可以邮箱私聊找我获取。噶油！</p>
<img src="/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/5.png" class="" title="[李宏毅机器学习-第二课作业]">  
<p>在kaggle上的成绩又往前提高了hh，之前两个0.86是我自己写的得到的正确率，后来的0.88617是直接跑的老师的结果得到的，0.88972是调参之后的结果。</p>
<p>正则化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w &#x3D; w - learning_rate &#x2F; np.sqrt(step) * (w_grad + lamda * w)</span><br><span class="line">        b &#x3D; b - learning_rate &#x2F; np.sqrt(step) * b_grad</span><br></pre></td></tr></table></figure>
<p>这是对w进行了正则化处理，lamda是自己设定的正则项系数，我这里设置的是0.004，跑出了最好的成绩。  </p>
<img src="/2020/03/19/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%BD%9C%E4%B8%9A/6.png" class="" title="[李宏毅机器学习-第二课作业]"> ]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Logistic Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习-第一课作业</title>
    <url>/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>最近在看2020李宏毅老师的机器学习，发现真的是宝藏老师！讲的概念很容易让我们搞懂，而且数学理论方面也讲得很清晰。但是u1s1他的实验课第一个作业就难倒我了。因为我之前最多使用个paddlepaddle框架，可能实现个手写数字识别还挺简单，一些基本的步骤还是都会的，但是第一个线性回归的实验就有很多难点，一是数据集给你但你需要自己整理出有效数据，二是Normalize还有Gradient Desent需要自己实现，而我之前没有接触过python对矩阵进行操作，所以很多numpy的api都是先从网上去查，导致看的很慢，两天才算完全看完，现在把我这个作业的思路和反思好好写下来以作参考。</p>
<a id="more"></a>

<h1 id="Step1：明确目标"><a href="#Step1：明确目标" class="headerlink" title="Step1：明确目标"></a><strong>Step1：明确目标</strong></h1><img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/1.png" class="" title="[李宏毅机器学习-第一课作业]">  
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/2.png" class="" title="[李宏毅机器学习-第一课作业]">  
<p>讲道理看到这里我就有点蒙了，这可咋整，实际上我们慢慢来。<br>给我们的一共是两个：数据集和测试集。<br>大概的内容是数据集中记录了++12个月的前20天每天24个小时的18个数据++的资料，然后测试集就是剩余的数据中再取的。从上述我们可以得到以下结论：</p>
<ul>
<li><input disabled="" type="checkbox"> 模型的输入是前9个小时的所有观测数据，即9*18的参数值，</li>
<li><input disabled="" type="checkbox"> 模型输出是一个值表示预测的第10个小时的PM2.5含量。<br>所以最适合的模型是<strong>Regression model</strong>。</li>
</ul>
<h1 id="Step2：数据预处理"><a href="#Step2：数据预处理" class="headerlink" title="Step2：数据预处理"></a><strong>Step2：数据预处理</strong></h1><p>训练集是酱的：  </p>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/3.png" class="" title="[李宏毅机器学习-第一课作业]">  
<p>大概就是第一行是说明，分别是时间，地点，各空气中物质的名称，以及0-23时他们的浓度。<br>注意RAINFALL参数的值是NR，表示没有下雨，那么我们就可以将它的值改为0这样便于处理。<br>我们第一步肯定是数据预处理啦，因为在python中数据是通过矩阵来保存的，所以我们第一步就是删减掉不需要的行与列，然后将其保存到矩阵中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 引入必要的包</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">data &#x3D; pd.read_csv(&#39;.&#x2F;dataset&#x2F;train.csv&#39;, encoding&#x3D;&#39;big5&#39;) # 读取数据保存到data中，路径根据你保存的train.csv位置而有变化</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; data.iloc[:, 3:]  # 行保留所有，列从第三列开始往后才保留，这样去除了数据中的时间、地点、参数等信息</span><br><span class="line"># print(data)</span><br><span class="line">data[data &#x3D;&#x3D; &#39;NR&#39;] &#x3D; 0  # 将所有NR的值全部置为0方便之后处理</span><br><span class="line"># print(data)</span><br><span class="line">raw_data &#x3D; data.to_numpy()  # 将data的所有数据转换为二维数据并用raw_data来保存</span><br></pre></td></tr></table></figure>

<p>以上步骤做完，就已经将csv文件中的数据保存到矩阵中了。<br>然后李老师的下一个步骤是这样处理数据的：<br>将每一个月的数据放到一大行中(我这样说可能不好理解，我通俗点讲，因为每一天是一共有18行的，第一天是0-17行，第二天是18-35行以此类推。而我们需要的模型的输入并未在上面体现，所以我们要自己将其分离出来，怎么分离呢，因为我们需要前九个小时的所有参数值，从而得出第10个小时的PM2.5的值，那么我们将一个月的第一天到第二十天横向排序，那么我们可以使用滑动窗口的思想，取大小为9的窗口，从第一天的第0时一直可以划到第20天的第14时[为什么是14时，因为14+9=23，最后一个小时的PM2.5数据需要得到，所以这样处理可以最大化的利用已知训练集从而得到更多的数据])  </p>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/6.png" class="" title="[李宏毅机器学习-第一课作业]">  
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/7.png" class="" title="[李宏毅机器学习-第一课作业]">  
<p>所以我们使用下面的步骤来将每一个月的数据放到一个大行中  </p>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/4.png" class="" title="[李宏毅机器学习-第一课作业]">  
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/5.png" class="" title="[李宏毅机器学习-第一课作业]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">month_data &#x3D; &#123;&#125;</span><br><span class="line">for month in range(12):  # month 从0-11 共12个月</span><br><span class="line">    sample &#x3D; np.empty([18, 480])  # 返回一个18行480列的数组，用来保存一个月的数据（一个月只有20天，一天24个小时）</span><br><span class="line">    for day in range(20):  # day从0-19 共20天</span><br><span class="line">        sample[:, day * 24: (day + 1) * 24] &#x3D; raw_data[18 * (20 * month + day): 18 * (20 * month + day + 1),</span><br><span class="line">                                              :]  # raw的行每次取18行，列取全部列。送到sample中（sample是18行480列）行给全部行，列只给24列，然后列往后增加</span><br><span class="line">    month_data[month] &#x3D; sample</span><br></pre></td></tr></table></figure>
<p>这样每个月的数据就是18行480(24*20)列,一共12个月的数据<br>然后继续对我上述所说的进行提取数据：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.empty([12 * 471, 18 * 9],</span><br><span class="line">             dtype&#x3D;float)  # 一共480个小时，每9个小时一个数据（480列最后一列不可以计入，因为如果取到最后一行那么最后一个数据便没有了结果&#123;需要9个小时的输入和第10个小时的第10行作为结果&#125;），480-1-9+1&#x3D;471。471*12个数据集按行排列，每一行一个数据；数据是一个小时有18个特征，而每个数据9个小时，一共18*9列</span><br><span class="line">y &#x3D; np.empty([12 * 471, 1], dtype&#x3D;float)  # 结果是471*12个数据，每个数据对应一个结果，即第10小时的PM2.5浓度</span><br><span class="line">for month in range(12):  # month 0-11</span><br><span class="line">    for day in range(20):  # day 0-19</span><br><span class="line">        for hour in range(24):  # hour 0-23</span><br><span class="line">            if day &#x3D;&#x3D; 19 and hour &gt; 14:  # 取到raw_data中的最后一块行为18，列为9的块之后，就不可以再取了，再取就会超过界限了，具体看下图</span><br><span class="line">                continue</span><br><span class="line">            x[month * 471 + day * 24 + hour, :] &#x3D; month_data[month][:, day * 24 + hour: day * 24 + hour + 9].reshape(1,</span><br><span class="line">                                                                                                                     # 取对应month：行都要取，列取9个，依次进行，最后将整个数据reshape成一行数据(列数无所谓)。然后赋给x，x内的坐标只是为了保证其从0-471*12</span><br><span class="line">                                                                                                                     -1)  # vector dim:18*9 (9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9)</span><br><span class="line">            y[month * 471 + day * 24 + hour, 0] &#x3D; month_data[month][</span><br><span class="line">                9, day * 24 + hour + 9]  # value,结果对应的行数一直是第9列（即第10行PM2.5）然后列数随着取得数据依次往后进行</span><br></pre></td></tr></table></figure>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/8.png" class="" title="[李宏毅机器学习-第一课作业]">  
<p>上述所有工作做完之后，X就是包含所有数据的数组，Y就是所有数据的结果，但此时还不可以进行训练，还需要两个步骤才可以。</p>
<h1 id="Step3：Normalize与训练集分类"><a href="#Step3：Normalize与训练集分类" class="headerlink" title="Step3：Normalize与训练集分类"></a><strong>Step3：Normalize与训练集分类</strong></h1><p>Normalize的方法我们选用最常用的标准差标准化方法这是说明：</p>
<blockquote>
<p>数据的标准化（normalization）是将数据按比例缩放，使之落入一个小的特定区间。<br>在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，<br>便于不同单位或量级的指标能够进行比较和加权。<br>最常见的标准化方法就是Z标准化，也是SPSS中最为常用的标准化方法，spss默认的标准化方法就是z-score标准化。<br>也叫标准差标准化，这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。<br>经过处理的数据符合标准正态分布，即均值为0，标准差为1，注意，一般来说z-score不是归一化，而是标准化，归一化只是标准化的一种[lz]。<br>其转化函数为：<br>x* = (x - μ ) / σ<br>其中μ为所有样本数据的均值，σ为所有样本数据的标准差。<br>具体可看这个<a href="https://www.cnblogs.com/chenyusheng0803/p/9867579.html">https://www.cnblogs.com/chenyusheng0803/p/9867579.html</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mean_x &#x3D; np.mean(x, axis&#x3D;0)  # 18 * 9 求均值，axis &#x3D; 0表示对各列求均值，返回 1* 列数 的矩阵</span><br><span class="line">std_x &#x3D; np.std(x, axis&#x3D;0)  # 18 * 9 求标准差，axis &#x3D; 0表示对各列求均值，返回 1* 列数 的矩阵</span><br><span class="line">for i in range(len(x)):  # 12 * 471</span><br><span class="line">    for j in range(len(x[0])):  # 18 * 9</span><br><span class="line">        if std_x[j] !&#x3D; 0:</span><br><span class="line">            x[i][j] &#x3D; (x[i][j] - mean_x[j]) &#x2F; std_x[j]</span><br></pre></td></tr></table></figure>
<p>接下来是将训练数据按8:2拆成训练数据和验证数据。这样的好处是因为最终只给我们test data的输入而没有给我们输出，所以我们无法定量我们模型的好坏，而使用验证数据可以简单验证我们模型的好坏，让我们自己心里有数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将训练数据拆成训练数据：验证数据&#x3D;8:2，这样用来验证</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">x_train_set &#x3D; x[: math.floor(len(x) * 0.8), :]</span><br><span class="line">y_train_set &#x3D; y[: math.floor(len(y) * 0.8), :]</span><br><span class="line">x_validation &#x3D; x[math.floor(len(x) * 0.8):, :]</span><br><span class="line">y_validation &#x3D; y[math.floor(len(y) * 0.8):, :]</span><br><span class="line">print(x_train_set)</span><br><span class="line">print(y_train_set)</span><br><span class="line">print(x_validation)</span><br><span class="line">print(y_validation)</span><br><span class="line">print(len(x_train_set))</span><br><span class="line">print(len(y_train_set))</span><br><span class="line">print(len(x_validation))</span><br><span class="line">print(len(y_validation))</span><br></pre></td></tr></table></figure>

<h1 id="Step4：训练模型"><a href="#Step4：训练模型" class="headerlink" title="Step4：训练模型"></a><strong>Step4：训练模型</strong></h1><p>终于到了最关键的一步，也是最困难的一步，决定我们模型好坏的就是训练的成果，首先明确，我们训练使用的Loss function和梯度下降算法。<br>直接看注释即可，已经写得很清楚了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dim &#x3D; 18 * 9 + 1  # 用来做参数vector的维数，加1是为了对bias好处理（还有个误差项）。即最后的h(x)&#x3D;w1x1+w2x2+&#39;&#39;&#39;+WnXn+b</span><br><span class="line">w &#x3D; np.ones([dim, 1])  # 生成一个dim行1列的数组用来保存参数值，对比源码我这里改成了ones而不是zeros</span><br><span class="line">x &#x3D; np.concatenate((np.ones([12 * 471, 1]), x), axis&#x3D;1).astype(</span><br><span class="line">    float)  # np.ones来生成12*471行1列的全1数组，np.concatenate，axis&#x3D;1表示按列将两个数组拼接起来，即在x最前面新加一列内容，之前x是12*471行18*9列的数组，新加一列之后变为12*471行18*9+1列的数组</span><br><span class="line">learning_rate &#x3D; 100  # 学习率</span><br><span class="line">iter_time &#x3D; 10000  # 迭代次数</span><br><span class="line">adagrad &#x3D; np.zeros([dim, 1])  # 生成dim行即163行1列的数组，用来使用adagrad算法更新学习率</span><br><span class="line">eps &#x3D; 0.0000000001  # 因为新的学习率是learning_rate&#x2F;sqrt(sum_of_pre_grads**2),而adagrad&#x3D;sum_of_grads**2,所以处在分母上而迭代时adagrad可能为0，所以加上一个极小数，使其不除0</span><br><span class="line">for t in range(iter_time):</span><br><span class="line">    loss &#x3D; np.sqrt(np.sum(np.power(np.dot(x, w) - y,</span><br><span class="line">                                   2)) &#x2F; 471 &#x2F; 12)  # rmse loss函数是从0-n的(X*W-Y)**2之和&#x2F;(471*12)再开根号，即使用均方根误差(root mean square error),具体可百度其公式，&#x2F;471&#x2F;12即&#x2F;N(次数)</span><br><span class="line">    if (t % 100 &#x3D;&#x3D; 0):  # 每一百次迭代就输出其损失</span><br><span class="line">        print(str(t) + &quot;:&quot; + str(loss))</span><br><span class="line">    gradient &#x3D; 2 * np.dot(x.transpose(), np.dot(x,</span><br><span class="line">                                                w) - y)  # dim*1 x.transpose即x的转置，后面是X*W-Y,即2*(x的转置*(X*W-Y))是梯度，具体可由h(x)求偏微分获得.最后生成1行18*9+1列的数组。转置后的X，其每一行是一个参数，与h(x)-y的值相乘之后是参数W0的修正值，同理可得W0-Wn的修正值保存到1行18*9+1列的数组中，即gradient</span><br><span class="line">    adagrad +&#x3D; gradient ** 2  # adagrad用于保存前面使用到的所有gradient的平方，进而在更新时用于调整学习率</span><br><span class="line">    w &#x3D; w - learning_rate * gradient &#x2F; np.sqrt(adagrad + eps)  # 更新权重</span><br><span class="line">np.save(&#39;weight.npy&#39;, w)  # 将参数保存下来</span><br></pre></td></tr></table></figure>
<p>注意的是，loss function我们选择的是Root Mean Square Error，即下图所示的公式：  </p>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/9.png" class="" title="[李宏毅机器学习-第一课作业]">  
<p>至于学习率，最简单的办法就是固定学习率，每次迭代的学习率都相同，但这样效果也会很差，良好的学习率应随迭代次数依次减少，所以我们使用自适应学习率的adagrad算法，即每次学习率都等于其除以之前所有的梯度平方和再开根号，即下图所示的公式:  </p>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/10.png" class="" title="[李宏毅机器学习-第一课作业]">  
<p>gradient就没什么好说的了，就是一个对Loss函数进行每个参数的偏微分而得到的矩阵。</p>
<h1 id="Step5：载入验证集进行验证"><a href="#Step5：载入验证集进行验证" class="headerlink" title="Step5：载入验证集进行验证"></a><strong>Step5：载入验证集进行验证</strong></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w &#x3D; np.load(&#39;weight.npy&#39;)</span><br><span class="line"># 使用x_validation和y_validation来计算模型的准确率，因为X已经normalize了，所以不需要再来一遍，只需在x_validation上添加新的一列作为bias的乘数即可</span><br><span class="line">x_validation &#x3D; np.concatenate((np.ones([1131, 1]), x_validation), axis&#x3D;1).astype(float)</span><br><span class="line">ans_y &#x3D; np.dot(x_validation, w)</span><br><span class="line">loss &#x3D; np.sqrt(np.sum(np.power(ans_y - y_validation, 2)) &#x2F; 1131)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure>
<p>细心的你肯定注意到了，我在第四步进行训练使用的训练集是整个X，而没使用我分开好的x_train_set,这是因为使用了整个X训练之后就直接可以预测testdata中的值并输出了，而使用x_train_set进行训练再使用x_validation和y_validation进行验证是为了预估模型的好坏。但我还是使用了两种训练集分别进行训练，并都用x_validation和y_validation进行验证，结果如下：  </p>
<ul>
<li><input disabled="" type="checkbox"> 使用全部X进行训练，并通过x_validation和y_validation进行验证，结果是<br>训练集中最后一次迭代的loss为5.68   测试集中loss为5.42</li>
</ul>
<p>++但上述情况是因为x_validation本身包括在训练集中，所以loss比下面方法更低在意料之中++</p>
<ul>
<li><input disabled="" type="checkbox"> 使用x_train_set进行训练，并通过x_validation和y_validation进行验证，结果是<br>训练集中最后一次迭代的loss为5.72   测试集中loss为5.66</li>
</ul>
<p>这样看来，我们的模型还算可以，所以就可以进行最后一步预测test data了<br>还需要补充的是，loss function一定和训练的loss function一致才可以通过比较它俩loss大小来评估模型好坏。然后就是如果使用x_validation进行训练时，将训练步骤的X全部换成x_validation，并且在”/471/12”的时候除的是x_validation的大小，即471<em>12</em>0.8</p>
<h1 id="Step6：预测testdata得到预测结果"><a href="#Step6：预测testdata得到预测结果" class="headerlink" title="Step6：预测testdata得到预测结果"></a><strong>Step6：预测testdata得到预测结果</strong></h1><p>因为之前对数据预处理、Normalize等等步骤我们已经做过了，所以我便不再赘述，直接看代码的注释即可，应该是非常详细了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">testdata &#x3D; pd.read_csv(&#39;.&#x2F;dataset&#x2F;test.csv&#39;, header&#x3D;None, encoding&#x3D;&#39;big5&#39;)</span><br><span class="line">test_data &#x3D; testdata.iloc[:, 2:]  # 取csv文件中的全行数即第3列到结束的列数所包含的数据</span><br><span class="line">test_data[test_data &#x3D;&#x3D; &#39;NR&#39;] &#x3D; 0  # 将testdata中的NR替换为0</span><br><span class="line">test_data &#x3D; test_data.to_numpy()  # 将其转换为数组</span><br><span class="line">test_x &#x3D; np.empty([240, 18 * 9], dtype&#x3D;float)  # 创建一个240行18*9列的空数列用于保存textdata的输入</span><br><span class="line">for i in range(240):  # 共240个测试输入数据</span><br><span class="line">    test_x[i, :] &#x3D; test_data[18 * i: 18 * (i + 1), :].reshape(1, -1)</span><br><span class="line"># 下面是Normalize,且必须跟training data是同一种方法进行Normalize</span><br><span class="line">for i in range(len(test_x)):</span><br><span class="line">    for j in range(len(test_x[0])):</span><br><span class="line">        if std_x[j] !&#x3D; 0:</span><br><span class="line">            test_x[i][j] &#x3D; (test_x[i][j] - mean_x[j]) &#x2F; std_x[j]</span><br><span class="line">test_x &#x3D; np.concatenate((np.ones([240, 1]), test_x), axis&#x3D;1).astype(float)  # 在test_x前面拼接一列全1数组，构成240行，163列数据</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进行预测 </span><br><span class="line">w &#x3D; np.load(&#39;weight.npy&#39;)</span><br><span class="line">ans_y &#x3D; np.dot(test_x, w)  # test data的预测值ans_y&#x3D;test_x与W的积</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将预测结果填入文件当中</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">with open(&#39;submit.csv&#39;, mode&#x3D;&#39;w&#39;, newline&#x3D;&#39;&#39;) as submit_file:</span><br><span class="line">    csv_writer &#x3D; csv.writer(submit_file)</span><br><span class="line">    header &#x3D; [&#39;id&#39;, &#39;value&#39;]</span><br><span class="line">    print(header)</span><br><span class="line">    csv_writer.writerow(header)</span><br><span class="line">    for i in range(240):</span><br><span class="line">        row &#x3D; [&#39;id_&#39; + str(i), ans_y[i][0]]</span><br><span class="line">        csv_writer.writerow(row)</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure>
<img src="/2020/03/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%BD%9C%E4%B8%9A/11.png" class="" title="[李宏毅机器学习-第一课作业]">  
<h1 id="Step7：总结即优化"><a href="#Step7：总结即优化" class="headerlink" title="Step7：总结即优化"></a><strong>Step7：总结即优化</strong></h1><p>以上，我们就完成了作业1的所有内容。实际上，可不可以使我们的模型更好些？答案是肯定的，我们在loss function中可以加入正则项，这样肯定会使模型的准确度更好些，但这里不再继续写了。<br>写到这里我的心情是非常激动的，这是第一个我自己根据老师的指导，完完全全弄懂完成的第一个实验，确实给了我很多启发与理解，只能说老师水平很高吧。果然好大学的实验课才是精华，课程只是锦上添花哇。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>DL-手写数字识别</title>
    <url>/2020/03/09/DL-%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>本实践使用多层感知器训练（DNN）模型，用于预测手写数字图片。</p>
<p><img src="https://ai-studio-static-online.cdn.bcebos.com/ba26eac845334208851e72c7a2dfef5e1eec566894ba430aba7492e72c49cacd" alt=""></p>
<a id="more"></a>

<p> 实践总体过程和步骤如下图</p>
<p><img src="https://ai-studio-static-online.cdn.bcebos.com/daa656fb63c54dec8e0e468ba8f65e1c94ccd7debd314d8ca6d179f12f13883d" alt=""></p>
<p>首先导入必要的包</p>
<p>numpy———-&gt;python第三方库，用于进行科学计算</p>
<p>PIL————&gt; Python Image Library,python第三方图像处理库</p>
<p>matplotlib—–&gt;python的绘图库 pyplot:matplotlib的绘图框架</p>
<p>os————-&gt;提供了丰富的方法来处理文件和目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入需要的包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> paddle <span class="keyword">as</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<h1 id="Step1：准备数据。"><a href="#Step1：准备数据。" class="headerlink" title="Step1：准备数据。"></a><strong>Step1：准备数据。</strong></h1><p>(1)数据集介绍</p>
<p>MNIST数据集包含60000个训练集和10000测试数据集。分为图片和标签，图片是28*28的像素矩阵，标签为0~9共10个数字。</p>
<p><img src="https://ai-studio-static-online.cdn.bcebos.com/fc73217ae57f451a89badc801a903bb742e42eabd9434ecc8089efe19a66c076" alt=""></p>
<p>(2)train_reader和test_reader</p>
<p>paddle.dataset.mnist.train()和test()分别用于获取mnist训练集和测试集</p>
<p>paddle.reader.shuffle()表示每次缓存BUF_SIZE个数据项，并进行打乱</p>
<p>paddle.batch()表示每BATCH_SIZE组成一个batch</p>
<p>（3）打印看下数据是什么样的？PaddlePaddle接口提供的数据已经经过了归一化、居中等处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUF_SIZE=<span class="number">512</span></span><br><span class="line">BATCH_SIZE=<span class="number">128</span></span><br><span class="line"><span class="comment">#用于训练的数据提供器，每次从缓存中随机读取批次大小的数据</span></span><br><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(paddle.dataset.mnist.train(),</span><br><span class="line">                          buf_size=BUF_SIZE),</span><br><span class="line">    batch_size=BATCH_SIZE)</span><br><span class="line"><span class="comment">#用于训练的数据提供器，每次从缓存中随机读取批次大小的数据</span></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(paddle.dataset.mnist.test(),</span><br><span class="line">                          buf_size=BUF_SIZE),</span><br><span class="line">    batch_size=BATCH_SIZE)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#用于打印，查看mnist数据</span></span><br><span class="line">train_data=paddle.dataset.mnist.train();</span><br><span class="line">sampledata=next(train_data())</span><br><span class="line">print(sampledata)</span><br></pre></td></tr></table></figure>

<pre><code>[==================================================]t/train-images-idx3-ubyte.gz not found, downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz
[==================================================]t/train-labels-idx1-ubyte.gz not found, downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz
[==================================================]t/t10k-images-idx3-ubyte.gz not found, downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz
[==================================================]t/t10k-labels-idx1-ubyte.gz not found, downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz




(array([-1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -0.9764706 , -0.85882354, -0.85882354,
       -0.85882354, -0.01176471,  0.06666672,  0.37254906, -0.79607844,
        0.30196083,  1.        ,  0.9372549 , -0.00392157, -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -0.7647059 , -0.7176471 , -0.26274508,  0.20784318,
        0.33333337,  0.9843137 ,  0.9843137 ,  0.9843137 ,  0.9843137 ,
        0.9843137 ,  0.7647059 ,  0.34901965,  0.9843137 ,  0.8980392 ,
        0.5294118 , -0.4980392 , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -0.6156863 ,  0.8666667 ,
        0.9843137 ,  0.9843137 ,  0.9843137 ,  0.9843137 ,  0.9843137 ,
        0.9843137 ,  0.9843137 ,  0.9843137 ,  0.96862745, -0.27058822,
       -0.35686272, -0.35686272, -0.56078434, -0.69411767, -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -0.85882354,  0.7176471 ,  0.9843137 ,  0.9843137 ,
        0.9843137 ,  0.9843137 ,  0.9843137 ,  0.5529412 ,  0.427451  ,
        0.9372549 ,  0.8901961 , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -0.372549  ,  0.22352946, -0.1607843 ,  0.9843137 ,  0.9843137 ,
        0.60784316, -0.9137255 , -1.        , -0.6627451 ,  0.20784318,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -0.8901961 ,
       -0.99215686,  0.20784318,  0.9843137 , -0.29411763, -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        ,  0.09019613,
        0.9843137 ,  0.4901961 , -0.9843137 , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -0.9137255 ,  0.4901961 ,  0.9843137 ,
       -0.45098037, -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -0.7254902 ,  0.8901961 ,  0.7647059 ,  0.254902  ,
       -0.15294117, -0.99215686, -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -0.36470586,  0.88235295,  0.9843137 ,  0.9843137 , -0.06666666,
       -0.8039216 , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -0.64705884,
        0.45882356,  0.9843137 ,  0.9843137 ,  0.17647064, -0.7882353 ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -0.8745098 , -0.27058822,
        0.9764706 ,  0.9843137 ,  0.4666667 , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        ,  0.9529412 ,  0.9843137 ,
        0.9529412 , -0.4980392 , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -0.6392157 ,  0.0196079 ,
        0.43529415,  0.9843137 ,  0.9843137 ,  0.62352943, -0.9843137 ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -0.69411767,
        0.16078436,  0.79607844,  0.9843137 ,  0.9843137 ,  0.9843137 ,
        0.9607843 ,  0.427451  , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -0.8117647 , -0.10588235,  0.73333335,  0.9843137 ,  0.9843137 ,
        0.9843137 ,  0.9843137 ,  0.5764706 , -0.38823527, -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -0.81960785, -0.4823529 ,  0.67058825,  0.9843137 ,
        0.9843137 ,  0.9843137 ,  0.9843137 ,  0.5529412 , -0.36470586,
       -0.9843137 , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -0.85882354,  0.3411765 ,  0.7176471 ,
        0.9843137 ,  0.9843137 ,  0.9843137 ,  0.9843137 ,  0.5294118 ,
       -0.372549  , -0.92941177, -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -0.5686275 ,  0.34901965,
        0.77254903,  0.9843137 ,  0.9843137 ,  0.9843137 ,  0.9843137 ,
        0.9137255 ,  0.04313731, -0.9137255 , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        ,  0.06666672,  0.9843137 ,  0.9843137 ,  0.9843137 ,
        0.6627451 ,  0.05882359,  0.03529418, -0.8745098 , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        , -1.        ,
       -1.        , -1.        , -1.        , -1.        ], dtype=float32), 5)</code></pre><h1 id="Step2-网络配置"><a href="#Step2-网络配置" class="headerlink" title="Step2.网络配置"></a><strong>Step2.网络配置</strong></h1><p>以下的代码判断就是定义一个简单的多层感知器，一共有三层，两个大小为100的隐层和一个大小为10的输出层，因为MNIST数据集是手写0到9的灰度图像，类别有10个，所以最后的输出大小是10。最后输出层的激活函数是Softmax，所以最后的输出层相当于一个分类器。加上一个输入层的话，多层感知器的结构是：输入层–&gt;&gt;隐层–&gt;&gt;隐层–&gt;&gt;输出层。</p>
<p><img src="https://ai-studio-static-online.cdn.bcebos.com/cb69f928778c4299b75814179607a89eea770bdc409d4e08a87e2975cb96b19b" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义多层感知器 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multilayer_perceptron</span><span class="params">(input)</span>:</span> </span><br><span class="line">    <span class="comment"># 第一个全连接层，激活函数为ReLU </span></span><br><span class="line">    hidden1 = fluid.layers.fc(input=input, size=<span class="number">100</span>, act=<span class="string">'relu'</span>) </span><br><span class="line">    <span class="comment"># 第二个全连接层，激活函数为ReLU </span></span><br><span class="line">    hidden2 = fluid.layers.fc(input=hidden1, size=<span class="number">100</span>, act=<span class="string">'relu'</span>) </span><br><span class="line">    <span class="comment"># 以softmax为激活函数的全连接输出层，输出层的大小必须为数字的个数10 </span></span><br><span class="line">    prediction = fluid.layers.fc(input=hidden2, size=<span class="number">10</span>, act=<span class="string">'softmax'</span>) </span><br><span class="line">    <span class="keyword">return</span> prediction</span><br></pre></td></tr></table></figure>

<p>（2）定义数据层</p>
<p>输入的是图像数据。图像是 28 * 28 的灰度图，所以输入的形状是[1, 28, 28]，如果图像是32*32的彩色图，那么输入的形状是[3. 32, 32]，因为灰度图只有一个通道，而彩色图有RGB三个通道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入的原始图像数据，大小为1*28*28</span></span><br><span class="line">image = fluid.layers.data(name=<span class="string">'image'</span>, shape=[<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>], dtype=<span class="string">'float32'</span>)<span class="comment">#单通道，28*28像素值</span></span><br><span class="line"><span class="comment"># 标签，名称为label,对应输入图片的类别标签</span></span><br><span class="line">label = fluid.layers.data(name=<span class="string">'label'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)          <span class="comment">#图片标签</span></span><br></pre></td></tr></table></figure>

<p>（3）获取分类器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取分类器</span></span><br><span class="line">predict = multilayer_perceptron(image)</span><br></pre></td></tr></table></figure>

<p>（4）定义损失函数和准确率</p>
<p>这次使用的是交叉熵损失函数，该函数在分类任务上比较常用。</p>
<p>定义了一个损失函数之后，还有对它求平均值，训练程序必须返回平均损失作为第一个返回值，因为它会被后面反向传播算法所用到。。</p>
<p>同时我们还可以定义一个准确率函数，这个可以在我们训练的时候输出分类的准确率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用交叉熵损失函数,描述真实样本标签和预测概率之间的差值</span></span><br><span class="line">cost = fluid.layers.cross_entropy(input=predict, label=label)  </span><br><span class="line"><span class="comment"># 使用类交叉熵函数计算predict和label之间的损失函数</span></span><br><span class="line">avg_cost = fluid.layers.mean(cost)</span><br><span class="line"><span class="comment"># 计算分类准确率</span></span><br><span class="line">acc = fluid.layers.accuracy(input=predict, label=label)</span><br></pre></td></tr></table></figure>

<p>（5）定义优化函数</p>
<p>这次我们使用的是Adam优化方法，同时指定学习率为0.001</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#使用Adam算法进行优化, learning_rate 是学习率(它的大小与网络的训练收敛速度有关系)</span></span><br><span class="line">optimizer = fluid.optimizer.AdamOptimizer(learning_rate=<span class="number">0.001</span>)  </span><br><span class="line">opts = optimizer.minimize(avg_cost)</span><br></pre></td></tr></table></figure>

<p>在上述模型配置完毕后，得到两个fluid.Program：fluid.default_startup_program() 与fluid.default_main_program() 配置完毕了。</p>
<p>参数初始化操作会被写入fluid.default_startup_program()</p>
<p>fluid.default_main_program()用于获取默认或全局main program(主程序)。该主程序用于训练和测试模型。fluid.layers 中的所有layer函数可以向 default_main_program 中添加算子和变量。default_main_program 是fluid的许多编程接口（API）的Program参数的缺省值。例如,当用户program没有传入的时候， Executor.run() 会默认执行 default_main_program 。</p>
<h1 id="Step3-模型训练-and-Step4-模型评估"><a href="#Step3-模型训练-and-Step4-模型评估" class="headerlink" title="Step3.模型训练 and Step4.模型评估"></a><strong>Step3.模型训练 and Step4.模型评估</strong></h1><p>（1）创建训练的Executor</p>
<p>首先定义运算场所 fluid.CPUPlace()和 fluid.CUDAPlace(0)分别表示运算场所为CPU和GPU</p>
<p>Executor:接收传入的program，通过run()方法运行program。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义使用CPU还是GPU，使用CPU时use_cuda = False,使用GPU时use_cuda = True</span></span><br><span class="line">use_cuda = <span class="literal">False</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line"><span class="comment"># 获取测试程序</span></span><br><span class="line">test_program = fluid.default_main_program().clone(for_test=<span class="literal">True</span>)</span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line">exe.run(fluid.default_startup_program())</span><br></pre></td></tr></table></figure>

<p>（2）告知网络传入的数据分为两部分，第一部分是image值，第二部分是label值</p>
<p>DataFeeder负责将数据提供器（train_reader,test_reader）返回的数据转成一种特殊的数据结构，使其可以输入到Executor中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">feeder = fluid.DataFeeder(place=place, feed_list=[image, label])</span><br></pre></td></tr></table></figure>

<p>(3)展示模型训练曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_train_iter=<span class="number">0</span></span><br><span class="line">all_train_iters=[]</span><br><span class="line">all_train_costs=[]</span><br><span class="line">all_train_accs=[]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_train_process</span><span class="params">(title,iters,costs,accs,label_cost,lable_acc)</span>:</span></span><br><span class="line">    plt.title(title, fontsize=<span class="number">24</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"iter"</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"cost/acc"</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">    plt.plot(iters, costs,color=<span class="string">'red'</span>,label=label_cost) </span><br><span class="line">    plt.plot(iters, accs,color=<span class="string">'green'</span>,label=lable_acc) </span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>（4）训练并保存模型</p>
<p>训练需要有一个训练程序和一些必要参数，并构建了一个获取训练过程中测试误差的函数。必要参数有executor,program,reader,feeder,fetch_list。</p>
<p><strong>executor</strong>表示之前创建的执行器</p>
<p><strong>program</strong>表示执行器所执行的program，是之前创建的program，如果该项参数没有给定的话则默认使用defalut_main_program</p>
<p><strong>reader</strong>表示读取到的数据</p>
<p><strong>feeder</strong>表示前向输入的变量</p>
<p><strong>fetch_list</strong>表示用户想得到的变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCH_NUM=<span class="number">2</span></span><br><span class="line">model_save_dir = <span class="string">"/home/aistudio/work/hand.inference.model"</span></span><br><span class="line"><span class="keyword">for</span> pass_id <span class="keyword">in</span> range(EPOCH_NUM):</span><br><span class="line">    <span class="comment"># 进行训练</span></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(train_reader()):                         <span class="comment">#遍历train_reader</span></span><br><span class="line">        train_cost, train_acc = exe.run(program=fluid.default_main_program(),<span class="comment">#运行主程序</span></span><br><span class="line">                                        feed=feeder.feed(data),              <span class="comment">#给模型喂入数据</span></span><br><span class="line">                                        fetch_list=[avg_cost, acc])          <span class="comment">#fetch 误差、准确率  </span></span><br><span class="line">        </span><br><span class="line">        all_train_iter=all_train_iter+BATCH_SIZE</span><br><span class="line">        all_train_iters.append(all_train_iter)</span><br><span class="line">        </span><br><span class="line">        all_train_costs.append(train_cost[<span class="number">0</span>])</span><br><span class="line">        all_train_accs.append(train_acc[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每200个batch打印一次信息  误差、准确率</span></span><br><span class="line">        <span class="keyword">if</span> batch_id % <span class="number">200</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Pass:%d, Batch:%d, Cost:%0.5f, Accuracy:%0.5f'</span> %</span><br><span class="line">                  (pass_id, batch_id, train_cost[<span class="number">0</span>], train_acc[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行测试</span></span><br><span class="line">    test_accs = []</span><br><span class="line">    test_costs = []</span><br><span class="line">    <span class="comment">#每训练一轮 进行一次测试</span></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(test_reader()):                         <span class="comment">#遍历test_reader</span></span><br><span class="line">        test_cost, test_acc = exe.run(program=test_program, <span class="comment">#执行训练程序</span></span><br><span class="line">                                      feed=feeder.feed(data),               <span class="comment">#喂入数据</span></span><br><span class="line">                                      fetch_list=[avg_cost, acc])           <span class="comment">#fetch 误差、准确率</span></span><br><span class="line">        test_accs.append(test_acc[<span class="number">0</span>])                                       <span class="comment">#每个batch的准确率</span></span><br><span class="line">        test_costs.append(test_cost[<span class="number">0</span>])                                     <span class="comment">#每个batch的误差</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    <span class="comment"># 求测试结果的平均值</span></span><br><span class="line">    test_cost = (sum(test_costs) / len(test_costs))                         <span class="comment">#每轮的平均误差</span></span><br><span class="line">    test_acc = (sum(test_accs) / len(test_accs))                            <span class="comment">#每轮的平均准确率</span></span><br><span class="line">    print(<span class="string">'Test:%d, Cost:%0.5f, Accuracy:%0.5f'</span> % (pass_id, test_cost, test_acc))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#保存模型</span></span><br><span class="line">    <span class="comment"># 如果保存路径不存在就创建</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_save_dir):</span><br><span class="line">    os.makedirs(model_save_dir)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'save models to %s'</span> % (model_save_dir))</span><br><span class="line">fluid.io.save_inference_model(model_save_dir,   <span class="comment">#保存推理model的路径</span></span><br><span class="line">                                  [<span class="string">'image'</span>],    <span class="comment">#推理（inference）需要 feed 的数据</span></span><br><span class="line">                                  [predict],    <span class="comment">#保存推理（inference）结果的 Variables</span></span><br><span class="line">                                  exe)             <span class="comment">#executor 保存 inference model</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'训练模型保存完成！'</span>)</span><br><span class="line">draw_train_process(<span class="string">"training"</span>,all_train_iters,all_train_costs,all_train_accs,<span class="string">"trainning cost"</span>,<span class="string">"trainning acc"</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Pass:0, Batch:0, Cost:2.62739, Accuracy:0.17188
Pass:0, Batch:200, Cost:0.31689, Accuracy:0.87500
Pass:0, Batch:400, Cost:0.28762, Accuracy:0.92188
Test:0, Cost:0.22491, Accuracy:0.93008
Pass:1, Batch:0, Cost:0.28741, Accuracy:0.91406
Pass:1, Batch:200, Cost:0.20729, Accuracy:0.95312
Pass:1, Batch:400, Cost:0.20814, Accuracy:0.93750
Test:1, Cost:0.15814, Accuracy:0.94877
save models to /home/aistudio/work/hand.inference.model
训练模型保存完成！</code></pre><p><img src="output_25_1.png" alt="png"></p>
<h1 id="Step5-模型预测"><a href="#Step5-模型预测" class="headerlink" title="Step5.模型预测"></a><strong>Step5.模型预测</strong></h1><p>（1）图片预处理</p>
<p>在预测之前，要对图像进行预处理。</p>
<p>首先进行灰度化，然后压缩图像大小为28*28，接着将图像转换成一维向量，最后再对一维向量进行归一化处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(file)</span>:</span></span><br><span class="line">    im = Image.open(file).convert(<span class="string">'L'</span>)                        <span class="comment">#将RGB转化为灰度图像，L代表灰度图像，像素值在0~255之间</span></span><br><span class="line">    im = im.resize((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)                 <span class="comment">#resize image with high-quality 图像大小为28*28</span></span><br><span class="line">    im = np.array(im).reshape(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).astype(np.float32)<span class="comment">#返回新形状的数组,把它变成一个 numpy 数组以匹配数据馈送格式。</span></span><br><span class="line">    <span class="comment"># print(im)</span></span><br><span class="line">    im = im / <span class="number">255.0</span> * <span class="number">2.0</span> - <span class="number">1.0</span>                               <span class="comment">#归一化到【-1~1】之间</span></span><br><span class="line">    <span class="keyword">return</span> im</span><br></pre></td></tr></table></figure>

<p>（2）使用Matplotlib工具显示这张图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">infer_path=<span class="string">'/home/aistudio/data/data1910/infer_3.png'</span></span><br><span class="line">img = Image.open(infer_path)</span><br><span class="line">plt.imshow(img)   <span class="comment">#根据数组绘制图像</span></span><br><span class="line">plt.show()        <span class="comment">#显示图像</span></span><br></pre></td></tr></table></figure>


<p><img src="output_30_0.png" alt="png"></p>
<p>(3)创建预测用的Executer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">infer_exe = fluid.Executor(place)</span><br><span class="line">inference_scope = fluid.core.Scope()</span><br></pre></td></tr></table></figure>

<p>(4)开始预测</p>
<p>通过fluid.io.load_inference_model，预测器会从params_dirname中读取已经训练好的模型，来对从未遇见过的数据进行预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据并开始预测</span></span><br><span class="line"><span class="keyword">with</span> fluid.scope_guard(inference_scope):</span><br><span class="line">    <span class="comment">#获取训练好的模型</span></span><br><span class="line">    <span class="comment">#从指定目录中加载 推理model(inference model)</span></span><br><span class="line">    [inference_program,                                            <span class="comment">#推理Program</span></span><br><span class="line">     feed_target_names,                                            <span class="comment">#是一个str列表，它包含需要在推理 Program 中提供数据的变量的名称。 </span></span><br><span class="line">     fetch_targets] = fluid.io.load_inference_model(model_save_dir,<span class="comment">#fetch_targets：是一个 Variable 列表，从中我们可以得到推断结果。model_save_dir：模型保存的路径</span></span><br><span class="line">                                                    infer_exe)     <span class="comment">#infer_exe: 运行 inference model的 executor</span></span><br><span class="line">    img = load_image(infer_path)</span><br><span class="line"></span><br><span class="line">    results = infer_exe.run(program=inference_program,               <span class="comment">#运行推测程序</span></span><br><span class="line">                   feed=&#123;feed_target_names[<span class="number">0</span>]: img&#125;,           <span class="comment">#喂入要预测的img</span></span><br><span class="line">                   fetch_list=fetch_targets)                   <span class="comment">#得到推测结果,  </span></span><br><span class="line">    <span class="comment"># 获取概率最大的label</span></span><br><span class="line">    lab = np.argsort(results)                                  <span class="comment">#argsort函数返回的是result数组值从小到大的索引值</span></span><br><span class="line">    <span class="comment">#print(lab)</span></span><br><span class="line">    print(<span class="string">"该图片的预测结果的label为: %d"</span> % lab[<span class="number">0</span>][<span class="number">0</span>][<span class="number">-1</span>])     <span class="comment">#-1代表读取数组中倒数第一列</span></span><br></pre></td></tr></table></figure>

<pre><code>该图片的预测结果的label为: 3</code></pre><p>测试图片下载(直接右键图片另存为即可)：<br><img src="infer_3.png" alt="png"><br><img src="infer_9.jpg" alt="jpg">  </p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1356</title>
    <url>/2020/03/02/leetcode-1356/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/</a>  </p>
<a id="more"></a>
<img src="/2020/03/02/leetcode-1356/1.png" class="" title="[leetcode-1356]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct node&#123;&#x2F;&#x2F;自定义结构体</span><br><span class="line">        int data;</span><br><span class="line">        int num;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a,node b)&#123;&#x2F;&#x2F;自定义排序函数</span><br><span class="line">        return a.num&#x3D;&#x3D;b.num?a.data&lt;b.data;a.num&lt;b.num;</span><br><span class="line">    &#125;</span><br><span class="line">    int checked(int n)&#x2F;&#x2F;输入一个十进制数字，输出数字在二进制下1的个数</span><br><span class="line">    &#123;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        while (n!&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            if (n%2!&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            n&#x2F;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;       </span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        vector&lt;node&gt;V;</span><br><span class="line">        for(auto i:arr)&#123;</span><br><span class="line">            int num&#x3D;checked(i);</span><br><span class="line">            V.push_back(&#123;i,num&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(),V.end(),cmp);</span><br><span class="line">        arr.clear();</span><br><span class="line">        for(auto i:V)&#123;</span><br><span class="line">            arr.push_back(i.data);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/03/02/leetcode-1356/2.png" class="" title="[leetcode-1356]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-面试题45</title>
    <url>/2020/02/29/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9845/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</a>  </p>
<a id="more"></a>
<img src="/2020/02/29/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9845/1.png" class="" title="[leetcode-面试题45]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">    string minNumber(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        vector&lt;string&gt; V(len);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V[i] &#x3D; to_string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (auto i : V)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很像179题，思路是一模一样的</p>
<img src="/2020/02/29/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9845/2.png" class="" title="[leetcode-面试题45]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1054</title>
    <url>/2020/02/28/leetcode-1054/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/distant-barcodes/">https://leetcode-cn.com/problems/distant-barcodes/</a>  </p>
<a id="more"></a>
<img src="/2020/02/28/leetcode-1054/1.png" class="" title="[leetcode-1054]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一开始自己的思路，排序后从前往后和从后往前依次输出一个数，直到遍历完成，too young too simple，sometimes naive</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt; &amp;barcodes)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        sort(barcodes.begin(), barcodes.end());</span><br><span class="line">        int i &#x3D; 0, j &#x3D; barcodes.size() - 1;</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &lt;&#x3D; j)</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(barcodes[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt;&#x3D; j)</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(barcodes[j]);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*</span><br><span class="line">非常好的思路：使用map来保存每个数字出现的次数，然后存入优先队列中并根据次数进行从大到小的排序（需要自定义排序函数）</span><br><span class="line">然后每次取优先队列的头两个元素，放入vector并将其second减一，如果不为0再放回。这样一直</span><br><span class="line">到最后优先队列只剩一个元素0个元素，然后直接再将其放入vector中即可</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct cmp</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator()(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b)</span><br><span class="line">        &#123;</span><br><span class="line">            return a.second &lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt; &amp;barcodes)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; P;</span><br><span class="line">        map&lt;int, int&gt; M;</span><br><span class="line">        for (auto it : barcodes)</span><br><span class="line">        &#123;</span><br><span class="line">            M[it]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it : M)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int, int&gt; temp;</span><br><span class="line">            temp.first &#x3D; it.first;</span><br><span class="line">            temp.second &#x3D; it.second;</span><br><span class="line">            P.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        while (P.size() &gt;&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            auto t1 &#x3D; P.top();</span><br><span class="line">            P.pop();&#x2F;&#x2F;别忘pop</span><br><span class="line">            auto t2 &#x3D; P.top();</span><br><span class="line">            P.pop();</span><br><span class="line">            V.push_back(t1.first);</span><br><span class="line">            V.push_back(t2.first);</span><br><span class="line">            if (--t1.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--t2.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (P.size() &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(P.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/28/leetcode-1054/2.png" class="" title="[leetcode-1054]">  
<p>这类题（周围元素没有相同的排序）思路就非常明显了：使用map，优先队列，然后依次从次数大的元素开始输出即可(跟前面的767重构字符串很像)<br>修改后的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">学了1054新方法之后回来重写的方法，根本思路与1054基本一致</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct cmp</span><br><span class="line">    &#123;</span><br><span class="line">        bool operator()(const pair&lt;char, int&gt; &amp;a, const pair&lt;char, int&gt; &amp;b) const</span><br><span class="line">        &#123;</span><br><span class="line">            return a.second &lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;char, int&gt;, vector&lt;pair&lt;char, int&gt;&gt;, cmp&gt; P;</span><br><span class="line">        map&lt;char, int&gt; M;</span><br><span class="line">        for (auto it : S)</span><br><span class="line">        &#123;</span><br><span class="line">            M[it]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it : M)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;char, int&gt; temp;</span><br><span class="line">            temp.first &#x3D; it.first;</span><br><span class="line">            temp.second &#x3D; it.second;</span><br><span class="line">            P.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        int len&#x3D;S.size();</span><br><span class="line">        if (P.top().second &gt; (len + 1) &#x2F; 2) &#x2F;&#x2F;如果次数出现最多的字母大于字符串的一半长度，那么肯定是不可以成功的了</span><br><span class="line">        &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        while (P.size() &gt;&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            auto t1 &#x3D; P.top();</span><br><span class="line">            P.pop();</span><br><span class="line">            auto t2 &#x3D; P.top();</span><br><span class="line">            P.pop();</span><br><span class="line">            str +&#x3D; t1.first;</span><br><span class="line">            str +&#x3D; t2.first;</span><br><span class="line">            if (--t1.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (--t2.second &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push(t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (P.size() &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; P.top().first;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/28/leetcode-1054/3.png" class="" title="[leetcode-1054]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-853</title>
    <url>/2020/02/26/leetcode-853/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/car-fleet/">https://leetcode-cn.com/problems/car-fleet/</a>  </p>
<a id="more"></a>
<img src="/2020/02/26/leetcode-853/1.png" class="" title="[leetcode-853]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">思路：一开始的思路是只要有一个还未到终点的瞬间，有多个车到了同一个距离，那么他们就是</span><br><span class="line">同一个车队，为了防止重复计算，就将这些划为车队的车进行flag&#x3D;false操作，使其不再进行</span><br><span class="line">下一步遍历，结果只对了十个测试点，思路错了</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int pos;</span><br><span class="line">        bool flag &#x3D; true;</span><br><span class="line">    &#125;;</span><br><span class="line">    int equalNum(vector&lt;node&gt; &amp;V) &#x2F;&#x2F;函数检查V中相等元素的个数并返回，还要修改flag</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;int, int&gt; P;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[i].flag)</span><br><span class="line">            &#123;</span><br><span class="line">                P[V[i].pos]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second &gt;&#x3D; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (V[i].pos &#x3D;&#x3D; it-&gt;first)</span><br><span class="line">                    &#123;</span><br><span class="line">                        V[i].flag &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    int carFleet(int target, vector&lt;int&gt; &amp;position, vector&lt;int&gt; &amp;speed)</span><br><span class="line">    &#123;</span><br><span class="line">        int len &#x3D; position.size();</span><br><span class="line">        vector&lt;node&gt; V(len);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V[i].pos &#x3D; position[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (V[i].pos + speed[i] &lt;&#x3D; target &amp;&amp; V[i].flag) &#x2F;&#x2F;车还没到终点并且车不会超过终点</span><br><span class="line">                &#123;</span><br><span class="line">                    V[i].pos +&#x3D; speed[i];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &#x3D;&#x3D; 1 || cnt &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            count +&#x3D; equalNum(V);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[i].flag)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">官方思路：先按距终点的距离降序排序，然后算出每个车到终点的时间</span><br><span class="line">从头开始遍历(排序之后也就是降序顺序),遇到第一个比它大的数之前的车都可以组成一个车队</span><br><span class="line">因为车只受它前面的车的影响(后面的车即使追上他了也要跟他同一个速度前进)</span><br><span class="line">如果它到终点的时间小于等于前面车到终点的时间，那么它就能追上前面的车，也就是组成一个车队</span><br><span class="line">所以只要他遇到比它大的数，那么那个数之后（包括那个数）都不会与前面的车组成一个车队</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int pos;</span><br><span class="line">        double time;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a,node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.pos&gt;b.pos;</span><br><span class="line">    &#125;</span><br><span class="line">    int carFleet(int target, vector&lt;int&gt; &amp;position, vector&lt;int&gt; &amp;speed)</span><br><span class="line">    &#123;    </span><br><span class="line">        int len &#x3D; position.size();</span><br><span class="line">        if (len&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;node&gt; V(len);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V[i].pos &#x3D; position[i];</span><br><span class="line">            V[i].time &#x3D; (target - position[i])*1.0 &#x2F; speed[i];&#x2F;&#x2F;向上取整</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(),V.end(),cmp);</span><br><span class="line">        int i&#x3D;0,j&#x3D;i,cnt&#x3D;0;</span><br><span class="line">        while (j&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[j].time&lt;&#x3D;V[i].time)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                i&#x3D;j;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt+1;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/26/leetcode-853/2.png" class="" title="[leetcode-853]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-179</title>
    <url>/2020/02/25/leetcode-179/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-number/">https://leetcode-cn.com/problems/largest-number/</a>  </p>
<a id="more"></a>
<img src="/2020/02/25/leetcode-179/1.png" class="" title="[leetcode-179]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a+b&gt;b+a;&#x2F;&#x2F;直接根据a+b和b+a中更大的来排序，简单粗暴</span><br><span class="line">    &#125;</span><br><span class="line">    string largestNumber(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; V;&#x2F;&#x2F;用来存nums数组元素转换为string元素</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp&#x3D;to_string(nums[i]);</span><br><span class="line">            V.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        for (auto i &#x3D; V.begin(); i !&#x3D; V.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; *i;</span><br><span class="line">        &#125;</span><br><span class="line">        while (str[0]&#x3D;&#x3D;&#39;0&#39;&amp;&amp;str.size()&gt;1)&#x2F;&#x2F;删除拼接字符串的首项为0的元素，知道只剩一个0为止</span><br><span class="line">        &#123;</span><br><span class="line">            str.erase(0,1);</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/25/leetcode-179/2.png" class="" title="[leetcode-179]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-274</title>
    <url>/2020/02/25/leetcode-274/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/h-index/">https://leetcode-cn.com/problems/h-index/</a>  </p>
<a id="more"></a>
<img src="/2020/02/25/leetcode-274/1.png" class="" title="[leetcode-274]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">思路：就是从1-V.size()进行遍历，看哪个数最后满足h指数的情况，然后输出即可</span><br><span class="line">注意要使用do-while，这样可以使得循环至少进行一次，若数组只有一个元素，那么</span><br><span class="line">for循环就会出错</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">    bool checked(int cnt, vector&lt;int&gt; &amp;V)</span><br><span class="line">    &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (V[i] &gt;&#x3D; cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count&gt;&#x3D;cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    int hIndex(vector&lt;int&gt; &amp;citations)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(citations.begin(), citations.end());</span><br><span class="line">        int max &#x3D; 0, temp,i&#x3D;0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            if(checked(i, citations)&amp;&amp;i&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max&#x3D;i;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125; while (i&lt;citations.size());     </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/25/leetcode-274/2.png" class="" title="[leetcode-274]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-56</title>
    <url>/2020/02/24/leetcode-56/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a>  </p>
<a id="more"></a>
  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：首先按区间开头从小到大排序，然后每次比较前两个元素并判断：如果第一个元素的区间结尾</span><br><span class="line">&#x2F;&#x2F;大于第二个元素的区间开头，说明两个区间重合，因为已经排序，所以改变第二个元素，它的区间开头</span><br><span class="line">&#x2F;&#x2F;一定是第一个元素的区间开头，它的区间结尾是第一个元素和第二个元素区间结尾的最大值&#123;比如[0,4],[1,3];和[0,4],[1,5]&#125;</span><br><span class="line">&#x2F;&#x2F;然后删除第一个元素即可</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt; v1, vector&lt;int&gt; v2)</span><br><span class="line">    &#123;</span><br><span class="line">        return v1[0]&lt;v2[0];       </span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt; &amp;intervals)</span><br><span class="line">    &#123;</span><br><span class="line">        if (intervals.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        for (auto it &#x3D; intervals.begin(); it !&#x3D; intervals.end() - 1;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it[0][1] &gt;&#x3D; (it + 1)[0][0])</span><br><span class="line">            &#123;</span><br><span class="line">                (it + 1)[0][0] &#x3D; it[0][0];</span><br><span class="line">                (it + 1)[0][1] &#x3D; max(it[0][1],(it+1)[0][1]);</span><br><span class="line">                it &#x3D; intervals.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                it++;</span><br><span class="line">        &#125;</span><br><span class="line">        return intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-767</title>
    <url>/2020/02/24/leetcode-767/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/reorganize-string/">https://leetcode-cn.com/problems/reorganize-string/</a>  </p>
<a id="more"></a>
<img src="/2020/02/24/leetcode-767/1.png" class="" title="[leetcode-767]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;767 lang&#x3D;cpp</span><br><span class="line"> *</span><br><span class="line"> * [767] 重构字符串</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">&#x2F;&#x2F;思路：</span><br><span class="line">&#x2F;*先构造S的哈希表，如果S的最大值-1(就是需要填充的地方)小于剩余元素的和，那么</span><br><span class="line">肯定可以重排使其相邻字符不同，否则不可；</span><br><span class="line">判断出其可以后，只需按P的顺序输出即可*&#x2F;</span><br><span class="line">&#x2F;&#x2F;60,61,62测试点未通过，感觉我的方法有点笨拙，果断换思路</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;char, int&gt; P;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; S.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[S[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int max &#x3D; -1;</span><br><span class="line">        char index;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max &#x3D; it-&gt;second;</span><br><span class="line">                index &#x3D; it-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (auto it &#x3D; P.begin(); it !&#x3D; P.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;first !&#x3D; index)</span><br><span class="line">            &#123;</span><br><span class="line">                sum +&#x3D; it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (max - 1 &gt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag &#x3D; false;</span><br><span class="line">        if (max - 1 &#x3D;&#x3D; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;char, int&gt;&gt; V(P.begin(), P.end());</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        if (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                int cnt &#x3D; 0;</span><br><span class="line">                for (auto it &#x3D; V.begin(); it !&#x3D; V.end(); it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (it-&gt;second !&#x3D; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        str +&#x3D; it-&gt;first;</span><br><span class="line">                        it-&gt;second--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cnt &#x3D;&#x3D; V.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                int cnt &#x3D; 0;</span><br><span class="line">                for (auto it &#x3D; V.begin(); it !&#x3D; V.end(); it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (it-&gt;second !&#x3D; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        str +&#x3D; it-&gt;first;</span><br><span class="line">                        it-&gt;second--;</span><br><span class="line">                        if (it-&gt;first !&#x3D; index)</span><br><span class="line">                        &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cnt &#x3D;&#x3D; V.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*</span><br><span class="line">思路:</span><br><span class="line">根据字母出现的顺序排序，然后每次输出前两项即可(输出后记得减少前两项字母的次数)，输出后立刻再进行排序</span><br><span class="line">直到所有字母的次数都为0</span><br><span class="line">每次排序太麻烦，并且没有数据结构支持(set和优先队列当你进行--操作时就已经排序了所以不能保证第二项--时仍为原来的那一项)</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;*</span><br><span class="line">第三个思路：</span><br><span class="line">借鉴的大神思路-先使用哈希表按出现顺序从大到小排列，然后按间隔进行插入</span><br><span class="line">贪心思想</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(pair&lt;char, int&gt; a, pair&lt;char, int&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    string reorganizeString(string S)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;char, int&gt; P;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; S.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[S[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;char, int&gt;&gt; V(P.begin(), P.end());</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        for (auto p : V)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp(p.second, p.first); &#x2F;&#x2F;String temp(2,&#39;c&#39;)&#x3D;&#x3D;&quot;cc&quot;</span><br><span class="line">            str +&#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; str.size();</span><br><span class="line">        if (V[0].second &gt; (len+1) &#x2F; 2)&#x2F;&#x2F;如果次数出现最多的字母大于字符串的一半长度，那么肯定是不可以成功的了</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        S.clear();</span><br><span class="line">        S &#x3D; (len, &#39;0&#39;);</span><br><span class="line">        int i &#x3D; 0, j &#x3D; 1, index &#x3D; 0;</span><br><span class="line">        while (i &lt; len &amp;&amp; index &lt; len)&#x2F;&#x2F;按奇数进行插入</span><br><span class="line">        &#123;</span><br><span class="line">            S[i] &#x3D; str[index++];</span><br><span class="line">            i +&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt; len &amp;&amp; index &lt; len)&#x2F;&#x2F;按偶数进行插入</span><br><span class="line">        &#123;</span><br><span class="line">            S[j] &#x3D; str[index++];</span><br><span class="line">            j +&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br></pre></td></tr></table></figure>
<img src="/2020/02/24/leetcode-767/2.png" class="" title="[leetcode-767]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-524</title>
    <url>/2020/02/23/leetcode-524/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/</a>  </p>
<a id="more"></a>
<img src="/2020/02/23/leetcode-524/1.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次做题</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        int count;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.count &#x3D;&#x3D; b.count ? a.str &lt; b.str : a.count &lt; b.count;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checked(string s, string str) &#x2F;&#x2F;看两个字符串是否是相对顺序</span><br><span class="line">    &#123;</span><br><span class="line">        int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">        bool flag &#x3D; true;</span><br><span class="line">        if (s.size() &gt; str.size()) &#x2F;&#x2F;保证双指针在相等时往后移的是长字符串的指针</span><br><span class="line">        &#123;</span><br><span class="line">            flag &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        while (first &lt; s.size() &amp;&amp; second &lt; str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[first] &#x3D;&#x3D; str[second])</span><br><span class="line">            &#123;</span><br><span class="line">                first++;</span><br><span class="line">                second++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (!flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#x2F;&#x2F;判断是否是相对顺序是看短字符串是否到了尽头</span><br><span class="line">        &#123;</span><br><span class="line">            if (second &#x3D;&#x3D; str.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (first &#x3D;&#x3D; s.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;node&gt; V;</span><br><span class="line">        map&lt;char, int&gt; P;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P[s[i]]++; &#x2F;&#x2F;将字符串s出现的字母次数存入哈希表</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map&lt;char, int&gt; temp &#x3D; P;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            if (!checked(s, d[i])) &#x2F;&#x2F;如果不是相对顺序，那么直接跳过这个字符串</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; d[i].size(); j++) &#x2F;&#x2F;在需要判断的字符串中遍历，并每出现一个</span><br><span class="line">            &#123;                                     &#x2F;&#x2F;字母，就将其在哈希表中的数值-1,</span><br><span class="line">                temp[d[i][j]]--;                  &#x2F;&#x2F;如果出现-1表示不能组成字符串</span><br><span class="line">                if (temp[d[i][j]] &#x3D;&#x3D; -1)          &#x2F;&#x2F;剩余字母的次数相加越小者，说明其本身越长</span><br><span class="line">                &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                int cnt &#x3D; 0;</span><br><span class="line">                for (auto it &#x3D; temp.begin(); it !&#x3D; temp.end(); it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt +&#x3D; it-&gt;second;</span><br><span class="line">                &#125;</span><br><span class="line">                V.push_back(&#123;d[i], cnt&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (V.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        return V[0].str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/2.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第二次优化，将第一次的大圈子剪短一半，不需要哈希表，双指针即可</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.size() &#x3D;&#x3D; b.size() ? a &lt; b : a.size() &gt; b.size();</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; V;</span><br><span class="line">        if (s.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            if (s.size() &gt; d[i].size()) &#x2F;&#x2F;保证双指针在相等时往后移的是长字符串的指针</span><br><span class="line">            &#123;</span><br><span class="line">                flag &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            while (first &lt; s.size() &amp;&amp; second &lt; d[i].size())</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[first] &#x3D;&#x3D; d[i][second])</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!flag)</span><br><span class="line">                    &#123;</span><br><span class="line">                        first++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        second++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag) &#x2F;&#x2F;判断是否是相对顺序是看短字符串是否到了尽头</span><br><span class="line">            &#123;</span><br><span class="line">                if (second &#x3D;&#x3D; d[i].size())</span><br><span class="line">                &#123;</span><br><span class="line">                    V.push_back(d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (first &#x3D;&#x3D; s.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    V.push_back(d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        if (V.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return V[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/3.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第三次优化，每次不需判断s与d[i]哪个大，都只让s大即可</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(string a, string b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.size() &#x3D;&#x3D; b.size() ? a &lt; b : a.size() &gt; b.size();</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; V;</span><br><span class="line">        if (s.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            if (d[i].size() &gt; s.size()) &#x2F;&#x2F;只要一直让s的大小大于d[i],就会省很多行代码</span><br><span class="line">                swap(d[i], s);</span><br><span class="line">            while (first &lt; s.size() &amp;&amp; second &lt; d[i].size())</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[first] &#x3D;&#x3D; d[i][second])</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (second &#x3D;&#x3D; d[i].size())</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        if (V.size() &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return V[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/4.png" class="" title="[leetcode-524]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第四次优化，将所有计算size的操作全部赋值再使用</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string checked(string a, string b)&#x2F;&#x2F;不需要另加vector再排序后输出，进行简单的比较即可</span><br><span class="line">    &#123;</span><br><span class="line">        int size1&#x3D;a.size(),size2&#x3D;b.size();</span><br><span class="line">        if (size1 &#x3D;&#x3D; size2)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a &gt; b)</span><br><span class="line">            &#123;</span><br><span class="line">                return b;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return a;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (size1 &gt; size2)</span><br><span class="line">            &#123;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string findLongestWord(string s, vector&lt;string&gt; &amp;d)</span><br><span class="line">    &#123;</span><br><span class="line">        string str &#x3D; &quot;&quot;;</span><br><span class="line">        int sSize&#x3D;s.size();</span><br><span class="line">        if (sSize &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; d.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int first &#x3D; 0, second &#x3D; 0;</span><br><span class="line">            bool flag &#x3D; true;</span><br><span class="line">            int dSize&#x3D;d[i].size();</span><br><span class="line">            if (dSize &gt; sSize) &#x2F;&#x2F;只要一直让s的大小大于d[i],就会省很多行代码</span><br><span class="line">                swap(d[i], s);</span><br><span class="line">            while (first &lt; sSize &amp;&amp; second &lt; dSize)</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[first] &#x3D;&#x3D; d[i][second])</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    first++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (second &#x3D;&#x3D; dSize)</span><br><span class="line">            &#123;</span><br><span class="line">                str &#x3D; checked(str,d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/23/leetcode-524/5.png" class="" title="[leetcode-524]">  




]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-75</title>
    <url>/2020/02/22/leetcode-75/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors/">https://leetcode-cn.com/problems/sort-colors/</a>  </p>
<a id="more"></a>
<img src="/2020/02/22/leetcode-75/1.png" class="" title="[leetcode-75]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">我的思路：定两个指针，前指针指向第一个元素和后指针指向最后一个元素，然后从前往后扫描数组，遇到0，</span><br><span class="line">与前指针元素交换，前指针++；遇到1继续走，遇到2，与后指针元素交换，后指针--，前指针与后指针相等时跳出遍历，</span><br><span class="line">这样时间复杂度是O(n),空间复杂度是常数O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        int front &#x3D; 0, rear &#x3D; nums.size() - 1;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (i &lt;&#x3D; rear)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[front]);</span><br><span class="line">                i++;</span><br><span class="line">                front++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i] &#x3D;&#x3D; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[rear]);</span><br><span class="line">                rear--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i] &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>肺都气炸，思路跟迪杰斯特拉解决三色国旗问题的思路是一样的，但跳出循环条件不一样，我一开始写的条件是front!=rear,后来改成front!=rear-1也不对，压根没想到i一直往后走知道i&gt;rear跳出循环，只能说差一点吧，继续加油</p>
<img src="/2020/02/22/leetcode-75/2.png" class="" title="[leetcode-75]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-973</title>
    <url>/2020/02/22/leetcode-969/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/pancake-sorting">https://leetcode-cn.com/problems/pancake-sorting</a>  </p>
<a id="more"></a>
<img src="/2020/02/22/leetcode-969/1.png" class="" title="[leetcode-969]">  
<p>很有趣的一道题，一开始我的思路是找到先遍历一遍找到最大值，然后将最大值翻转到最后一位，然后每次遍历最大值都已经归位了。但是题目中只可以翻转前n项，所以只需要多一步辅助，将最大值翻转到第一位，然后再翻转到最后一位。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; pancakeSort(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        int temp &#x3D; 0;&#x2F;&#x2F;每一次循环最大的元素一定在正确位置，所以使用temp来缩短遍历长度</span><br><span class="line">        for (int j &#x3D; 0; j &lt; A.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int max &#x3D; -1, index &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; A.size() - temp; i++)&#x2F;&#x2F;寻找剩余元素中的最大值，返回其下标</span><br><span class="line">            &#123;</span><br><span class="line">                if (max &lt; A[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    max &#x3D; A[i];</span><br><span class="line">                    index &#x3D; i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (index &#x3D;&#x3D; 0)&#x2F;&#x2F;如果最大值恰好在第一个元素位置，那么直接进行翻转A.size() - temp长度将其转到剩余元素的最大位置</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(A.size() - temp);</span><br><span class="line">                reverseK(A, A.size() - temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                V.push_back(index + 1);&#x2F;&#x2F;先将其翻转到第一个元素位置</span><br><span class="line">                reverseK(A, index + 1);</span><br><span class="line">                V.push_back(A.size() - temp);&#x2F;&#x2F;再将第一个元素位置翻转到剩余元素最大值位置</span><br><span class="line">                reverseK(A, A.size() - temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void reverseK(vector&lt;int&gt; &amp;V, int k) &#x2F;&#x2F;翻转vector的前k个元素</span><br><span class="line">    &#123;</span><br><span class="line">        if (k &gt; V.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(V.begin(), V.begin() + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/22/leetcode-969/2.png" class="" title="[leetcode-969]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-973</title>
    <url>/2020/02/21/leetcode-973/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">https://leetcode-cn.com/problems/k-closest-points-to-origin/</a>  </p>
<a id="more"></a>
<img src="/2020/02/21/leetcode-973/1.png" class="" title="[leetcode-973]">  
<p>跟1030有异曲同工之妙，看1030思路即可  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        int c;</span><br><span class="line">        int dis;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.dis &lt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt; &amp;points, int K)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;node&gt; V;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node temp &#x3D; &#123;points[i][0], points[i][1], pow(points[i][0], 2) + pow(points[i][1], 2)&#125;;&#x2F;&#x2F;因为坐标只有两位，所以使用0,1即可得到点的横纵坐标</span><br><span class="line">            V.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; K; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(&#123;V[i].r, V[i].c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/21/leetcode-973/2.png" class="" title="[leetcode-973]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>解决新发布的文章中文乱码</title>
    <url>/2020/02/20/%E8%A7%A3%E5%86%B3%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>最近遇到了很麻烦的问题，就是我</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>创建了一个新文章之后，使用有道云笔记打开再编辑完后通过记录本的格式复制回去，发现线上的文章就是中文乱码了，包括标题和分类也是乱码，代码中的中文也会乱码。这里总结一下解决方法</p>
<blockquote>
<p>根本问题在于：使用记事本打开新文章后，默认的格式是ANSI,需要改成UTF-8并另存为。</p>
</blockquote>
<p>但有的时候另存为选择所有文件格式还是会存成.txt后缀的文件，所以这时要修改一下文件格式，将.md删掉重新输入.md，然后选择所有格式和UTF-8,这样保存时就会有是否替换的提示，替换后就会恢复中文了。</p>
<img src="/2020/02/20/%E8%A7%A3%E5%86%B3%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/1.png" class="" title="[解决新发布的文章中文乱码]">  
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-147</title>
    <url>/2020/02/20/leetcode-147/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/insertion-sort-list/">https://leetcode-cn.com/problems/insertion-sort-list/</a>  </p>
<img src="/2020/02/20/leetcode-147/1.png" class="" title="[leetcode-147]">  
<a id="more"></a>
<p>最基本的插入排序，难点应该在于数据结构使用的链表所以麻烦一些，不过思路是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *insertionSortList(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!head||!head-&gt;next)&#x2F;&#x2F;链表题这个是套路，必须要在前面加上</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy(0);&#x2F;&#x2F;dummy头结点法，就不多说了</span><br><span class="line">        dummy.next &#x3D; head;</span><br><span class="line">        ListNode *cur &#x3D; head-&gt;next;&#x2F;&#x2F;cur为当前要插入的点</span><br><span class="line">        head-&gt;next&#x3D;NULL;&#x2F;&#x2F;第一个点默认是已经排好的，所以与后面的链表元素断开</span><br><span class="line">        while (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *temp &#x3D; &amp;dummy;</span><br><span class="line">            while (temp-&gt;next-&gt;val &lt; cur-&gt;val)&#x2F;&#x2F;找到第一个比cur大的元素，即在temp后面插入cur元素</span><br><span class="line">            &#123;</span><br><span class="line">                temp &#x3D; temp-&gt;next;</span><br><span class="line">                if (!temp-&gt;next)&#x2F;&#x2F;如果找到最后temp已经到有序链表的结尾处还未找到比cur大的元素，则说明cur元素要插在有序链表的末尾</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;          </span><br><span class="line">            ListNode* res&#x3D;cur-&gt;next;&#x2F;&#x2F;res为保存下一个要插入的点的指针，因为之后cur会改变，所以要保存当前的位置</span><br><span class="line">            cur-&gt;next &#x3D; temp-&gt;next;&#x2F;&#x2F;在temp节点后面插入节点的两部曲</span><br><span class="line">            temp-&gt;next &#x3D; cur;</span><br><span class="line">            cur &#x3D; res;&#x2F;&#x2F;cur继续遍历</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/20/leetcode-147/2.png" class="" title="[leetcode-147]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-148</title>
    <url>/2020/02/20/leetcode-148/</url>
    <content><![CDATA[<img src="/2020/02/20/leetcode-148/1.png" class="" title="[leetcode-148]">  
<p><a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a>  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av31197206?from&#x3D;search&amp;seid&#x3D;13970831847445553437</span><br><span class="line">第一个方法:使用fast，slow快慢指针，这样快指针走到链表结尾时慢指针走到链表中间，使链表一分为二，这样再分别对两个部分进行排序sort(l1),sort(l2)</span><br><span class="line">然后再合并merge(l1,l2).因为排序部分是用到递归，所以空间复杂度为O(logn),时间复杂度为O(nlogn)</span><br><span class="line">注意一开始时fast一定是head-&gt;next，而slow为head，因为如果fast和slow都是同一起点，那么如果链表是1-&gt;3-&gt;5时，fast第二次迭代就会变成野指针了(null-&gt;next)</span><br><span class="line">而fast在初始化时就往后退一格正好避免这种错误情况，这样跳出循环的条件是slow在链表中央时，fast为NULL或fast-&gt;next&#x3D;&#x3D;NULL</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *sortList(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!head || !head-&gt;next) &#x2F;&#x2F;如果链表只有一个元素或没有元素，则直接返回即可无需排序</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast &#x3D; head-&gt;next;</span><br><span class="line">        ListNode *slow &#x3D; head;</span><br><span class="line">        while (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">            slow &#x3D; slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *mid &#x3D; slow-&gt;next;</span><br><span class="line">        slow-&gt;next &#x3D; NULL;</span><br><span class="line">        return merge(sortList(mid), sortList(head));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ListNode *merge(ListNode *list1, ListNode *list2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode dummy(0);       &#x2F;&#x2F;链表的构造函数</span><br><span class="line">        ListNode *tail &#x3D; &amp;dummy; &#x2F;&#x2F;这个引用很关键，tail是指针指向dummy，tail伴随着插入的元素一直走到链表尾部</span><br><span class="line">        while (list1 &amp;&amp; list2)   &#x2F;&#x2F;就是merge的标准格式代码，双指针比较</span><br><span class="line">        &#123;</span><br><span class="line">            if (list1-&gt;val &gt; list2-&gt;val) &#x2F;&#x2F;这样的好处就是始终让list1-&gt;val&lt;list2-&gt;val，这样始终是将list1放入tail后面</span><br><span class="line">            &#123;</span><br><span class="line">                swap(list1, list2);</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1-&gt;next;</span><br><span class="line">            tail &#x3D; tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1) &#x2F;&#x2F;如果跳出循环后list1还存在，就将剩余的list1元素接到tail后面即可</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list2) &#x2F;&#x2F;同理</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/20/leetcode-148/2.png" class="" title="[leetcode-148]">  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">第二个方法：使用for循环进行merge操作，而不是用递归操作，这样时间复杂度不变,空间复杂度为O(1)</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *sortList(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!head || !head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp &#x3D; head;</span><br><span class="line">        int len &#x3D; 0;&#x2F;&#x2F;len是链表的长度</span><br><span class="line">        while (temp)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            temp &#x3D; temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy(0);</span><br><span class="line">        dummy.next &#x3D; head;</span><br><span class="line">        ListNode *l;</span><br><span class="line">        ListNode *r;</span><br><span class="line">        ListNode *tail;</span><br><span class="line">        for (int n &#x3D; 1; n &lt; len; n *&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            tail &#x3D; &amp;dummy;</span><br><span class="line">            ListNode *cur &#x3D; dummy.next;</span><br><span class="line">            while (cur)&#x2F;&#x2F;cur走到链表结尾会为NULL</span><br><span class="line">            &#123;</span><br><span class="line">                l &#x3D; cur;&#x2F;&#x2F;l在cur位置上</span><br><span class="line">                r &#x3D; split(l, n);&#x2F;&#x2F;r是l位置取n个元素后(并断开)的剩下元素链表的头指针</span><br><span class="line">                cur &#x3D; split(r, n);&#x2F;&#x2F;cur是r位置取n个元素后(并断开)剩下的元素链表的头指针</span><br><span class="line">                auto result &#x3D; merge(l, r);&#x2F;&#x2F;将l和r两个链表进行merge并将其绑定到tail后</span><br><span class="line">                tail-&gt;next &#x3D; result.first;</span><br><span class="line">                tail &#x3D; result.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ListNode *split(ListNode *head, int n)&#x2F;&#x2F;是将head链表分割n个元素出去，得到n个元素的链表和剩下元素的链表，比如1-&gt;4-&gt;3-&gt;2， n&#x3D;1,</span><br><span class="line">    &#123;&#x2F;&#x2F;那么分割1个元素后head&#x3D;1,rest&#x3D;4-&gt;3-&gt;2，并且head的后续是断开的即head-&gt;next&#x3D;NULL。函数的操作就是分割链表并断开链表</span><br><span class="line">        while (head &amp;&amp; --n)</span><br><span class="line">        &#123;</span><br><span class="line">            head &#x3D; head-&gt;next;&#x2F;&#x2F;找到要分割的最后一个元素</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *rest &#x3D; head ? head-&gt;next : NULL;&#x2F;&#x2F;如果head不为空，那么rest就为head-&gt;next(因为head是分割的最后一个元素，head-&gt;next就是rest链表的头)，否则就将rest置为NULL</span><br><span class="line">        if (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next &#x3D; NULL;&#x2F;&#x2F;别忘了将要分离的元素和rest元素断开</span><br><span class="line">        &#125;</span><br><span class="line">        return rest;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;ListNode *, ListNode *&gt; merge(ListNode *list1, ListNode *list2)&#x2F;&#x2F;相比第一种方法多返回一个链表的尾指针，这样方便在sortList中将tail直接绑定到尾指针上</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode dummy(0);</span><br><span class="line">        ListNode *tail &#x3D; &amp;dummy;</span><br><span class="line">        while (list1 &amp;&amp; list2)</span><br><span class="line">        &#123;</span><br><span class="line">            if (list1-&gt;val &gt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(list1, list2);</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1-&gt;next;</span><br><span class="line">            tail &#x3D; tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list1)</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list2)</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next &#x3D; list2;</span><br><span class="line">        &#125;</span><br><span class="line">        while (tail-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            tail &#x3D; tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;dummy.next, tail&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/20/leetcode-148/3.png" class="" title="[leetcode-148]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-976</title>
    <url>/2020/02/17/leetcode-976/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">https://leetcode-cn.com/problems/largest-perimeter-triangle/</a>  </p>
<img src="/2020/02/17/leetcode-976/1.png" class="" title="[leetcode-976]">  
<a id="more"></a>
<p>第一个算法：先排序，然后从后面往前遍历，因为是三边，所以取三次遍历，每次判断是否是三角形，如果是则返回，不是的话最后函数跳出0，但是一看就超时了  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#x2F;&#x2F;这个算法超时了</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int largestPerimeter(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; i - 1; j &gt;&#x3D; 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int m &#x3D; j - 1; m &gt;&#x3D; 0; m--)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (A[m] + A[j] &gt; A[i]) &#x2F;&#x2F;因为是三角形三边从小到大依次是A[m],A[j]和A[i](因为排序并且从后向前遍历)，所以只需三角形最短的两边比第三边大即可</span><br><span class="line">                    &#123;</span><br><span class="line">                        return A[i] + A[j] + A[m];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/17/leetcode-976/2.png" class="" title="[leetcode-976]">  
<p>第二个算法：在第一个算法的基础上改进，因为如果遍历三次，肯定是这种情况:比如排好序之后数组为1,3,5,7.取得是3,5,7；1,5,7；1,3,5这样取。但实际上如果3,5,7无法组成三角形，那么1,5,7一定也不可以，因为1比3小。<br>所以我们只需一个大小为3的滑动窗口，然后从数组最后往前移动即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int largestPerimeter(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        for (int i &#x3D; A.size() - 3; i &gt;&#x3D; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (A[i]+A[i+1]&gt;A[i+2])&#x2F;&#x2F;因为从小到大为A[i]，A[i+1]，A[i+2]，只要满足最小的两边之和大于第三边即可</span><br><span class="line">            &#123;</span><br><span class="line">                return A[i]+A[i+1]+A[i+2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/17/leetcode-976/3.png" class="" title="[leetcode-976]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1030</title>
    <url>/2020/02/16/leetcode-1030/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">https://leetcode-cn.com/problems/matrix-cells-in-distance-order/</a>  </p>
<img src="/2020/02/16/leetcode-1030/1.png" class="" title="[leetcode-1030]">  

<a id="more"></a>  

<p>我的思路是既然是按距离排序，那我就创建一个struct node，然后使用sort的重载cmp函数进行排序，最后再只将struct node的横纵坐标加入到二维数组中。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    struct node</span><br><span class="line">    &#123;</span><br><span class="line">        int r;</span><br><span class="line">        int c;</span><br><span class="line">        int dis;</span><br><span class="line">    &#125;;</span><br><span class="line">    static bool cmp(node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.dis &lt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        vector&lt;node&gt; V;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; R; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; C; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                node temp &#x3D; &#123;i, j, abs(i - r0) + abs(j - c0)&#125;;&#x2F;&#x2F;创建temp节点并放入V中</span><br><span class="line">                V.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(V.begin(), V.end(), cmp);&#x2F;&#x2F;排序</span><br><span class="line">        for (int i &#x3D; 0; i &lt; V.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(&#123;V[i].r, V[i].c&#125;);&#x2F;&#x2F;将V中的元素放入vec中，但只放入横纵坐标</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/leetcode-1030/2.png" class="" title="[leetcode-1030]">  

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-数组的相对排序</title>
    <url>/2020/02/15/leetcode-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/relative-sort-array/">https://leetcode-cn.com/problems/relative-sort-array/</a>  </p>
<a id="more"></a>
<img src="/2020/02/15/leetcode-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/1.png" class="" title="[leetcode-数组的相对排序]">  
<p>这道题我的思路是只需在arr1中找到arr2中依次出现的元素，然后放入vector中，但是需要将每一个放入vector中的元素删除，这样时间复杂度就会变小。不过我看还有计数排序的方法，也可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt; &amp;arr1, vector&lt;int&gt; &amp;arr2)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        for (auto it1 &#x3D; arr2.begin(); it1 !&#x3D; arr2.end(); it1++)</span><br><span class="line">        &#123;</span><br><span class="line">            auto it2 &#x3D; arr1.begin();</span><br><span class="line">            while (it2 !&#x3D; arr1.end())</span><br><span class="line">            &#123;</span><br><span class="line">                if (*it2 &#x3D;&#x3D; *it1)</span><br><span class="line">                &#123;</span><br><span class="line">                    V.push_back(*it2);</span><br><span class="line">                    it2 &#x3D; arr1.erase(it2);&#x2F;&#x2F;从arr1中删除it2指针指向的元素</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    it2++;&#x2F;&#x2F;如果没匹配成功，必须要指针后移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(), arr1.end());&#x2F;&#x2F;将剩下的元素排序后再放入V中</span><br><span class="line">        for (auto i &#x3D; arr1.begin(); i !&#x3D; arr1.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(*i);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/15/leetcode-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/2.png" class="" title="[leetcode-数组的相对排序]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-按奇偶判断数组</title>
    <url>/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<img src="/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/1.png" class="" title="[leetcode-按奇偶判断数组]">  
<p><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</a><br>见到这个题的思路是：  </p>
<a id="more"></a>
<p>先将数组排序一遍，然后从头遍历判断每个位置：<br>1.如果当前位置为正确的数(奇数位置为奇数，偶数位置为偶数),那么就continue<br>2.如果当前位置不是正确的数，那么从这个数的下一个数开始一直到数组最后一个元素进行遍历，找到第一个适合当前位置的数，使他俩交换。<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt; &amp;A)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        &#x2F;&#x2F; sort(A.begin(), A.end());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((A[i] % 2 &#x3D;&#x3D; 0 &amp;&amp; i % 2 &#x3D;&#x3D; 0) || (A[i] % 2 !&#x3D; 0 &amp;&amp; i % 2 !&#x3D; 0))&#x2F;&#x2F;当前位置为正确的数</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j &#x3D; i + 1; j &lt; A.size(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if ((A[i] % 2 &#x3D;&#x3D; 0 &amp;&amp; A[j] % 2 !&#x3D; 0) || (A[i] % 2 !&#x3D; 0 &amp;&amp; A[j] % 2 &#x3D;&#x3D; 0))&#x2F;&#x2F;已知当前位置为错误的数，那么我只需往后找和他奇偶相反的数即可</span><br><span class="line">                    &#123;                                                                   &#x2F;&#x2F;比如上面的数是一个奇数，他的i是偶数，那么我只需在后面找一个偶数与自己交换即可</span><br><span class="line">                        swap(A[i], A[j]);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto i &#x3D; 0; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/2.png" class="" title="[leetcode-按奇偶判断数组]">  
<p>其实，最后的答案不是唯一的，不需要从头到尾为正序，所以第一步的sort没必要，优化以后就是只将代码中sort那一行注释即可  </p>
<img src="/2020/02/13/leetcode-%E6%8C%89%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/3.png" class="" title="[leetcode-按奇偶判断数组]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-两个数组的交集</title>
    <url>/2020/02/13/leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<img src="/2020/02/13/leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/2.png" class="" title="[leetcode-两个数组的交集]">  
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">https://leetcode-cn.com/problems/intersection-of-two-arrays/</a><br>这道题我的思路一开始是我先把两个数组进行排序，然后使用双指针思想，分别从两个数组的开头进行遍历，遇到相等时就把它们放到vector中，不相等时数小的指针往后移，直到数组超界。</p>
<a id="more"></a>
<p>结果我想的太复杂，实际上两个数组排好序后只要有一个超界，那么就可以break了，因为你已经排好了序，当一个数组超界时，另外一个数组就算没超界，其后面的元素也无法与超界数组进行匹配。而且最简单的办法就是引入一个set，先把相等的元素放入set中，再放到vector里，但是我一开始想着不想再多使用另一个数据结构了。但实际上使用set更简单一点。<br>代码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * @lc app&#x3D;leetcode.cn id&#x3D;349 lang&#x3D;cpp</span><br><span class="line"> *</span><br><span class="line"> * [349] 两个数组的交集</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; V;</span><br><span class="line">        set&lt;int&gt;S;</span><br><span class="line">        if (nums1.size() &#x3D;&#x3D; 0 || nums2.size() &#x3D;&#x3D; 0)&#x2F;&#x2F;如果一开始其中一个数组没有元素，那么就不会有相同的元素，输出空即可</span><br><span class="line">        &#123;</span><br><span class="line">            return V;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums1.begin(), nums1.end());&#x2F;&#x2F;排序</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; nums1.size() || j &#x3D;&#x3D; nums2.size())&#x2F;&#x2F;如果其中一个数组超界，那么直接break</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums1[i] &#x3D;&#x3D; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                S.insert(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;         </span><br><span class="line">            else if (nums1[i] &lt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums1[i] &gt; nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it &#x3D; S.begin(); it !&#x3D; S.end(); it++)&#x2F;&#x2F;将set中元素拷贝到vector中</span><br><span class="line">        &#123;</span><br><span class="line">            V.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        return V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br></pre></td></tr></table></figure>

<img src="/2020/02/13/leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/1.png" class="" title="[leetcode-两个数组的交集]">  
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>you-get批量下载视频</title>
    <url>/2020/02/05/you-get%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>今天在b站上看到了一个很喜欢的网课，怕被和谐，所以想下载下来，但网页端b站没有下载的渠道，使用其他的下载方式还需要下软件，所以又由csdn博客上了解到使用you-get第三方库可以非常轻松的下载b站视频(当然也支持很多其他视频平台)，所以使用一下，效果非常棒，(当然也有缺点，比如下载速度有些慢)不过可以批量下载，所以瑕不掩瑜吧。  </p>
<a id="more"></a>
<p><a href="https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E">官方详细中文文档</a><br>直接控制台输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install you-get</span><br></pre></td></tr></table></figure>
<p>即可安装成功  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">you-get --playlist  -o F:\bilibili https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av6731067</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\bilibili</span><br></pre></td></tr></table></figure>
<p>是下载到f盘bilibili文件夹下(需要先自行创建文件夹)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av6731067</span><br></pre></td></tr></table></figure>
<p>是视频的地址，这样后台就可以下载成功了。  </p>
<img src="/2020/02/05/you-get%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/1.png" class="" title="[you-get批量下载视频]">  

<img src="/2020/02/05/you-get%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/2.png" class="" title="[you-get批量下载视频]">  



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>下载视频</tag>
        <tag>python</tag>
        <tag>you-get</tag>
      </tags>
  </entry>
  <entry>
    <title>理解RESTful</title>
    <url>/2020/01/31/%E7%90%86%E8%A7%A3RESTful/</url>
    <content><![CDATA[<p>一、REST  </p>
<blockquote>
<p>REST：即 Representational State Transfer，（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便， 所以正得到越来越多网站的采用。</p>
</blockquote>
<p>具体说，就是 HTTP 协议里面，四个表示操作方式的动 词：<br>GET、POST、PUT、DELETE。<br>它们分别对应四种基本操作：<br>GET 用来获取资源<br>POST 用来新建资源<br>PUT 用来更新资源<br>DELETE 用来删除资源  </p>
<a id="more"></a>
<p>URL示例 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看ticket 12</span><br><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>


<p>二、幂等性<br>理解RESTful的幂等性，并且设计符合幂等规范的高质量RESTful API。</p>
<p>HTTP幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p>
<p>HTTP GET方法<br>HTTP GET方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     &#x2F;tickets       # 获取ticket列表</span><br><span class="line">GET     &#x2F;tickets&#x2F;12    # 查看ticket 12</span><br></pre></td></tr></table></figure>

<p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p>
<p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个HTTP GET方法可能会每次得到不同的返回内容，但并不影响资源。</p>
<p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET     &#x2F;service_time # 获取服务器当前时间</span><br></pre></td></tr></table></figure>

<p>它本身不会对资源本身产生影响，因此满足幂等性。</p>
<p>HTTP POST方法<br>HTTP POST方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST    &#x2F;tickets       # 新建一个ticket</span><br></pre></td></tr></table></figure>

<p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p>
<p>HTTP PUT方法<br>HTTP PUT方法是不是幂等的呢？我们来看下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT     &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p>
<p>HTTP PATCH方法<br>HTTP PATCH方法是非幂等的。HTTP POST方法和HTTP PUT方法可能比较好理解，但是HTTP PATCH方法只是更新部分资源，怎么是非幂等的呢? 我们举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATCH   &#x2F;tickets&#x2F;12    # 更新ticket 12</span><br></pre></td></tr></table></figure>

<p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条ticket记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p>
<p>HTTP DELETE方法<br>HTTP DELETE方法用于删除资源，会将资源删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE  &#x2F;tickets&#x2F;12    # 删除ticekt 12</span><br></pre></td></tr></table></figure>

<p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p>
<p>三、如何设计符合幂等性的高质量RESTful API<br>HTTP GET方法 vs HTTP POST方法<br>也许，你会想起一个面试题。HTTP请求的GET与POST方式有什么区别？你可能会回答到：GET方式通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。但是，我们现在从RESTful的资源角度来看待问题，HTTP GET方法是幂等的，所以它适合作为查询操作，HTTP POST方法是非幂等的，所以用来表示新增操作。</p>
<p>但是，也有例外，我们有的时候可能需要把查询方法改造成HTTP POST方法。比如，超长（1k）的GET URL使用POST方法来替代，因为GET受到URL长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p>
<p>HTTP POST方法 vs HTTP PUT方法<br>对于HTTP POST方法和HTTP PUT方法，我们一般的理解是POST表示创建资源，PUT表示更新资源。当然，这个是正确的理解。</p>
<p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST方法是非幂等，所以用来表示创建资源，HTTP PUT方法是幂等的，因此表示更新资源更加贴切。</p>
<p>HTTP PUT方法 vs HTTP PATCH方法<br>此时，你看会有另外一个问题。HTTP PUT方法和HTTP PATCH方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是PUT表示更新全部资源，PATCH表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH方法是非幂等的，因此我们在设计我们服务端的RESTful API的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用HTTP PUT方法。</p>
]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus实战-5</title>
    <url>/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-5/</url>
    <content><![CDATA[<p>sql性能分析插件：<br>在MyBatisPlusConfig中添加性能分析插件：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * SQL 执行性能分析插件</span><br><span class="line">     * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)&#x2F;&#x2F; 设置 dev test 环境开启</span><br><span class="line">    public PerformanceInterceptor performanceInterceptor() &#123;</span><br><span class="line">        PerformanceInterceptor performanceInterceptor &#x3D; new PerformanceInterceptor();</span><br><span class="line">        performanceInterceptor.setMaxTime(100);&#x2F;&#x2F;ms，超过此处设置的ms则sql不执行，抛出异常信息，提示优化程序</span><br><span class="line">        performanceInterceptor.setFormat(true);</span><br><span class="line">        return performanceInterceptor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在配置文件中设置dev环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#环境设置：dev、test、prod</span><br><span class="line">spring.profiles.active&#x3D;dev</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties</p>
</blockquote>
<p>测试CRUDTest中的插入操作：</p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-5/1.png" class="" title="[Mybatis-plus实战-5]">  
<p>若将setMaxTime的参数值改小为小于40的数，就会报错。</p>
<p>学完MyBatis-plus大体功能后，整个项目结构是这样的：</p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-5/2.png" class="" title="[Mybatis-plus实战-5]">  
]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus实战-4</title>
    <url>/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/</url>
    <content><![CDATA[<p>1.Delete<br>1.1 根据id删除记录  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteById()&#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteById(8L);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/1.jpg" class="" title="[Mybatis-plus实战-4]">  
<p>1.2 根据id批量删除记录  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteBatchIds() &#123;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; userMapper.deleteBatchIds(Arrays.asList(8, 9, 10));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/2.jpg" class="" title="[Mybatis-plus实战-4]">  
<p>1.3 使用map进行简单查询删除  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    简单条件删除：先组装hashmap，再使用deleteByMap方法进行删除</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testDeleteByMap() &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;name&quot;, &quot;Sandy&quot;);</span><br><span class="line">        map.put(&quot;age&quot;, 21);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.deleteByMap(map);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/3.jpg" class="" title="[Mybatis-plus实战-4]">  
<p><strong>1.4 逻辑删除</strong>  </p>
<blockquote>
<p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据<br>逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p>
</blockquote>
<p>(1)  逻辑删除即在表中新加一个逻辑字段deleted，类型是tinyint，长度为1，默认为0(新版mysql没有布尔类型，都是用一位长度的tinyint类型表示，默认为0表示没有被删除，1表示被删除了)<br>(2)  在实体类中加入以下字段  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@TableLogic</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>

<p>(3)在配置文件中添加以下字段  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#逻辑删除的配置</span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-value&#x3D;1</span><br><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value&#x3D;0</span><br></pre></td></tr></table></figure>

<p>在做删除操作时，mybatis-plus检测到有逻辑删除，那么就会自动的将删除操作更改为更新操作，并将deleted字段更新为1。<br>(4)在MyBatisPlusConfig类中注册逻辑删除插件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;逻辑删除插件</span><br><span class="line">    @Bean</span><br><span class="line">    public ISqlInjector sqlInjector() &#123;</span><br><span class="line">        return new LogicSqlInjector();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逻辑删除功能成功！现在开始测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 测试 逻辑删除</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testLogicDelete() &#123;</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.deleteById(5L);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>==测试后发现，数据并没有被删除，deleted字段的值由0变成了1<br>测试后分析打印的sql语句，是一条update<br>注意：被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作==  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/4.png" class="" title="[Mybatis-plus实战-4]">  
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/5.jpg" class="" title="[Mybatis-plus实战-4]">  

<p>逻辑查询测试：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 测试 逻辑删除后的查询：</span><br><span class="line">     * 不包括被逻辑删除的记录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testLogicDeleteSelect() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(null);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时查询将不会带有逻辑删除后的结果  </p>
<img src="/2020/01/30/Mybatis-plus%E5%AE%9E%E6%88%98-4/6.png" class="" title="[Mybatis-plus实战-4]">  




]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus实战-3</title>
    <url>/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/</url>
    <content><![CDATA[<p>1.Select<br>1.1根据id查询记录：  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectById()&#123;</span><br><span class="line"></span><br><span class="line">    User user &#x3D; userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/1.png" class="" title="[Mybatis-plus实战-3]">  
<p>1.2根据多个id查询记录：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectBatchIds()&#123;&#x2F;&#x2F;多个id查询</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectBatchIds(Arrays.asList(1, 2, 3));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/2.png" class="" title="[Mybatis-plus实战-3]">  
<p>1.3 使用map进行条件查询  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectByMap()&#123;&#x2F;&#x2F;使用map封装查询条件</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;name&quot;, &quot;Helen&quot;);</span><br><span class="line">        map.put(&quot;age&quot;, 18);</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectByMap(map);</span><br><span class="line"></span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/3.png" class="" title="[Mybatis-plus实战-3]">  
<blockquote>
<p>需要注意的一点是：map中的key对应==数据库中的列名==。如：数据库user_id，实体类是userId，这时map的key需要填写user_id</p>
</blockquote>
<p>使用map进行条件查询的<strong>缺点</strong>：只能精确匹配，无法查询大于小于等等。</p>
<p>1.4 分页插件<br>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能<br>在MyBatisPlusConfig中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">        return new PaginationInterceptor();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新建分页测试，其最终通过page对象获取相关数据：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectPage() &#123;</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(1,5);&#x2F;&#x2F;第一个参数:页码，第二个参数:每页的数量</span><br><span class="line">        userMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">        page.getRecords().forEach(System.out::println);</span><br><span class="line">        System.out.println(page.getCurrent());&#x2F;&#x2F;当前页码</span><br><span class="line">        System.out.println(page.getPages());&#x2F;&#x2F;总页数</span><br><span class="line">        System.out.println(page.getSize());&#x2F;&#x2F;每页记录数</span><br><span class="line">        System.out.println(page.getTotal());&#x2F;&#x2F;总记录数</span><br><span class="line">        System.out.println(page.hasNext());&#x2F;&#x2F;是否有下一页内容</span><br><span class="line">        System.out.println(page.hasPrevious());&#x2F;&#x2F;是否有上页内容</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/4.png" class="" title="[Mybatis-plus实战-3]">  
<p>1.5 分页使用map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectMapsPage() &#123;&#x2F;&#x2F;结果集是Map</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(1, 5);</span><br><span class="line"></span><br><span class="line">        IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage &#x3D; userMapper.selectMapsPage(page, null);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;注意：此行必须使用 mapIPage 获取记录列表，否则会有数据类型转换错误</span><br><span class="line">        mapIPage.getRecords().forEach(System.out::println);</span><br><span class="line">        System.out.println(page.getCurrent());</span><br><span class="line">        System.out.println(page.getPages());</span><br><span class="line">        System.out.println(page.getSize());</span><br><span class="line">        System.out.println(page.getTotal());</span><br><span class="line">        System.out.println(page.hasNext());</span><br><span class="line">        System.out.println(page.hasPrevious());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.6使用条件构造器进行查询</strong><br>1.6.1 wrapper介绍  </p>
<img src="/2020/01/29/Mybatis-plus%E5%AE%9E%E6%88%98-3/5.png" class="" title="[Mybatis-plus实战-3]">  
<p>创建一个新的测试类用于测试12种wrapper查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class QueryWrapperTests &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.6.2 12种常见语句(使用时字段均为数据库内字段)：<br>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    ge:greater and equals 大于等于</span><br><span class="line">    gt:greater than 大于</span><br><span class="line">    le:less and equals 小于等于</span><br><span class="line">    lt:less than 小于</span><br><span class="line">    isNull: 为空</span><br><span class="line">    isNotNull：不为空</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testDelete() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper</span><br><span class="line">                .isNull(&quot;name&quot;)</span><br><span class="line">                .ge(&quot;age&quot;, 12)</span><br><span class="line">                .isNotNull(&quot;email&quot;);</span><br><span class="line">        int result &#x3D; userMapper.delete(queryWrapper);</span><br><span class="line">        System.out.println(&quot;delete return count &#x3D; &quot; + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    eq:equals 等于</span><br><span class="line">    ne:not equals 不等于</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectOne() &#123;&#x2F;&#x2F;只能查询一条记录，多于一条便报错</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(&quot;name&quot;, &quot;Tom&quot;);</span><br><span class="line"></span><br><span class="line">        User user &#x3D; userMapper.selectOne(queryWrapper);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    between: 包括</span><br><span class="line">    notBetween ：不包括</span><br><span class="line">     *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">    public void testSelectCount() &#123;&#x2F;&#x2F;包括大小边界，即可以取到20和30</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.between(&quot;age&quot;, 20, 30);</span><br><span class="line"></span><br><span class="line">        Integer count &#x3D; userMapper.selectCount(queryWrapper);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;allEq: 所有条件都是等于的</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectList() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;id&quot;, 2);</span><br><span class="line">        map.put(&quot;name&quot;, &quot;Jack&quot;);</span><br><span class="line">        map.put(&quot;age&quot;, 20);</span><br><span class="line"></span><br><span class="line">        queryWrapper.allEq(map);</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>5.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    like: 包含</span><br><span class="line">    notLike: 不包含</span><br><span class="line">    likeLeft: 这个val左边模糊匹配(%val)</span><br><span class="line">    likeRight: 这个val右面模糊匹配(val%)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectMaps() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper</span><br><span class="line">                .notLike(&quot;name&quot;, &quot;e&quot;)</span><br><span class="line">                .likeRight(&quot;email&quot;, &quot;t&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; userMapper.selectMaps(queryWrapper);&#x2F;&#x2F;返回值是Map列表</span><br><span class="line">        maps.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>6.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    in: notIn(&quot;age&quot;,&#123;1,2,3&#125;)---&gt;age not in (1,2,3)</span><br><span class="line">    notIn: notIn(&quot;age&quot;, 1, 2, 3)---&gt;age not in (1,2,3)</span><br><span class="line">    inSql:子查询中包括 ：inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)---&gt;age in (1,2,3,4,5,6)；inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3)</span><br><span class="line">    notinSql: 子查询中不包括：</span><br><span class="line">    exists:</span><br><span class="line">    notExists:</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectObjs() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;queryWrapper.in(&quot;id&quot;, 1, 2, 3);</span><br><span class="line">        queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; objects &#x3D; userMapper.selectObjs(queryWrapper);&#x2F;&#x2F;返回值是Object列表</span><br><span class="line">        objects.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    不调用or则默认为使用 and ，</span><br><span class="line">    or表示或</span><br><span class="line">    and表示和</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testUpdate1() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改值</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setAge(99);</span><br><span class="line">        user.setName(&quot;Andy&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改条件</span><br><span class="line">        UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">        userUpdateWrapper</span><br><span class="line">                .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">                .or()</span><br><span class="line">                .between(&quot;age&quot;, 20, 30);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>8.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   使用lambda表达式进行嵌套or、嵌套and操作，跟testUpdate1类似，</span><br><span class="line">   当需要组装较为复杂的sql查询条件时，可以使用lambda表达式提升语句优先级，即可做到嵌套</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Test</span><br><span class="line">   public void testUpdate2() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;修改值</span><br><span class="line">       User user &#x3D; new User();</span><br><span class="line">       user.setAge(99);</span><br><span class="line">       user.setName(&quot;Andy&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;修改条件</span><br><span class="line">       UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">       userUpdateWrapper</span><br><span class="line">               .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">               .or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;age&quot;, 20));&#x2F;&#x2F;or里面有and</span><br><span class="line"></span><br><span class="line">       int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line"></span><br><span class="line">       System.out.println(result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>9.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    orderBy:</span><br><span class="line">    orderByDesc:查询结果倒序排列</span><br><span class="line">    orderByAsc:查询结果正序排列</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectListOrderBy() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByDesc(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>10.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接拼接到 sql 的最后，只能调用一次,多次调用以最后一次为准，谨慎使用，有sql注入风险</span><br><span class="line">&#x2F;&#x2F;在sql最后添加自定义代码片段</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectListLast() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.last(&quot;limit 1&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>11.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指定要查询的列,不需要展示表中所有的列</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectListColumn() &#123;</span><br><span class="line"></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>12.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为更新操作指定查询条件</span><br><span class="line">    @Test</span><br><span class="line">    public void testUpdateSet() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改值</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setAge(99);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改条件</span><br><span class="line">        UpdateWrapper&lt;User&gt; userUpdateWrapper &#x3D; new UpdateWrapper&lt;&gt;();</span><br><span class="line">        userUpdateWrapper</span><br><span class="line">                .like(&quot;name&quot;, &quot;h&quot;)</span><br><span class="line">                .set(&quot;name&quot;, &quot;老李头&quot;)&#x2F;&#x2F;除了可以查询还可以使用set设置修改的字段</span><br><span class="line">                .setSql(&quot; email &#x3D; &#39;123@qq.com&#39;&quot;);&#x2F;&#x2F;可以有子查询</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.update(user, userUpdateWrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus实战-2</title>
    <url>/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/</url>
    <content><![CDATA[<p><strong>实现CURD接口：</strong><br>1、Insert:<br>新建Insert测试类  </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class CRUDTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testInsert()&#123;</span><br><span class="line"></span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setName(&quot;Helen&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line">        user.setEmail(&quot;55317332@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">        int result &#x3D; userMapper.insert(user);</span><br><span class="line">        System.out.println(result); &#x2F;&#x2F;影响的行数</span><br><span class="line">        System.out.println(user); &#x2F;&#x2F;id自动回填</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入的id为19位  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/1.jpg" class="" title="[mybatis-plus实战-2]">
<p><em>1.1主键策略</em><br>MyBatis-Plus默认的主键策略是：ID_WORKER  全局唯一ID<br>参考资料：分布式系统唯一ID生成方案汇总：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a><br><em>1.2自增策略</em><br>实现主键自增，要进行如下配置  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/2.png" class="" title="[mybatis-plus实战-2]">
<p>如果想要想影响所有实体的配置，可以在配置文件中设置全局主键配置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局设置主键生成策略</span><br><span class="line">mybatis-plus.global-config.db-config.id-type&#x3D;auto</span><br></pre></td></tr></table></figure>

<p>主键配置的其他类型(通过源码可得)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum IdType &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 数据库ID自增</span><br><span class="line">     *&#x2F;</span><br><span class="line">    AUTO(0),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 该类型为未设置主键类型</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NONE(1),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用户输入ID</span><br><span class="line">     * 该类型可以通过自己注册自动填充插件进行填充</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INPUT(2),</span><br><span class="line"></span><br><span class="line">    &#x2F;* 以下3种类型、只有当插入对象ID 为空，才自动填充。 *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局唯一ID (idWorker)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ID_WORKER(3),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局唯一ID (UUID)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    UUID(4),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 字符串全局唯一ID (idWorker 的字符串表示)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ID_WORKER_STR(5);</span><br><span class="line"></span><br><span class="line">    private int key;</span><br><span class="line"></span><br><span class="line">    IdType(int key) &#123;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Update<br><em>2.1编写Update测试类–此时是根据id进行更新</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testUpdate() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setId(1222451509303422980L);&#x2F;&#x2F;设置要修改的id</span><br><span class="line"></span><br><span class="line">        user.setEmail(&quot;text@mail.com&quot;);&#x2F;&#x2F;设置要修改的内容</span><br><span class="line">        int result &#x3D; userMapper.updateById(user);&#x2F;&#x2F;result为影响的行数，传entity类型参数即user</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>2.2自动填充</em><br>例如创建时间和更新时间，这是每个表必须有的，但不需要我们手动填充，应配置并根据当时的时间自动填充。<br>为实体配置：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/3.png" class="" title="[mybatis-plus实战-2]">
<p>相关的类型如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum FieldFill &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认不处理</span><br><span class="line">     *&#x2F;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入填充字段</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INSERT,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 更新填充字段</span><br><span class="line">     *&#x2F;</span><br><span class="line">    UPDATE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插入和更新填充字段</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INSERT_UPDATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在包下创建Handler文件夹并创建MyMetaObjectHandler类继承MetaObjectHandler，重写其两个方法insertFill和updateFill  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;必须要写</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;&#x2F;&#x2F;插入时自动填充</span><br><span class="line">        System.out.println(&quot;插入时自动填充：-------&quot;);</span><br><span class="line">        this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);&#x2F;&#x2F;第一个字段必须是entity中的fieldName，并且第二个字段必须与第一个字段的类型一样</span><br><span class="line">        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;&#x2F;&#x2F;更新时自动填充</span><br><span class="line">        System.out.println(&quot;更新时自动填充：-------&quot;);</span><br><span class="line">        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别使用之前的InsertTest和UpdateTest测试，发现成功  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/4.jpg" class="" title="[mybatis-plus实战-2]">

<hr>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/5.jpg" class="" title="[mybatis-plus实战-2]">
<p><em>2.3乐观锁</em>  </p>
<blockquote>
<p>主要适用场景：当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新。分为四个步骤：<br>1.取出记录时，获取当前version：假设取出的version=1<br>2.更新时，带上这个version<br>3.执行更新时， set version = newVersion where version = oldVersion<br>4.如果version不对，就更新失败</p>
</blockquote>
<p>在数据库中新建version字段，类型为int，默认值是0  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/6.jpg" class="" title="[mybatis-plus实战-2]">
<p>在User类中新加属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Version</span><br><span class="line">    private Integer version;</span><br></pre></td></tr></table></figure>

<p>在包中新建一个文件夹config，里面建一个类MyBatisPlusConfig并配置乐观锁插件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span><br><span class="line">public class MyBatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;</span><br><span class="line">        return new OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乐观锁的测试  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 测试 乐观锁插件</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void testOptimisticLocker() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;必须要先查询，用于获取version的值</span><br><span class="line">        User user &#x3D; userMapper.selectById(1222451509303422980L);</span><br><span class="line">        &#x2F;&#x2F;修改数据</span><br><span class="line">        user.setName(&quot;Helen Yao&quot;);</span><br><span class="line">        user.setEmail(&quot;helen@qq.com&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行更新</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/7.png" class="" title="[mybatis-plus实战-2]">
<p>一共执行两个sql语句，注意第二个sql语句，后面的条件不光是id是否等于id，而且version是否等于oldversion<br>数据库内：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-2/8.jpg" class="" title="[mybatis-plus实战-2]">
<p>version以加一</p>
]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus实战-1</title>
    <url>/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/</url>
    <content><![CDATA[<p><strong>1、创建数据库</strong><br>mybatis_plus  </p>
<a id="more"></a>
<p><strong>2.创建User表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS user;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user</span><br><span class="line">(</span><br><span class="line">	id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,</span><br><span class="line">	name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,</span><br><span class="line">	age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,</span><br><span class="line">	email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,</span><br><span class="line">	PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM user;</span><br><span class="line"></span><br><span class="line">INSERT INTO user (id, name, age, email) VALUES</span><br><span class="line">(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),</span><br><span class="line">(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),</span><br><span class="line">(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),</span><br><span class="line">(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),</span><br><span class="line">(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);</span><br></pre></td></tr></table></figure>

<p>最后的表结构如下：  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/1.png" class="" title="[mybatis-plus实战-1]">
<p><strong>3、使用 Spring Initializr 快速初始化一个 Spring Boot 工程</strong><br>==Group：com.atguigu<br>Artifact：mybatis_plus<br>版本：2.0.7.RELEASE==<br>引入三个新依赖：<br>mybatis-plus-boot-starter、MySQL、lombok  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--mybatis-plus--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.0.5&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!--mysql--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--lombok用来简化实体类--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>别忘下载lombok插件。<br><strong>4、配置</strong>  </p>
<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/2.png" class="" title="[mybatis-plus实战-1]">  
<p><strong>5、编写</strong><br>新建entity文件夹后新建User类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建mapper文件夹后新建UserMapper接口  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动类中添加MapperScan注解，文件夹就是上面创建的文件夹目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span><br><span class="line">public class MybatisPlusApplication &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、测试</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class MybatisPlusApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectList() &#123;</span><br><span class="line">        System.out.println((&quot;----- selectAll method test ------&quot;));</span><br><span class="line">        &#x2F;&#x2F;UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper</span><br><span class="line">        &#x2F;&#x2F;所以不填写就是无任何条件</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(null);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/29/mybatis-plus%E5%AE%9E%E6%88%98-1/3.png" class="" title="[mybatis-plus实战-1]">  
<p>成功!</p>
]]></content>
      <categories>
        <category>MyBatis-plus</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>MyBatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战-第一章-Spring之旅-2</title>
    <url>/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/</url>
    <content><![CDATA[<p>继续上节内容：  </p>
<a id="more"></a>  
<p>2.容纳你的Bean<br>2.1 使用应用上下文  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/1.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>在基于Spring的应用中，应用对象生存于Spring容器中，且容器负责创建对象，装载它们，配置它们并管理整个生命周期，从生存到死亡。<br>Spring容器有多个容器实现：<br>==bean工厂==和==应用上下文==，bean工厂对大多数企业级开发太低级，所以主要讨论应用上下文。<br>下列是可能用得到的应用上下文：  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/2.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>可以使用上述方法加载bean。且上下文准备就绪后，可以调用上下文的getBean()方法从Spring容器中获取bean。<br>2.2 bean的生命周期<br>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用， 则由Java自动进行垃圾回收。 而Spring容器中的bean的生命周期相对复杂，大体如下图所示：  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/3.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>3.俯瞰Spring风景线  </p>
<img src="/2020/01/28/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85-2/4.png" class="" title="[Spring实战-第一章-Spring之旅-2]">   
<p>4.Spring新功能<br>没什么好说的，因为之前几个版本我也没学过，从Spring 4.0开始算起。<br>5.小结<br>Spring致力于简化企业级Java开发，促进代码的松散耦合。==成功的关键在于依赖注入和AOP==。DI是组装应用对象的一种方式，==借助这种方式对象无需知道依赖来自何处或者依赖的实现方式==。不同于自己获取依赖对象，对象会在运行期赋予它们所依赖的对象。依赖对象通常会通过接口了解所注入的对象，这样的话就能确保低耦合。<br>除了DI，我们还简单介绍了Spring对AOP的支持。AOP可以帮助应用将散落在各处的逻辑汇集于一处——切面。当Spring装配bean的时候，这些切面能够在运行期编织起来，这样就能非常有效地赋予bean新的行为。==DI和AOP是Spring框架最核心的部分。==</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战-第一章-Spring之旅</title>
    <url>/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p><strong><em>Spring之旅</em></strong><br>Spring是一个开源框架，用于简化Java企业级应用开发，并且可以使JAVA应用变得简单，可测试和松耦合。  </p>
<a id="more"></a>  
<p>本章内容：<br>1.激发POJO的潜能<br>1.1 Spring可以通过依赖注入使得普通的类变成Spring组件。  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/1.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>DamselRescuingKnight在构造函数中自行创建了RescueDamselQuest类，==这使得两个类耦合到了一起==，这样如果DamselRescuingKnight想要修改功能时RescueDamselQuest也需要改变，并且为其编写单元测试非常困难。  </p>
<blockquote>
<p>耦合具有两面性：一方面，紧密耦合的代码难以测试，难以服用，难以理解，并且表现出打地鼠式bug特性(修一个又出一个)；另一方面，一定程度的耦合是必须的，只要对于两个类想要交互，必须就有耦合。</p>
</blockquote>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/2.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/3.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>通过依赖注入，对象的依赖关系将由系统中负责协调个对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理他们的依赖关系，依赖关系奖杯自动注入到需要它们的对象当中去。</p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/4.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>这一次BraveKnight没有自行创建任务，而是在构造函数中传入参数来规定其任务是什么(Quest就是任务),这是依赖注入的方式之一，即构造器注入(Constructor Injection)  </p>
<blockquote>
<p>这种形式，大大降低耦合度，如果一个对象通过接口来表明依赖关系，那么这种依赖就能在对象不知情的情况下用不同的具体实现进行替换。  </p>
</blockquote>
<p>由上面的类，它现在可以接受任何我传递给他的Quest的实现，下面是把特定的Quest传送给它的办法:  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/5.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>SlayDragonQuest是要注入到BraveKnight的特定Quest实现，它实现了Quest接口，准备注入到BraveKnight。<br>创建应用组件之间协作的行为通常称为装配(wiring)，Spring有多重装备bean的方式，XML是其中一种也是最常见的一种，使用Spring配置文件便可以将其装配在一起。<br>==XML方式：==  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/6.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>==Java类方式：==  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/7.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>在具体工作时，Spring通过应用上下文(Application Context)装载bean的定义并把他们组装起来，<br>加载方式：  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/8.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>这里的main方法导入knights.xml并获取id为knight的bean，得到Knight对象的引用后，只需要简单调用该对象的embarkOnQuest方法即可，并且这个类完全不知道骑士要接受哪种探险任务，也没有意识到是由BraveKnight执行的。</p>
<p>1.2 应用切面：</p>
<blockquote>
<p>面向切面编程(Aspect-oriented programming,AOP)：系统由许多不同的组件构成，每个组件各负责一块特定功能，除了实现自身核心的功能之外，还需要承担着额外的职责(比如事务管理和安全这样的系统服务),但这会带来双重复杂性：</p>
</blockquote>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/9.png" class="" title="[Spring实战-第一章-Spring之旅]">   

<hr>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/10.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>但AOP能够使这些服务模块化，并以声明的形式将他们应用到他们需要影响到的组件中去。简单来说，AOP能够确保POJO(Plain Ordinary Java Object，简单JAVA对象)的简单性  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/11.png" class="" title="[Spring实战-第一章-Spring之旅]">   

<hr>
<p>举例说明：  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/12.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/13.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>Minstrel有两个类，分别在探险任务之前和之后调用，但是这样的话BraveKnight肯定要调用Minstrel，并且在他自己的方法中，但吟游诗人应该做他分内的事情，并不需要骑士提醒他这么做，并且这样做使BraveKnight的代码变得复杂。==解决的方法就是将Minstrel抽象为一个切面，只需在Spring配置文件中声明即可。==</p>
<hr>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/14.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>注意几个标签：<br>&lt;aop:aspect ref=”bean”&gt;引用bean<br>&lt;aop:pointcut &gt;定义切点<br>&lt;aop:before &gt;前置通知<br>&lt;aop:after &gt;后置通知<br>通过这样调用，Minstrel可以被应用到BraveKnight中，并且BraveKnight不需要显式地调用它，即BraveKnight根本不知道Minstrel的存在。<br>1.3 使用模板消除样板式代码  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/15.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>如图所示的样板式代码，最核心的查询员工数据代码只占很小一部分，因为都由创建数据库连接，创建语句对象，捕捉异常，关闭数据库连接，再捕捉异常所占满。  </p>
<img src="/2020/01/27/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85/16.png" class="" title="[Spring实战-第一章-Spring之旅]">   
<p>而使用Spring的JdbcTemplate重写的getEmployeeById()只关注查询员工数据的逻辑，这样大大减少了样板式代码的冗余。</p>
<p>第一章剩余内容：</p>
<p>2.容纳你的Bean<br>3.俯瞰Spring风景线<br>4.Spring新功能<br>5.小结  </p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>添加总站访问量和文章访问量</title>
    <url>/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/</url>
    <content><![CDATA[<p>1、配置是否开启不蒜子访问量统计功能<br>在<strong>themes/yilia/_config.yml</strong>添加属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否开启访问量统计功能(不蒜子)</span><br><span class="line">busuanzi:</span><br><span class="line"> enable: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<img src="/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/1.png" class="" title="[添加总站访问量和文章访问量]">
<p>2、引入不蒜子并添加站点访问量<br><strong>在themes/yilia/layout/_partial/footer.ejs</strong>对应位置(不能超过&lt;footer/)添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">                本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot; style&#x3D;&#39;display:none&#39;&gt;</span><br><span class="line">                本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/2.png" class="" title="[添加总站访问量和文章访问量]">
<p>3、添加文章访问量<br>在<strong>themes/yilia/layout/_partial/post/date.ejs</strong>开头添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_page_pv&quot; style&#x3D;&#39;display:none&#39; class&#x3D;&quot;&lt;%&#x3D; class_name %&gt;&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;icon-smile icon&quot;&gt;&lt;&#x2F;i&gt; 阅读数：&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/22/%E6%B7%BB%E5%8A%A0%E6%80%BB%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E5%92%8C%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F/3.png" class="" title="[添加总站访问量和文章访问量]">

<p>重启即可查看效果啦~</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>修改hexo博客代码块样式</title>
    <url>/2020/01/22/%E4%BF%AE%E6%94%B9hexo%E5%8D%9A%E5%AE%A2%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>直接修改编译好的文件。路径为： theme/yilia/source/main.0cf68a.css<br>修改代码背景色，搜索 .article-entry .highlight, 修改background后面的颜色</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pre&#123;background:#272822;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pre&#123;background:#1a0139;</span><br></pre></td></tr></table></figure>
<p>修改行号颜色，搜索 .article-entry .highlight .gutter pre .line<br>将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .gutter pre .line&#123;</span><br><span class="line">    color:#666</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .gutter pre .line&#123;</span><br><span class="line">      color:#fc0000</span><br></pre></td></tr></table></figure>
<p>修改代码字体颜色 .article-entry .highlight .line</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .line&#123;</span><br><span class="line">color:#fff;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-entry .highlight .line&#123;</span><br><span class="line">color:#00ff0d;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>由树的前序遍历和中序遍历推后序遍历&amp;&amp;由树的中序遍历和后序遍历推前序遍历</title>
    <url>/2020/01/22/%E7%94%B1%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E7%94%B1%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>假设树是酱婶的  </p>
<img src="/2020/01/22/%E7%94%B1%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E7%94%B1%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%8E%A8%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/1.png" class="" title="[由树的前序遍历和中序遍历推后序遍历&amp;&amp;由树的中序遍历和后序遍历推前序遍历]">  
<p>首先前序遍历为 123456，中序遍历为324165，没什么问题，如果不会求前序或中序百度一下就好</p>
<a id="more"></a>
<h2 id="1-由树的前序遍历和中序遍历推后序遍历"><a href="#1-由树的前序遍历和中序遍历推后序遍历" class="headerlink" title="1.由树的前序遍历和中序遍历推后序遍历"></a>1.由树的前序遍历和中序遍历推后序遍历</h2><p>定义函数原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postorder(int root,int start,int end)</span><br></pre></td></tr></table></figure>

<p>root是前序遍历中当前树的根节点索引（单看中序遍历找不到根节点，前序遍历就可以）<br>start为当前树在中序遍历中的起点索引<br>end为当前树在中序遍历中的终点索引<br><strong>所以函数入口为(0,0,5)</strong><br><strong>因为整个树的根节点在前序遍历的索引为0，整个树的起点在中序遍历中的起点为0，终点为最后一个点下标即5</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void postorder(int root, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	if (start &gt; end)&#x2F;&#x2F;如果左区间大于右区间，直接返回函数，当这个区间只有一个元素之后的下一个递归函数就是在这里弹出</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int rot &#x3D; preorder[root];&#x2F;&#x2F;当前根节点</span><br><span class="line">	int index;&#x2F;&#x2F;index找到inorder中对应根节点的索引</span><br><span class="line">	for (int i &#x3D; 0; i &lt; inorder.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (inorder[i] &#x3D;&#x3D; rot)</span><br><span class="line">		&#123;</span><br><span class="line">			index &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	post(root + 1, start, index - 1);&#x2F;&#x2F;递归左子树，root+1就是左子树的根节点在preorder中的索引</span><br><span class="line">	post(root + 1 + index -  start, index + 1, end);&#x2F;&#x2F;递归右子树，第一个参数中index-start是指左子树的个数，root+1+左子树的个数就是右子树的根节点在preorder中的索引</span><br><span class="line">	postorder.push_back(preorder[root]);&#x2F;&#x2F;将当前根节点放入postorder中（后序遍历是左右根的顺序）</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：preorder，inorder，postorder分别是前序遍历，中序遍历和后序遍历的向量。</em></strong></p>
<h2 id="2-由树的中序遍历和后序遍历推前序遍历"><a href="#2-由树的中序遍历和后序遍历推前序遍历" class="headerlink" title="2.由树的中序遍历和后序遍历推前序遍历"></a>2.由树的中序遍历和后序遍历推前序遍历</h2><p>基本思想跟上述一样，只不过根节点每次都是从后序遍历中从后往前找（1中是从前序遍历中从前往后找，所以总的函数基本一样，只不过后面递归函数参数以及将当前根节点放入向量中的顺序不太一样）<br><strong>函数入口为(5,0,5)</strong><br><strong>因为整个树的根节点在后序遍历的索引为5（后序遍历最后一个值），整个树的起点在中序遍历中的起点为0，终点为最后一个点下标即5</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void preorder(int root, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	if (start &gt; end)&#x2F;&#x2F;如果左区间大于右区间，直接返回函数，当这个区间只有一个元素之后的下一个递归函数就是在这里弹出</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int rot &#x3D; postorder[root];&#x2F;&#x2F;当前根节点</span><br><span class="line">	int index;&#x2F;&#x2F;index找到inorder中对应根节点的索引</span><br><span class="line">	for (int i &#x3D; 0; i &lt; inorder.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (inorder[i] &#x3D;&#x3D; rot)</span><br><span class="line">		&#123;</span><br><span class="line">			index &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	preorder.push_back(postorder[root]);&#x2F;&#x2F;将当前根节点放入preorder中（后序遍历是根左右的顺序）</span><br><span class="line">	post(root-(end-index)-1, start, index - 1);&#x2F;&#x2F;递归左子树，第一个参数中end-index是指右子树的个数，root-右子树的个数-1就是左子树的根节点在preorder中的索引	</span><br><span class="line">	post(root-1, index + 1, end);&#x2F;&#x2F;递归右子树，root-1就是右子树的根节点在preorder中的索引</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：preorder，inorder，postorder仍然分别是前序遍历，中序遍历和后序遍历的向量。</em></strong><br>其次，最难的部分就是函数中第一个参数，只要找准左子树跟右子树的根节点索引即可<br>因为前序遍历是根左右，所以左子树的根节点是root+sth（这里是加号）<br>因为后序遍历是左右根，所以得左右子树根节点时是root-sth（这里是减号）<br><strong>同时注意:前序遍历中root+1先得到的是左子树根节点（因为是根左右），其次加上右子树的个数就是右子树根节点。而后序遍历中root-1先得到的是右子树根节点（因为是左右根），其次减上左子树的个数就是左子树根节点。</strong>  </p>
<p>成了，以上就是简单模式下的由树的前序遍历和中序遍历推后序遍历&amp;&amp;由树的中序遍历和后序遍历推前序遍历，简单模式下假定树的所有节点的值都是不相同的，所以困难模式下还有树中有相等的值，此时会有一些变式，有时间我会在写下来。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的基本操作（数据结构）</title>
    <url>/2020/01/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<p>看了很多博客许多大牛的文章，发现他们的方法即巧妙又简便，果断学习并理解。结合所学的知识，把二叉树的基本操作罗列了下来。<br>废话不多说，直接上源码，一些不容易理解的地方会有注释，要是有问题也可以私信我QQ``:790567648交个朋友互相学习鸭~</p>
<a id="more"></a>
<p><strong>———头文件，宏定义以及树ADT的实现**</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;头文件</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;宏定义</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">&#x2F;&#x2F;ADT</span><br><span class="line">typedef int TElemType;</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef struct BiTNode              &#x2F;&#x2F;定义二叉树节点数据类型 </span><br><span class="line">&#123;</span><br><span class="line">	TElemType data;</span><br><span class="line">	struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;           &#x2F;&#x2F;bitree为指向bitnode这种结构的指针</span><br></pre></td></tr></table></figure>
<p><strong>———-基本操作的声明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BiTree CreateTree();&#x2F;&#x2F;按先序次序输入二叉树中结点的值（一个字符）空格字符表示空数</span><br><span class="line">Status PreOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;先序遍历二叉树T,对每个结点调用函数VIsit一次且仅一次</span><br><span class="line">Status InOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;中序。。。</span><br><span class="line">Status PostOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;后序。。。</span><br><span class="line">Status LevelOrderTraverse(BiTree T, Status(*Visit)(TElemType e));&#x2F;&#x2F;层序。。。</span><br><span class="line">Status Deepth(BiTree T);&#x2F;&#x2F;求树的高度</span><br><span class="line">Status PreorderPrintLeaves(BiTree BT);&#x2F;&#x2F;先序输出树的结点</span><br></pre></td></tr></table></figure>
<p><strong>———-具体的函数的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BiTree CreateTree()&#x2F;&#x2F;二叉树的建立</span><br><span class="line">&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	TElemType item;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;item);</span><br><span class="line">	if (item &#x3D;&#x3D; 0)              &#x2F;&#x2F;叶节点数据标志：其后根两个0 </span><br><span class="line">		T &#x3D; NULL;            &#x2F;&#x2F;若某一节点为叶子结点，则其左右子树均为NULL，0表示建空树</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		T &#x3D; (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">		T-&gt;data &#x3D; item;</span><br><span class="line">		T-&gt;lchild &#x3D; CreateTree();             &#x2F;&#x2F;递归创建其左子树 </span><br><span class="line">		T-&gt;rchild &#x3D; CreateTree();            &#x2F;&#x2F;递归创建其右子树 </span><br><span class="line">	&#125;</span><br><span class="line">	return T;                              &#x2F;&#x2F;返回根节点 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PrintElement(TElemType e)&#x2F;&#x2F;应用函数具体实现</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;%d &quot;, e);</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PreOrderTraverse1(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;先序遍历递归</span><br><span class="line">&#123;</span><br><span class="line">	if (T)</span><br><span class="line">	&#123;</span><br><span class="line">		if (Visit(T-&gt;data))</span><br><span class="line">			if (PreOrderTraverse1(T-&gt;lchild, Visit))</span><br><span class="line">				if (PreOrderTraverse1(T-&gt;rchild, Visit))</span><br><span class="line">					return OK;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status InOrderTraverse1(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;中序遍历递归</span><br><span class="line">&#123;</span><br><span class="line">	if (T)</span><br><span class="line">	&#123;</span><br><span class="line">		if (PreOrderTraverse1(T-&gt;lchild, Visit))</span><br><span class="line">			if (Visit(T-&gt;data))</span><br><span class="line">				if (PreOrderTraverse1(T-&gt;rchild, Visit))</span><br><span class="line">					return OK;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PostOrderTraverse1(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;后序遍历递归</span><br><span class="line">&#123;</span><br><span class="line">	if (T)</span><br><span class="line">	&#123;</span><br><span class="line">		if (PreOrderTraverse1(T-&gt;lchild, Visit))</span><br><span class="line">			if (PreOrderTraverse1(T-&gt;rchild, Visit))</span><br><span class="line">				if (Visit(T-&gt;data))</span><br><span class="line">					return OK;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status PreOrderTraverse2(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;先序遍历非递归</span><br><span class="line">&#123;	</span><br><span class="line">	BiTree P &#x3D; T;</span><br><span class="line">	stack&lt;BiTree&gt;S;</span><br><span class="line">	while (P!&#x3D;NULL||!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		while (P!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			Visit(P-&gt;data);</span><br><span class="line">			S.push(P);</span><br><span class="line">			P &#x3D; P-&gt;lchild;</span><br><span class="line">		&#125;	</span><br><span class="line">	if (!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		P&#x3D;S.top();</span><br><span class="line">		S.pop();</span><br><span class="line">		P &#x3D; P-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status InOrderTraverse2(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;中序遍历非递归</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;BiTree&gt;S;</span><br><span class="line">	BiTree P &#x3D; T;</span><br><span class="line">	while (P!&#x3D;NULL||!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		while (P!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			S.push(P);</span><br><span class="line">			P &#x3D; P-&gt;lchild;			</span><br><span class="line">		&#125;</span><br><span class="line">		if (!S.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			P &#x3D; S.top();</span><br><span class="line">			S.pop();</span><br><span class="line">			Visit(P-&gt;data);		</span><br><span class="line">			P&#x3D;P-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PostOrderTraverse2(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;后序遍历非递归</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;BiTree&gt;S;</span><br><span class="line">	BiTNode *cur;&#x2F;&#x2F;当前结点</span><br><span class="line">	BiTNode *ptr&#x3D;NULL;&#x2F;&#x2F;之前访问的结点</span><br><span class="line">	S.push(T);</span><br><span class="line">	while (!S.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		cur &#x3D; S.top();</span><br><span class="line">		if ((cur-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;cur-&gt;rchild&#x3D;&#x3D;NULL)||(ptr!&#x3D;NULL&amp;&amp;(ptr&#x3D;&#x3D;cur-&gt;lchild||ptr&#x3D;&#x3D;cur-&gt;rchild)))</span><br><span class="line">		&#123;</span><br><span class="line">			Visit(cur-&gt;data);</span><br><span class="line">			S.pop();</span><br><span class="line">			ptr &#x3D; cur;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (cur-&gt;rchild!&#x3D;NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				S.push(cur-&gt;rchild);</span><br><span class="line">			&#125;</span><br><span class="line">			if (cur-&gt;lchild!&#x3D;NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				S.push(cur-&gt;lchild);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status LevelOrderTraverse(BiTree T, Status(*Visit)(TElemType e))&#x2F;&#x2F;层序遍历二叉树(借助于队列)</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;BiTree&gt;Q;</span><br><span class="line">	BiTree P &#x3D; T;</span><br><span class="line">	Q.push(P);</span><br><span class="line">	while (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		BiTree temp &#x3D; Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		Visit(temp-&gt;data);		</span><br><span class="line">		if (temp-&gt;lchild!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			Q.push(temp-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp-&gt;rchild!&#x3D;NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			Q.push(temp-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status LevelOrderTraverse(BiTree T)&#x2F;&#x2F; 二叉树的层序遍历(数组实现)</span><br><span class="line">&#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) return ERROR;</span><br><span class="line"></span><br><span class="line">	BiTree q[MAXSIZE];&#x2F;&#x2F;树中最大的结点数为10.</span><br><span class="line">	q[0] &#x3D; T;</span><br><span class="line"></span><br><span class="line">	int front &#x3D; 0;</span><br><span class="line">	int rear &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	while (front&lt;rear)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;,q[front]-&gt;data);</span><br><span class="line">		if (q[front]-&gt;lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			q[rear] &#x3D; q[front]-&gt;lchild;</span><br><span class="line">			rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (q[front]-&gt;rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			q[rear] &#x3D; q[front]-&gt;rchild;</span><br><span class="line">			rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		front++;&#x2F;&#x2F;最后跳出循环的条件为front&#x3D;rear</span><br><span class="line">		&#x2F;&#x2F;rear为除了根节点以外所有结点的总数，front为算上根节点的所有结点总数，遍历所有结点后rear&#x3D;front</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Deepth(BiTree T)&#x2F;&#x2F;求树的高度</span><br><span class="line">&#123;</span><br><span class="line">	int deepthLeft &#x3D; 0;</span><br><span class="line">	int deepthRight &#x3D; 0;</span><br><span class="line">	int deepCount &#x3D; 0;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		deepCount &#x3D; 0;</span><br><span class="line">		return deepCount;</span><br><span class="line">	&#125;	</span><br><span class="line">	deepthLeft &#x3D; Deepth(T-&gt;lchild);</span><br><span class="line">	deepthRight &#x3D; Deepth(T-&gt;rchild);</span><br><span class="line">	deepCount &#x3D; 1 + ((deepthLeft &gt; deepthRight) ? deepthLeft : deepthRight);&#x2F;&#x2F;在左子树和右子树中求最高的那棵树，总树高为其加1</span><br><span class="line">	return deepCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status PreorderPrintLeaves(BiTree BT)&#x2F;&#x2F;先序输出树的结点</span><br><span class="line">&#123;</span><br><span class="line">	if (BT &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (BT-&gt;lchild &#x3D;&#x3D; NULL&amp;&amp;BT-&gt;rchild &#x3D;&#x3D; NULL) printf(&quot;%d &quot;, BT-&gt;data);</span><br><span class="line">		PreorderPrintLeaves(BT-&gt;lchild);</span><br><span class="line">		PreorderPrintLeaves(BT-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>———–随便写了一下主函数，，，都用的非递归的遍历，，，觉得递归的遍历时间复杂度太高了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	printf(&quot;请输入数据先序创建一棵二叉树:(结点为空时输入0)\n&quot;);</span><br><span class="line">	T &#x3D; CreateTree();               &#x2F;&#x2F;先序创建一棵二叉树 </span><br><span class="line">	printf(&quot;先序遍历结果为：\n&quot;);</span><br><span class="line">	PreOrderTraverse2(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;中序遍历结果为：\n&quot;);</span><br><span class="line">	InOrderTraverse2(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;后序遍历结果为：\n&quot;);</span><br><span class="line">	PostOrderTraverse2(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;层序遍历结果为：\n&quot;);</span><br><span class="line">	LevelOrderTraverse(T);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	LevelOrderTraverse(T, PrintElement);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;此树的高度为:\n&quot;);</span><br><span class="line">	printf(&quot;%d\n&quot;, Deepth(T));</span><br><span class="line">	printf(&quot;其树结点为:(先序)\n&quot;);</span><br><span class="line">	PreorderPrintLeaves(T);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也算是我对数据结构二叉树这一章的总结吧，记录一下自己的学习历程！冲鸭！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表和双向链表基本操作的实现（数据结构 C语言实现版)</title>
    <url>/2020/01/22/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%89%88/</url>
    <content><![CDATA[<p>大家吼我又来了，今天我给大家带来的是单向链表和双向链表的基本操作（基本上挺全的。。。）<br>    <strong>数据结构</strong>这门课程是学计算机的学生们感觉很重要很困难的学科。而链表也基本上算是数据结构刚入门时所写的了吧。<br>    我把自己学习数据结构的历程分享到自己的博客里，供大家学习也供我自己查阅自己的学习历程。若是感觉还不错或者有任何问题的话，欢迎加我的qq：790567648来跟我进一步的交流。hhh<br>    话不多说，我先上代码为敬，（基本上操作内我都写上注释了，再有什么看不懂的地方可以私信我聊）</p>
<a id="more"></a>
<p><strong>单向链表的基本操作实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-------老规矩，头文件，宏定义以及ADT和基本数据操作的声明</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;Node, *List;</span><br><span class="line"></span><br><span class="line">List InitList();&#x2F;&#x2F;带头结点的链表的建立</span><br><span class="line">int Listlength(List L);&#x2F;&#x2F;求链表的长度</span><br><span class="line">void ListInsert(List L, int i, ElemType e);&#x2F;&#x2F;在L中第i个位置之后插入一个结点的数值为e</span><br><span class="line">void ListDelete(List L, int i);&#x2F;&#x2F;链表第i个结点的删除</span><br><span class="line">int GetElemtype(List L, int i);&#x2F;&#x2F; 返回L中第i个位置的数据元素的值</span><br><span class="line">void GetElem(List L, ElemType e);&#x2F;&#x2F;查找在链表中是否有e这个元素，有的话返回它在链表中的位置，没有的话显示无</span><br><span class="line">void ListCleaner(List L);&#x2F;&#x2F;链表的清除</span><br><span class="line">void print(List L);&#x2F;&#x2F;链表的输出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List InitList()&#x2F;&#x2F;带头结点的链表的建立（需要参数和不需要参数同理）</span><br><span class="line">&#123;</span><br><span class="line">	Node *last;&#x2F;&#x2F;p为插入结点，last始终指向末节点;</span><br><span class="line">	List L;</span><br><span class="line">	L &#x3D; (Node *)malloc(sizeof(Node));</span><br><span class="line">	L-&gt;next &#x3D;&#x3D; NULL;</span><br><span class="line">	last &#x3D; L;</span><br><span class="line">	ElemType elem;</span><br><span class="line">	printf(&quot;已为您创建链表，请输入每个元素的值（以空格隔开并且以-1为结尾且不计入链表之中）\n&quot;);</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;elem) &amp;&amp; elem !&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *p;</span><br><span class="line">		p &#x3D; (Node *)malloc(sizeof(Node));</span><br><span class="line">		p-&gt;data &#x3D; elem;</span><br><span class="line">		last-&gt;next &#x3D; p;</span><br><span class="line">		last &#x3D; p;</span><br><span class="line">	&#125;</span><br><span class="line">	last-&gt;next &#x3D; NULL;</span><br><span class="line">	printf(&quot;链表以创建成功！\n&quot;);</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line">int Listlength(L)&#x2F;&#x2F;求链表的长度</span><br><span class="line">&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	int temp &#x3D; 0;</span><br><span class="line">	while (p-&gt;next !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		temp++;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void ListInsert(List L, int i, ElemType e)&#x2F;&#x2F;在L中第i个位置之后插入一个结点的数值为e</span><br><span class="line">&#123;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	Node *p, *temp;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	while (j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	temp &#x3D; (Node *)malloc(sizeof(Node));&#x2F;&#x2F;新建一个结点</span><br><span class="line">	temp-&gt;data &#x3D; e;</span><br><span class="line">	temp-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void print(List L)&#x2F;&#x2F;链表的输出</span><br><span class="line">&#123;</span><br><span class="line">	List tempList;</span><br><span class="line">	tempList &#x3D; L-&gt;next;</span><br><span class="line">	while (tempList)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, tempList-&gt;data);</span><br><span class="line">		tempList &#x3D; tempList-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ListDelete(List L, int i)&#x2F;&#x2F;链表第i个结点的删除</span><br><span class="line">&#123;</span><br><span class="line">	if (i&lt;1 || i&gt;Listlength(L) + 1)</span><br><span class="line">	&#123;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	Node *p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	while (p&amp;&amp;j &lt; i - 1)&#x2F;&#x2F;找到第i个位置前的结点</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next &#x3D; p-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">int GetElemtype(List L, int Position)&#x2F;&#x2F; 返回L中第i个数据元素的值</span><br><span class="line">&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; Position; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListCleaner(List L)&#x2F;&#x2F;链表的清除</span><br><span class="line">&#123;</span><br><span class="line">	List p &#x3D; NULL, q &#x3D; NULL;&#x2F;&#x2F;让p指向当前要删除的结点，q指向p之后的结点，等p释放空间后再重复上述操作</span><br><span class="line">	p &#x3D; L-&gt;next;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		q &#x3D; p-&gt;next;</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; q;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next &#x3D; NULL;</span><br><span class="line">	printf(&quot;链表已经清除！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void GetElem(List L, ElemType e)&#x2F;&#x2F;查找在链表中是否有e这个元素，有的话返回它在链表中的位置</span><br><span class="line">&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	int temp &#x3D; 0;</span><br><span class="line">	p &#x3D; L-&gt;next;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		temp++;</span><br><span class="line">		if (p-&gt;data &#x3D;&#x3D; e)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;结果：该元素在第%d个位置\n&quot;, temp);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;结果：未找到相关元素！\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己写的main函数，大家看看就好，，，，不必当真（QAQ我知道看到这里大佬要开始吐槽我了，手下留情）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int n, i, e;</span><br><span class="line">	List L;</span><br><span class="line">	L &#x3D; InitList();</span><br><span class="line">	printf(&quot;链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line">	printf(&quot;此时，链表的元素为：&quot;);</span><br><span class="line">	print(L);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;请输入需要插入的位置以及元素：&quot;);</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;i, &amp;e);</span><br><span class="line">	ListInsert(L, i, e);</span><br><span class="line">	printf(&quot;此时，链表的元素为：&quot;);</span><br><span class="line">	print(L);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;此时链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line"></span><br><span class="line">	int deletenum;</span><br><span class="line">	printf(&quot;请输入要删除的元素的位置为：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;deletenum);</span><br><span class="line">	ListDelete(L, deletenum);</span><br><span class="line">	printf(&quot;此时，链表的元素为：&quot;);</span><br><span class="line">	print(L);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;此时，链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line"></span><br><span class="line">	int test;</span><br><span class="line">	printf(&quot;请输入要查询第几个位置的元素：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;test);</span><br><span class="line">	printf(&quot;该位置的元素为：%d\n&quot;, GetElemtype(L, test));</span><br><span class="line"></span><br><span class="line">	int temp;</span><br><span class="line">	printf(&quot;请输入此元素来查询该链表中是否有该元素：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">	GetElem(L, temp);</span><br><span class="line"></span><br><span class="line">	printf(&quot;正在进行清空操作，请稍候。。。\n&quot;);</span><br><span class="line">	ListCleaner(L);</span><br><span class="line">	printf(&quot;此时，链表的长度为：%d\n&quot;, Listlength(L));</span><br><span class="line">	</span><br><span class="line">	printf(&quot;恭喜您以完成全部操作！\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双向链表的基本操作实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct DuLNode &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct DuLNode *prior;</span><br><span class="line">	struct DuLNode *next;</span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br><span class="line"></span><br><span class="line">DuLinkList InitList();&#x2F;&#x2F;带头结点的链表的建立</span><br><span class="line">int Listlength(DuLinkList L);&#x2F;&#x2F;求链表的长度</span><br><span class="line">void ListInsert(DuLinkList L, int i, ElemType e);&#x2F;&#x2F;在L中第i个位置之后插入一个结点的数值为e</span><br><span class="line">void ListDelete(DuLinkList L, int i);&#x2F;&#x2F;链表第i个结点的删除</span><br><span class="line">int GetElemtype(DuLinkList L, int i);&#x2F;&#x2F; 返回L中第i个位置的数据元素的值</span><br><span class="line">void GetElem(DuLinkList L, ElemType e);&#x2F;&#x2F;查找在链表中是否有e这个元素，有的话返回它在链表中的位置，没有的话显示无</span><br><span class="line">void ListCleaner(DuLinkList L);&#x2F;&#x2F;链表的清除</span><br><span class="line">void print(DuLinkList L);&#x2F;&#x2F;链表的输出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DuLinkList InitList()</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList L,Last;</span><br><span class="line">	L &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">	L-&gt;prior &#x3D; NULL;</span><br><span class="line">	L-&gt;next &#x3D; NULL;</span><br><span class="line">	Last &#x3D; L;&#x2F;&#x2F;last一直指向链表的最后一个元素，便于循环内部的初始化链表的值</span><br><span class="line">	int data;</span><br><span class="line">	printf(&quot;请输入双向链表的值:(以空格为间隔，结尾为-1且不算在链表中)&quot;);</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;data)&amp;&amp;data!&#x3D;-1)&#x2F;&#x2F;出现-1则跳出循环，-1不在链表之内</span><br><span class="line">	&#123;</span><br><span class="line">		DuLNode *p &#x3D; (DuLNode *)malloc(sizeof(DuLNode));</span><br><span class="line">		p-&gt;data &#x3D; data;</span><br><span class="line">		Last-&gt;next&#x3D;p;</span><br><span class="line">		p-&gt;prior &#x3D; Last;</span><br><span class="line">		p-&gt;next &#x3D; NULL;</span><br><span class="line">		Last &#x3D; p;</span><br><span class="line">	&#125;</span><br><span class="line">	Last-&gt;next &#x3D; NULL;&#x2F;&#x2F;最后last指向最后一个有效的结点p，使其的next指向NULL</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Listlength(DuLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p;</span><br><span class="line">	p &#x3D; L;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	while (p-&gt;next)&#x2F;&#x2F;若p-&gt;next不空，则temp++，temp即为链表的长度</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		length++;</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetElemtype(DuLinkList L, int i)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p &#x3D; L;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	if (L&#x3D;NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		while (p-&gt;next&amp;&amp;j &lt; i)&#x2F;&#x2F;找到第i个元素所在的位置</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;&#x2F;&#x2F;跳出循环时p当前的位置即为第i个元素所在的位置(判断并输出的条件是j&#x3D;&#x3D;i)</span><br><span class="line">		if (j&#x3D;&#x3D;i)</span><br><span class="line">		&#123;</span><br><span class="line">			return p-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetElem(DuLinkList L, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p &#x3D; L;</span><br><span class="line">	int temp &#x3D; 0;</span><br><span class="line">	while (p-&gt;next)&#x2F;&#x2F;p-&gt;next若不空，则继续进行遍历，知道找到p</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		temp++;</span><br><span class="line">		if (p-&gt;data&#x3D;&#x3D;e)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;存在该元素，且它的位置在链表的第%d个位置上\n&quot;, temp);</span><br><span class="line">			temp &#x3D; -1;&#x2F;&#x2F;若元素在最后一个位置上，则下面的话也会输出，所以改变temp的值，使其跳出循环时不会被下面的判断句所接收</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (temp&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;该链表中不存在该元素！\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListCleaner(DuLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p;</span><br><span class="line">	p &#x3D; L-&gt;next;&#x2F;&#x2F;L为头结点，所以p要指向链表中第一个有效的结点即头结点的next</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		L-&gt;next &#x3D; p-&gt;next;&#x2F;&#x2F;将L-&gt;next指向p-&gt;next，便于删除p时影响链表的结构</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; L-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;链表已清除完毕！\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(DuLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">	int i &#x3D; 1;</span><br><span class="line">	DuLinkList p &#x3D; L-&gt;next;</span><br><span class="line">	while (p)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;链表的第%d个元素为：%d\n&quot;, i, p-&gt;data);</span><br><span class="line">		i++;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListInsert(DuLinkList L, int i, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	DuLinkList p &#x3D; L-&gt;next;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	if (i&lt;0||i&gt;Listlength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;所插入的位置不存在！\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		while (p&amp;&amp;j &lt; i - 1)&#x2F;&#x2F;找到p为所要插入的位置(即i之后的位置)</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i&#x3D;&#x3D;0)&#x2F;&#x2F;想在头结点之后插入元素时</span><br><span class="line">		&#123;</span><br><span class="line">			DuLinkList inserted;</span><br><span class="line">			inserted &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">			&#x2F;&#x2F;四步走，把四个线连起来</span><br><span class="line">			inserted-&gt;data &#x3D; e;</span><br><span class="line">			L-&gt;next &#x3D; inserted;</span><br><span class="line">			inserted-&gt;prior &#x3D; L;</span><br><span class="line">			inserted-&gt;next &#x3D; p;</span><br><span class="line">			p-&gt;prior &#x3D; inserted;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (p-&gt;next)&#x2F;&#x2F;i&gt;0&amp;&amp;p之后还有结点时</span><br><span class="line">		&#123;</span><br><span class="line">			DuLinkList inserted;</span><br><span class="line">			inserted &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">			inserted-&gt;data &#x3D; e;</span><br><span class="line">			&#x2F;&#x2F;四步走，把四个线连起来</span><br><span class="line">			inserted-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">			p-&gt;next-&gt;prior &#x3D; inserted;</span><br><span class="line">			p-&gt;next &#x3D; inserted;</span><br><span class="line">			inserted-&gt;prior &#x3D; p;</span><br><span class="line">			printf(&quot;插入成功！\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;i&gt;0&amp;&amp;p为链表最后一个结点时</span><br><span class="line">			DuLinkList inserted;</span><br><span class="line">			inserted &#x3D; (DuLinkList)malloc(sizeof(DuLinkList));</span><br><span class="line">			inserted-&gt;data &#x3D; e;</span><br><span class="line">			&#x2F;&#x2F;三步走</span><br><span class="line">			p-&gt;next &#x3D; inserted;</span><br><span class="line">			inserted-&gt;prior &#x3D; p;</span><br><span class="line">			inserted-&gt;next &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListDelete(DuLinkList L, int i)</span><br><span class="line">&#123;</span><br><span class="line">	if (i&lt;0||i&gt;Listlength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;位置不存在！\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		int j &#x3D; 0;</span><br><span class="line">		DuLinkList p &#x3D; L-&gt;next;&#x2F;&#x2F;L为头结点，所以p要指向链表中第一个有效的结点即头结点的next</span><br><span class="line">		&#x2F;&#x2F;先找到被删除结点的位置</span><br><span class="line">		while (p&amp;&amp;j &lt; i - 1)</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (p-&gt;next)&#x2F;&#x2F;p的next后还有结点时</span><br><span class="line">		&#123;&#x2F;&#x2F;两步走</span><br><span class="line">			p-&gt;next-&gt;prior &#x3D; p-&gt;prior;</span><br><span class="line">			p-&gt;prior-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;p为链表最后一个元素</span><br><span class="line">			p-&gt;prior-&gt;next &#x3D; NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;双向链表的定义及初始化</span><br><span class="line">	DuLinkList L;</span><br><span class="line">	L &#x3D; InitList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;求链表的长度</span><br><span class="line">	printf(&quot;该链表的长度为;%d\n&quot;, Listlength(L));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;&#x2F;&#x2F;求链表的第i个位置上的元素</span><br><span class="line">	int temp;</span><br><span class="line">	printf(&quot;请输入想要知道的第几个位置：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">	printf(&quot;该位置上的数为:%d\n&quot;, GetElemtype(L, temp));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;求链表是否存在元素的某个值</span><br><span class="line">	printf(&quot;请输入想知道链表中是否存在该元素的值：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">	GetElem(L, temp);</span><br><span class="line">	&#x2F;&#x2F;遍历输出链表的元素</span><br><span class="line">	print(L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;在链表中指定位置后插入元素</span><br><span class="line">	printf(&quot;输入你想在第几个位置之后插入元素:&quot;);</span><br><span class="line">	int yuansu, weizhi;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;weizhi);</span><br><span class="line">	printf(&quot;输入你想插入元素的值:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;yuansu);</span><br><span class="line">	ListInsert(L, weizhi, yuansu);</span><br><span class="line">	&#x2F;&#x2F;遍历</span><br><span class="line">	print(L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;在链表中指定位置删除元素</span><br><span class="line">	printf(&quot;输入你想删除的结点在链表中的位置:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;weizhi);</span><br><span class="line">	ListDelete(L, weizhi);</span><br><span class="line">	&#x2F;&#x2F;遍历</span><br><span class="line">	print(L);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;选择是否进行摧毁链表操作</span><br><span class="line">	printf(&quot;是否选择进行摧毁链表操作，1是确定，2是不进行：&quot;);</span><br><span class="line">	int boolean;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;boolean);	</span><br><span class="line">	if (boolean&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;链表正在删除当中。。。\n&quot;);</span><br><span class="line">		ListCleaner(L);</span><br><span class="line">		printf(&quot;该链表的长度为:%d\n&quot;, Listlength(L));</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;恭喜你完成双向链表的全部基本操作!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表代码里面的基本内容也都是参照单向链表里面写的，只不过更进一步而已。而循环链表我没再写是因为只要把最后last-next从指向NULL改为指向头结点即可。具体操作跟单向链表几乎一模一样（当然你也可以从双向链表的基础上做也就是双向循环链表hhh）</p>
<p>还有就是，emmmm…我写的两个基本操作集里面的链表都是带头结点的，而且Ctrl A+Crtl C+Ctrl V是可以直接使用C语言编译器通过的。。。刚想起来补充上，还有一些可能想不起来了想起来的时候会更新哦！</p>
<p>大家也要加油鸭！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>android 右上角3个点的menu菜单的创建</title>
    <url>/2020/01/22/android-%E5%8F%B3%E4%B8%8A%E8%A7%923%E4%B8%AA%E7%82%B9%E7%9A%84menu%E8%8F%9C%E5%8D%95%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>直接在res文件中新建一个文件夹叫menu，往里面放menu文件，在需要的xml上面建立,<br>比如我在layout文件夹下有activity_catalog，那么我想在这个布局上面建立一个三个点的菜单，则我在menu下建立一个menu_catalog,然后下列代码就是一个例子<br>其中</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:context&#x3D;&quot;.CatalogActivity&quot;</span><br></pre></td></tr></table></figure>
<p>用来指定你要在哪个布局上建立三个点的菜单栏，然后<br>item用来添加菜单项，对应的属性就不多说了可以网上搜到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- Options menu for the CatalogActivity --&gt;</span><br><span class="line">    &lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">        xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">        xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">        tools:context&#x3D;&quot;.CatalogActivity&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;item</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;action_insert_dummy_data&quot;</span><br><span class="line">            android:title&#x3D;&quot;@string&#x2F;action_insert_dummy_data&quot;</span><br><span class="line">            app:showAsAction&#x3D;&quot;never&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;item</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;action_delete_all_entries&quot;</span><br><span class="line">            android:title&#x3D;&quot;@string&#x2F;action_delete_all_entries&quot;</span><br><span class="line">            app:showAsAction&#x3D;&quot;never&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio FloatingActionButton 在现版本的添加方式（3.4.2）</title>
    <url>/2020/01/22/android-studio-FloatingActionButton-%E5%9C%A8%E7%8E%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%BC%8F%EF%BC%883-4-2%EF%BC%89/</url>
    <content><![CDATA[<p>之前我在看优达学城的android基础开发（<a href="https://classroom.udacity.com/courses/ud845/lessons/f5bb088f-6cc0-4e7d-9985-1418654bb141/concepts/e6620651-469b-4754-9ac9-dc34f6f0b781/">https://classroom.udacity.com/courses/ud845/lessons/f5bb088f-6cc0-4e7d-9985-1418654bb141/concepts/e6620651-469b-4754-9ac9-dc34f6f0b781/</a>）<br>时遇到了问题（<a href="https://github.com/udacity/ud845-Pets/">https://github.com/udacity/ud845-Pets/</a>），就是它创建的主界面有一个floatingActionButton,但是需要特殊的支持。<br>百度后很多人说要引用这个：</p>
<a id="more"></a>
<p><strong>在build.gradle中加入：<br>　compile ‘com.android.support:design:26.0.0’</strong><br>实际上我的IDE中还是不可以，但是我使用了默认的方法，alt加enter，这样IDE自动加上了引用<br><strong>import com.google.android.material.floatingactionbutton.FloatingActionButton;</strong><br>原因可能是因为安卓版本的更新导致引用发生了变化，特记录下来方便以后查看。<br>引用时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;com.google.android.material.floatingactionbutton.FloatingActionButton</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;fab&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_alignParentRight&#x3D;&quot;true&quot;</span><br><span class="line">        android:layout_alignParentBottom&#x3D;&quot;true&quot;</span><br><span class="line">        android:layout_margin&#x3D;&quot;@dimen&#x2F;fab_margin&quot;</span><br><span class="line">        android:src&#x3D;&quot;@drawable&#x2F;ic_add_pet&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git将本地仓库push到远程仓库上(包括readme.md)</title>
    <url>/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/</url>
    <content><![CDATA[<p>1.在本地项目目录文件下右键鼠标点击git bash here，使用git init命令初始化一个新的仓库<br>2.在github上面新建一个项目（不初始化readme.md，最后我们会处理它）<br>3.git remote add origin + 远程仓库url</p>
<a id="more"></a>
<p>4.git add .<br>   git commit -m “说明”<br>   git push -u origin master<br>5.此时，刷新github上面的内容，发现已经提交到远程仓库上面了。<br>6.在github下面有一个create readme.md选项（如果你项目中没有readme.md的话），创建并编辑。<br>7.使用git pull origin master:master命令，将远程仓库上面的内容pull到本地仓库（因为此时远程仓库比本地仓库多一个readmd.md）<br>8.大功告成，给自己鼓掌，切记以后尽量不要再github上面直接编辑文件，需要在本地仓库改变文件后进行第4步即可。<br>9.若不小心在github上面动了代码也不要紧，使用第7步即可。</p>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/1.jpg" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]">  

<hr>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/2.png" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]">  

<hr>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/3.jpg" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]"> 

<hr>
<img src="/2020/01/22/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93push%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A-%E5%8C%85%E6%8B%ACreadme-md/4.png" class="" title="[使用git将本地仓库push到远程仓库上(包括readme.md)]">  
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题</title>
    <url>/2020/01/22/leetcode%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>上篇博客提到过，我在备战PAT时也是边看《大话数据结构》边做PAT和leetcode两个平台上面的题，而leetcode平台的题只需要写函数即可，不需要大局观的细节让你实现，所以对于练习算法还是很有帮助的，<a id="more"></a>  我大体就是按线性表-栈队列-树-图等顺序和专题刷的，这是我的链接：<a href="https://leetcode-cn.com/u/user4002g/">https://leetcode-cn.com/u/user4002g/</a></p>
<img src="/2020/01/22/leetcode%E5%88%B7%E9%A2%98/1.png" class="" title="[leetcode刷题]">  ]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年冬季PAT考试</title>
    <url>/2020/01/21/2019%E5%B9%B4%E5%86%AC%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>2019年12月7日，去参加了2019年冬季PAT考试，之前很早就知道PAT考试，而真正想开始考甲级还是2019年暑假，所以从8月5日，我就直接回学校，开始准备刷题，学数据结构了。</p>
<p>这篇博客虽然是写2019年冬季PAT考试的博客，但还是要记录一下自己备考那段经历，到现在一想确实觉得很感谢当时的自己。</p>
<a id="more"></a>

<hr>
<p>1.2019-8-5~2019-10-1：<br>这段时间一直在全身心备考，大概的时间段就是每天上午8-11：30和下午2-5点，然后5点过后就开始去健身房健身(每周1,3,5,7),晚上就放松玩一会，大概每天都是这么度过，当有课的话还是去上课的。学习的时间呢，就在PAT和leetcode两个平台上面刷题，分别用的IDE是VS2017和VS code，同时在ipad上下载了大话数据结构并跟着看，基本上考试之前都看完了。这段时间也是我感觉提升非常快的一段时间。</p>
<hr>
<p>2.2019-10-7~2019-12-7：<br>自从国庆跟女朋友去青岛玩之后一直到回来，因为玩的确实比较好，所以感觉从这后没有之前般努力了。不过即使这样，我还仍是坚持每天一道PAT甲级题库的题，leetcode的题反而不做了，因为确实两个题库侧重点不一样，我为了考PAT还是着重刷PAT的题。</p>
<p>so，最终考试考了98分，问题出在第一题，也就是20分的题，其实临最后一分钟的时候知道那个测试点问题出在哪里了，但我改完想提交上去时间也结束了。怎么说呢，确实有点可惜，不过这也说明我平时踩的坑比较少吧。不过第一次考了98分我还是比较满意(虽然后来得知确实题目很简单),但可能以后还会再继续备考吧，不过也说不准。</p>
<p>我今天从PAT甲级平台上看了一下，还是155道题，考试的四道题并没有传到题库中，不过大体依稀记得：<br>1.HelloWorld，输入输出题，但踩坑点在输入的字符中#位置不一定在哪，这也是我最后掉分的地方。<br>2.链表题，因为之前总结了链表题所以觉得不是很难，大概半小时写完了得了25(其实5分钟就写完了，但有个测试点错误，debug了25分钟)<br>3.非常简单的图论，我记得是一道给分配位置的DFS题，考前好像正好做到了<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552/">类似的题</a>。<br>4.一道建树题，应该是用的递归吧，我忘记了。当时一眼没看出来以为和根据前序遍历中序遍历推后序遍历类似，最后发现是用递归就可。</p>
<p>以上就是我的考试经历，我大二上半学期学的数据结构，当时学到后面觉得很难就放松了对它的努力，其实现在觉得，软件的最基本的内容就是数据结构，所以也是下定了决心要好好把它学好。我不是最聪明的学生，只想做最努力的，大三下半学期，考研加油！</p>
<p>我的个人博客友情链接里面有PAT我就不贴了，我每刷完一道题都会把它放到github上, 链接:<a href="https://github.com/MrSunCodes/PAT_AdvanceLevel/">https://github.com/MrSunCodes/PAT_AdvanceLevel</a></p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样在Hexo上写博客</title>
    <url>/2020/01/20/%E6%80%8E%E6%A0%B7%E5%9C%A8Hexo%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>编写博客的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>title是博客的名称，即显示到主页的title<br>此条命令会在source/posts文件夹中新建一个以title命名的md文件，只需修改其md文件后再</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<a id="more"></a>  

<p>执行上面两条命令即可将修改的md文件push到github上，即可通过网站访问，不过推荐先使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>在本地进行测试，这样更快而且只要本地服务器开着，就不需要再上传一遍才能看效果了，可以边看效果边修改，之后一并将修改的最终内容push到github。  </p>
<p>编写博客时，推荐使用有道云笔记(我使用的就是有道云笔记)：<a href="http://note.youdao.com/download.html">官网下载</a>  </p>
<p>使用有道云笔记编写Markdown文件后可以边编写边预览效果，最后编写完成后只需复制粘贴到之前的md文件中(使用记录本复制粘贴即可)</p>
<p>如果博客中有图片需要上传，首先找到项目根目录的_config.yml文件,修改post_asset_folder属性为true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>别忘再</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>此时再使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>创建新博客时，在source/posts中会生成title同名文件夹,只需将所有该博客需要的图片放入其中，然后在图片引用位置加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名.图片后缀 [title] %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>title直接就是该博客的title，不需要再加引号</strong></p>
<p>至于修改博客的样式，需要修改主目录下的 _config.yml文件，以及themes/你的主题下的 _config.yml文件，<br>这两个文件修改的部分请见示例：<br><a href="https://github.com/litten/hexo-theme-yilia/blob/master/_config.yml">主目录的_config.yml文件</a><br><a href="https://github.com/litten/BlogBackup/blob/master/_config.yml">主题下的 _config.yml文件</a></p>
<p>最后需要注意的是，默认情况主页会显示博客的所有内容，如果想让其精简，加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>即可<br>此时，该位置会显示more，点击就是该博客剩下的内容，而剩下的内容在主页中不会显示。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客-Hexo博客的建立与部署</title>
    <url>/2020/01/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<ol>
<li>首先下载node.js以及git(这两个都是hexo博客框架所需要的)<br>node.js:<a href="https://nodejs.org/en/">官网</a><br>git<a href="https://git-scm.com/downloads/">官网</a>  </li>
<li>安装Hexo<br>2.1首先，node.js下载并安装后是默认安装npm(项目管理工具)<br>2.2 因为npm是使用国外镜像，所以我们修改并使用淘宝的镜像，这样之后的命令执行速度会变快， 其下载命令是:  </li>
</ol>
<a id="more"></a>  

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>别忘测试hh，之前测试的命令分别为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">cnpm</span><br></pre></td></tr></table></figure>
<p>完成之后安装Hexo：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>检验Hexo是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>3.创建一个目录：(我的是放在了F:/MyBlog)<br>使用命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>这步是将框架初始化的内容添加到你刚才创建的文件夹中<br>4.运行测试：<br>常使用的四个命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   #上传到服务器</span><br></pre></td></tr></table></figure>
<p>运行时，先使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>打开浏览器的<strong>localhost:4000</strong>，即可发现本地登录成功。<br>我是部署到github上，不需要关心服务器租赁费以及域名等等问题，<br>首先在github上面创建一个新的仓库，名字就叫做[github用户名].github.io,然后在自己所创建的目录中[我的是F:/MyBlog]打开<strong>_config.yml文件</strong>，将其中的  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br></pre></td></tr></table></figure>
<p>字段填补完整为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;MrSunCodes&#x2F;MrSunCodes.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>repo中的地址及你在github上面创建的仓库地址。<br>最后，只需执行一条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>即可将本地的所有文件push到github仓库中，此时访问<br><a href="https://mrsuncodes.github.io/">blog</a>即你的用户名.github.io即可(可能需要多刷新几下)</p>
<img src="/2020/01/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%83%A8%E7%BD%B2/1.png" class="" title="[第一篇博客-Hexo博客的建立与部署]">  

<p>大功告成！个人博客已经搞起来了！剩下的就是编写博客以及修改主题等样式了，具体可看我的下一篇博客。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
